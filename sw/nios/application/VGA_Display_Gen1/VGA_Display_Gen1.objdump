
VGA_Display_Gen1.elf:     file format elf32-littlenios2
VGA_Display_Gen1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10100150

Program Header:
    LOAD off    0x00001000 vaddr 0x10100000 paddr 0x10100000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10100020 paddr 0x10100020 align 2**12
         filesz 0x00002140 memsz 0x00002140 flags r-x
    LOAD off    0x00003160 vaddr 0x10102160 paddr 0x101021d4 align 2**12
         filesz 0x00000074 memsz 0x00000074 flags rw-
    LOAD off    0x00003248 vaddr 0x10102248 paddr 0x10102248 align 2**12
         filesz 0x00000000 memsz 0x00000198 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10100000  10100000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000130  10100020  10100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001bd8  10100150  10100150  00001150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000438  10101d28  10101d28  00002d28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000074  10102160  101021d4  00003160  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000198  10102248  10102248  00003248  2**4
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  101023e0  101023e0  000031d4  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000031d4  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000420  00000000  00000000  000031f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00005357  00000000  00000000  00003618  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001bb3  00000000  00000000  0000896f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002120  00000000  00000000  0000a522  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000878  00000000  00000000  0000c644  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001894  00000000  00000000  0000cebc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000222e  00000000  00000000  0000e750  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  00010980  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000208  00000000  00000000  000109e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00012914  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00012917  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00012923  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00012924  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  00012925  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  00012930  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  0001293b  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000006  00000000  00000000  00012946  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002c  00000000  00000000  0001294c  2**0
                  CONTENTS, READONLY
 26 .jdi          00003cd3  00000000  00000000  00012978  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     002a8901  00000000  00000000  0001664b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10100000 l    d  .entry	00000000 .entry
10100020 l    d  .exceptions	00000000 .exceptions
10100150 l    d  .text	00000000 .text
10101d28 l    d  .rodata	00000000 .rodata
10102160 l    d  .rwdata	00000000 .rwdata
10102248 l    d  .bss	00000000 .bss
101023e0 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 /home/pokitoz/Dropbox/DE0_SoC_VGA/sw/nios/application/VGA_Display_Gen1_bsp//obj/HAL/src/crt0.o
10100198 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
10100094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 DMA_Read.c
00000000 l    df *ABS*	00000000 VGA_DMA_display.c
10101d80 l     O .rodata	00000060 msgdma.2781
00000000 l    df *ABS*	00000000 VGA_Display.c
00000000 l    df *ABS*	00000000 msgDMA.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
101006f8 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
10102160 l     O .rwdata	00000060 msgdma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_msgdma.c
10100cc8 l     F .text	000000cc alt_msgdma_irq
10100d94 l     F .text	00000068 alt_msgdma_write_extended_descriptor
10100dfc l     F .text	00000230 alt_msgdma_descriptor_sync_transfer
1010102c l     F .text	00000190 alt_msgdma_descriptor_async_transfer
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
10101aec g     F .text	00000008 alt_msgdma_standard_descriptor_async_transfer
10100a48 g     F .text	0000002c alt_main
101022e0 g     O .bss	00000100 alt_irq
101021d4 g       *ABS*	00000000 __flash_rwdata_start
10100300 g     F .text	00000014 VGA_Display_changeVerticalPorch
1010122c g     F .text	0000003c alt_msgdma_construct_standard_mm_to_mm_descriptor
101005c4 g     F .text	00000134 msgdma_create_mm_to_st_descriptor_list
10102250 g     O .bss	00000004 descriptor_number
101011bc g     F .text	00000038 alt_msgdma_construct_standard_st_to_mm_descriptor
10100c28 g     F .text	00000038 alt_putstr
00000000  w      *UND*	00000000 __errno
10100000 g     F .entry	0000001c __reset
1010019c g     F .text	00000010 DMA_Read_configureDMA
10100020 g       *ABS*	00000000 __flash_exceptions_start
10102264 g     O .bss	00000004 errno
1010225c g     O .bss	00000004 alt_argv
1010a1c0 g       *ABS*	00000000 _gp
10101778 g     F .text	00000048 alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
10101c1c g     F .text	00000074 alt_find_dev
10100824 g     F .text	00000028 memcpy
10101934 g     F .text	0000006c alt_msgdma_start_prefetcher_with_extd_desc_list
10101af4 g     F .text	0000000c alt_msgdma_extended_descriptor_async_transfer
10101adc g     F .text	00000010 alt_msgdma_register_callback
101001ac g     F .text	00000008 DMA_Read_setFlags
10101690 g     F .text	00000050 alt_msgdma_prefetcher_add_standard_desc_to_list
10100000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
10100814 g     F .text	00000008 .hidden __udivsi3
10102248 g     O .bss	00000004 next_desc
10101ca4 g     F .text	00000038 alt_icache_flush
10101434 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
101023e0 g       *ABS*	00000000 __bss_end
101008e8 g     F .text	00000068 alt_iic_isr_register
101019f8 g     F .text	000000e4 alt_msgdma_init
10101b08 g     F .text	0000000c alt_msgdma_extended_descriptor_sync_transfer
101008d0 g     F .text	00000018 alt_ic_irq_enabled
10102254 g     O .bss	00000004 alt_irq_active
101000ec g     F .exceptions	00000064 alt_irq_handler
101012e0 g     F .text	00000078 alt_msgdma_construct_extended_mm_to_st_descriptor
101018c8 g     F .text	0000006c alt_msgdma_start_prefetcher_with_std_desc_list
10101b8c g     F .text	00000018 alt_dcache_flush_all
101021d4 g       *ABS*	00000000 __ram_rwdata_end
10102160 g       *ABS*	00000000 __ram_rodata_end
101021c4 g     O .rwdata	00000004 jtag_uart_0
1010081c g     F .text	00000008 .hidden __umodsi3
1010147c g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
101023e0 g       *ABS*	00000000 end
10104000 g       *ABS*	00000000 __alt_stack_pointer
10100c94 g     F .text	00000034 altera_avalon_jtag_uart_write
10100a74 g     F .text	0000016c alt_printf
10100150 g     F .text	0000004c _start
101011f4 g     F .text	00000038 alt_msgdma_construct_standard_mm_to_st_descriptor
10100c80 g     F .text	00000014 alt_sys_init
10100330 g     F .text	00000040 VGA_Display_set_irq
10102160 g       *ABS*	00000000 __ram_rwdata_start
10101d28 g       *ABS*	00000000 __ram_rodata_start
10102270 g     O .bss	00000060 msgdma_dev
101022d0 g     O .bss	00000010 msgdma_desc
10101b14 g     F .text	00000078 alt_busy_sleep
101013e8 g     F .text	0000004c alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
10101cdc g     F .text	00000030 memcmp
101023e0 g       *ABS*	00000000 __alt_stack_base
101014c4 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
10101ba4 g     F .text	00000078 alt_dev_llist_insert
10102248 g       *ABS*	00000000 __bss_start
101019a0 g     F .text	00000058 alt_msgdma_open
10100220 g     F .text	000000e0 main
10102258 g     O .bss	00000004 alt_envp
101016e0 g     F .text	00000064 alt_msgdma_prefetcher_add_extended_desc_to_list
101017c0 g     F .text	00000108 alt_msgdma_start_prefetcher_with_list_addr
101021d0 g     O .rwdata	00000004 alt_errno
101015e4 g     F .text	000000ac alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
10100764 g     F .text	00000054 .hidden __divsi3
10101d28 g       *ABS*	00000000 __flash_rodata_start
10100c60 g     F .text	00000020 alt_irq_init
10101b00 g     F .text	00000008 alt_msgdma_standard_descriptor_sync_transfer
10101554 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
10102260 g     O .bss	00000004 alt_argc
101001b4 g     F .text	0000006c irq_vsync
10100020 g       .exceptions	00000000 alt_irq_entry
10100020 g       *ABS*	00000000 __ram_exceptions_start
1010084c g     F .text	00000004 alt_ic_isr_register
101021d4 g       *ABS*	00000000 _edata
101023e0 g       *ABS*	00000000 _end
10100150 g       *ABS*	00000000 __ram_exceptions_end
10100314 g     F .text	00000014 VGA_Display_changeHorizontalPorch
10100890 g     F .text	00000040 alt_ic_irq_disable
10100328 g     F .text	00000008 VGA_Display_changeScreenColor
10101c9c g     F .text	00000008 altera_nios2_qsys_irq_init
10101744 g     F .text	00000034 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
101007b8 g     F .text	0000005c .hidden __modsi3
10104000 g       *ABS*	00000000 __alt_data_end
10100020 g     F .exceptions	00000000 alt_exception
10100370 g     F .text	000000f4 msgdma_transfer
10101358 g     F .text	00000090 alt_msgdma_construct_extended_mm_to_mm_descriptor
10101268 g     F .text	00000078 alt_msgdma_construct_extended_st_to_mm_descriptor
1010001c g       .entry	00000000 _exit
101021c8 g     O .rwdata	00000008 alt_msgdma_list
10101d0c g     F .text	0000001c strlen
10100be0 g     F .text	00000048 alt_putchar
1010224c g     O .bss	00000004 vsync
10101c90 g     F .text	0000000c alt_icache_flush_all
101021c0 g     O .rwdata	00000004 alt_priority_mask
10100850 g     F .text	00000040 alt_ic_irq_enable
10100464 g     F .text	00000160 msgdma_create_mm_to_mm_descriptor_list
10100950 g     F .text	000000f8 alt_load



Disassembly of section .entry:

10100000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10100000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10100004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10100008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1010000c:	00bffd16 	blt	zero,r2,10100004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10100010:	00440434 	movhi	at,4112
    ori r1, r1, %lo(_start)
10100014:	08405414 	ori	at,at,336
    jmp r1
10100018:	0800683a 	jmp	at

1010001c <_exit>:
1010001c:	00000000 	call	10000000 <__alt_mem_onchip_memory2_0-0x100000>

Disassembly of section .exceptions:

10100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
10100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
10100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
10100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1010002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1010003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
10100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
10100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1010004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1010005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1010006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1010007c:	10000326 	beq	r2,zero,1010008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10100080:	20000226 	beq	r4,zero,1010008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10100084:	01000ec0 	call	101000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10100088:	00000306 	br	10100098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1010008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10100090:	e8bfff17 	ldw	r2,-4(ea)

10100094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10100094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10100098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1010009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
101000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
101000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
101000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
101000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
101000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
101000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
101000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
101000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
101000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
101000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
101000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
101000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
101000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
101000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
101000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
101000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
101000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
101000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
101000e8:	ef80083a 	eret

101000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
101000ec:	defffe04 	addi	sp,sp,-8
101000f0:	dfc00115 	stw	ra,4(sp)
101000f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
101000f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
101000fc:	04040434 	movhi	r16,4112
10100100:	8408b804 	addi	r16,r16,8928

  active = alt_irq_pending ();

  do
  {
    i = 0;
10100104:	0005883a 	mov	r2,zero
    mask = 1;
10100108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
1010010c:	190a703a 	and	r5,r3,r4
10100110:	28000c26 	beq	r5,zero,10100144 <alt_irq_handler+0x58>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10100114:	100490fa 	slli	r2,r2,3
10100118:	8087883a 	add	r3,r16,r2
1010011c:	1805883a 	mov	r2,r3
10100120:	11000117 	ldw	r4,4(r2)
10100124:	18c00017 	ldw	r3,0(r3)
10100128:	183ee83a 	callr	r3
1010012c:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10100130:	203ff41e 	bne	r4,zero,10100104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
10100134:	dfc00117 	ldw	ra,4(sp)
10100138:	dc000017 	ldw	r16,0(sp)
1010013c:	dec00204 	addi	sp,sp,8
10100140:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10100144:	18c7883a 	add	r3,r3,r3
      i++;
10100148:	10800044 	addi	r2,r2,1

    } while (1);
1010014c:	003fef06 	br	1010010c <alt_irq_handler+0x20>

Disassembly of section .text:

10100150 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10100150:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
10100154:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
10100158:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
1010015c:	00bffd16 	blt	zero,r2,10100154 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10100160:	06c40434 	movhi	sp,4112
    ori sp, sp, %lo(__alt_stack_pointer)
10100164:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
10100168:	06840434 	movhi	gp,4112
    ori gp, gp, %lo(_gp)
1010016c:	d6a87014 	ori	gp,gp,41408
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
10100170:	00840434 	movhi	r2,4112
    ori r2, r2, %lo(__bss_start)
10100174:	10889214 	ori	r2,r2,8776

    movhi r3, %hi(__bss_end)
10100178:	00c40434 	movhi	r3,4112
    ori r3, r3, %lo(__bss_end)
1010017c:	18c8f814 	ori	r3,r3,9184

    beq r2, r3, 1f
10100180:	10c00326 	beq	r2,r3,10100190 <_start+0x40>

0:
    stw zero, (r2)
10100184:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
10100188:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
1010018c:	10fffd36 	bltu	r2,r3,10100184 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
10100190:	01009500 	call	10100950 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
10100194:	0100a480 	call	10100a48 <alt_main>

10100198 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
10100198:	003fff06 	br	10100198 <alt_after_alt_main>

1010019c <DMA_Read_configureDMA>:

void DMA_Read_configureDMA(alt_u32 base, alt_u32 buffer1_addr,
							alt_u32 buffer2_addr,
							alt_u32 transfer_size){

	IOWR_32DIRECT(base, DMA_READ_BUFFER_1_ADDR_REG, buffer1_addr);
1010019c:	21400035 	stwio	r5,0(r4)
	IOWR_32DIRECT(base, DMA_READ_BUFFER_2_ADDR_REG, buffer2_addr);
101001a0:	21800135 	stwio	r6,4(r4)
	IOWR_32DIRECT(base, DMA_READ_TRANSFER_LENGTH_REG, transfer_size);
101001a4:	21c00235 	stwio	r7,8(r4)
101001a8:	f800283a 	ret

101001ac <DMA_Read_setFlags>:
}


void DMA_Read_setFlags(alt_u32 base, alt_u32 flags) {
	IOWR_32DIRECT(base, DMA_READ_CONFIGURATION_REG, flags);
101001ac:	21400435 	stwio	r5,16(r4)
101001b0:	f800283a 	ret

101001b4 <irq_vsync>:

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
101001b4:	defffe04 	addi	sp,sp,-8
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
101001b8:	01040434 	movhi	r4,4112
101001bc:	01440434 	movhi	r5,4112
101001c0:	d8000015 	stw	zero,0(sp)
101001c4:	21089c04 	addi	r4,r4,8816
101001c8:	2948b404 	addi	r5,r5,8912
101001cc:	01900004 	movi	r6,16384
101001d0:	01c0a004 	movi	r7,640

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
101001d4:	dfc00115 	stw	ra,4(sp)
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
101001d8:	01011f40 	call	101011f4 <alt_msgdma_construct_standard_mm_to_st_descriptor>
			&msgdma_desc, VGA_DISPLAY_ADDRESS_DST_IMAGE, 640, 0);

	next_desc++;
101001dc:	d0a02217 	ldw	r2,-32632(gp)
101001e0:	10800044 	addi	r2,r2,1
101001e4:	d0a02215 	stw	r2,-32632(gp)
	vsync++;
101001e8:	d0a02317 	ldw	r2,-32628(gp)
101001ec:	10800044 	addi	r2,r2,1
101001f0:	d0a02315 	stw	r2,-32628(gp)
	if (next_desc == descriptor_number) {
101001f4:	d0e02217 	ldw	r3,-32632(gp)
101001f8:	d0a02417 	ldw	r2,-32624(gp)
101001fc:	1880011e 	bne	r3,r2,10100204 <irq_vsync+0x50>
		next_desc = 0;
10100200:	d0202215 	stw	zero,-32632(gp)
	}

	//alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);

	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);
10100204:	00840034 	movhi	r2,4096
10100208:	10821704 	addi	r2,r2,2140
1010020c:	00c00044 	movi	r3,1
10100210:	10c00035 	stwio	r3,0(r2)

}
10100214:	dfc00117 	ldw	ra,4(sp)
10100218:	dec00204 	addi	sp,sp,8
1010021c:	f800283a 	ret

10100220 <main>:

int main(void) {

	alt_putstr("Hello from VGA_DMA project!\n");
10100220:	01040434 	movhi	r4,4112
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
10100224:	defffd04 	addi	sp,sp,-12

	alt_putstr("Hello from VGA_DMA project!\n");
10100228:	21074a04 	addi	r4,r4,7464
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
1010022c:	dfc00215 	stw	ra,8(sp)
10100230:	dc000115 	stw	r16,4(sp)

	alt_putstr("Hello from VGA_DMA project!\n");
10100234:	0100c280 	call	10100c28 <alt_putstr>

	VGA_Display_changeScreenColor(VGA_MODULE_0_BASE, 0x00FF00FF);
10100238:	01040034 	movhi	r4,4096
1010023c:	01403ff4 	movhi	r5,255
10100240:	21021004 	addi	r4,r4,2112
10100244:	29403fc4 	addi	r5,r5,255
10100248:	01003280 	call	10100328 <VGA_Display_changeScreenColor>

	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CONFIGURATION, 0x1);
1010024c:	00840034 	movhi	r2,4096
10100250:	04000044 	movi	r16,1
10100254:	10821104 	addi	r2,r2,2116
10100258:	14000035 	stwio	r16,0(r2)

	ALTERA_MSGDMA_CSR_DESCRIPTOR_SLAVE_INSTANCE(MSGDMA_0, MSGDMA_0_CSR,
			MSGDMA_0_DESCRIPTOR_SLAVE, msgdma);

	msgdma_dev = msgdma;
1010025c:	01040434 	movhi	r4,4112
10100260:	01440434 	movhi	r5,4112
10100264:	21089c04 	addi	r4,r4,8816
10100268:	29476004 	addi	r5,r5,7552
1010026c:	01801804 	movi	r6,96
10100270:	01008240 	call	10100824 <memcpy>
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID,
10100274:	01040434 	movhi	r4,4112
10100278:	21089c04 	addi	r4,r4,8816
1010027c:	000b883a 	mov	r5,zero
10100280:	800d883a 	mov	r6,r16
10100284:	01019f80 	call	101019f8 <alt_msgdma_init>
10100288:	0005883a 	mov	r2,zero

	// Enable the interrupts
//	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
//	VGA_MODULE_0_IRQ);
	int ki = 0;
	for(ki = 0; ki < 640*480*3; ki++){
1010028c:	00c03874 	movhi	r3,225
		IOWR(HPS_0_BRIDGES_BASE, 4*ki, 0x00);
10100290:	10000035 	stwio	zero,0(r2)
10100294:	10800404 	addi	r2,r2,16

	// Enable the interrupts
//	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
//	VGA_MODULE_0_IRQ);
	int ki = 0;
	for(ki = 0; ki < 640*480*3; ki++){
10100298:	10fffd1e 	bne	r2,r3,10100290 <main+0x70>
		IOWR(HPS_0_BRIDGES_BASE, 4*ki, 0x00);
	}


	DMA_Read_configureDMA(0x10000820, HPS_0_BRIDGES_BASE, HPS_0_BRIDGES_BASE, 640*480*3);
1010029c:	01040034 	movhi	r4,4096
101002a0:	01c003b4 	movhi	r7,14
101002a4:	21020804 	addi	r4,r4,2080
101002a8:	000b883a 	mov	r5,zero
101002ac:	000d883a 	mov	r6,zero
101002b0:	39c40004 	addi	r7,r7,4096
101002b4:	010019c0 	call	1010019c <DMA_Read_configureDMA>
	DMA_Read_setFlags(0x10000820, DMA_READ_BIT_DMA_CONSTANT | DMA_READ_BIT_CONSTANT |  DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);
101002b8:	01040034 	movhi	r4,4096
101002bc:	21020804 	addi	r4,r4,2080
101002c0:	01401b04 	movi	r5,108
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002c4:	040003f4 	movhi	r16,15
		IOWR(HPS_0_BRIDGES_BASE, 4*ki, 0x00);
	}


	DMA_Read_configureDMA(0x10000820, HPS_0_BRIDGES_BASE, HPS_0_BRIDGES_BASE, 640*480*3);
	DMA_Read_setFlags(0x10000820, DMA_READ_BIT_DMA_CONSTANT | DMA_READ_BIT_CONSTANT |  DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);
101002c8:	01001ac0 	call	101001ac <DMA_Read_setFlags>
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002cc:	84108fc4 	addi	r16,r16,16959


	DMA_Read_configureDMA(0x10000820, HPS_0_BRIDGES_BASE, HPS_0_BRIDGES_BASE, 640*480*3);
	DMA_Read_setFlags(0x10000820, DMA_READ_BIT_DMA_CONSTANT | DMA_READ_BIT_CONSTANT |  DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);

	volatile int kk = 0;
101002d0:	d8000015 	stw	zero,0(sp)
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
101002d4:	d1602217 	ldw	r5,-32632(gp)
101002d8:	01040434 	movhi	r4,4112
101002dc:	21075204 	addi	r4,r4,7496
101002e0:	0100a740 	call	10100a74 <alt_printf>
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002e4:	d8000015 	stw	zero,0(sp)
101002e8:	d8800017 	ldw	r2,0(sp)
101002ec:	80bff916 	blt	r16,r2,101002d4 <main+0xb4>
101002f0:	d8800017 	ldw	r2,0(sp)
101002f4:	10800044 	addi	r2,r2,1
101002f8:	d8800015 	stw	r2,0(sp)
101002fc:	003ffa06 	br	101002e8 <main+0xc8>

10100300 <VGA_Display_changeVerticalPorch>:
#include "alt_types.h"
#include "system.h"
#include "sys/alt_irq.h"

void VGA_Display_changeVerticalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
10100300:	300c943a 	slli	r6,r6,16
10100304:	297fffcc 	andi	r5,r5,65535
10100308:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_V_REG, concatenated);
1010030c:	21400235 	stwio	r5,8(r4)
10100310:	f800283a 	ret

10100314 <VGA_Display_changeHorizontalPorch>:

}

void VGA_Display_changeHorizontalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
10100314:	300c943a 	slli	r6,r6,16
10100318:	297fffcc 	andi	r5,r5,65535
1010031c:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_H_REG, concatenated);
10100320:	21400335 	stwio	r5,12(r4)
10100324:	f800283a 	ret

10100328 <VGA_Display_changeScreenColor>:
}

void VGA_Display_changeScreenColor(alt_u32 BASE, alt_u32 color) {
	IOWR_32DIRECT(BASE, VGA_DISPLAY_COLOR_REG, color);
10100328:	21400035 	stwio	r5,0(r4)
1010032c:	f800283a 	ret

10100330 <VGA_Display_set_irq>:
}

void VGA_Display_set_irq(void (*irq_handler)(void*, alt_u32)) {
10100330:	defffd04 	addi	sp,sp,-12
10100334:	dfc00215 	stw	ra,8(sp)
10100338:	d9000115 	stw	r4,4(sp)

	if (irq_handler != NULL) {
1010033c:	20000926 	beq	r4,zero,10100364 <VGA_Display_set_irq+0x34>
		// Register the ISR for sync
		alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100340:	0009883a 	mov	r4,zero
10100344:	000b883a 	mov	r5,zero
10100348:	d8000015 	stw	zero,0(sp)
1010034c:	d9800104 	addi	r6,sp,4
10100350:	000f883a 	mov	r7,zero
10100354:	010084c0 	call	1010084c <alt_ic_isr_register>
				VGA_MODULE_0_IRQ, (void*) &irq_handler, 0, 0);

		// Enable the interrupts
		alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100358:	0009883a 	mov	r4,zero
1010035c:	000b883a 	mov	r5,zero
10100360:	01008500 	call	10100850 <alt_ic_irq_enable>
				VGA_MODULE_0_IRQ);
	}

}
10100364:	dfc00217 	ldw	ra,8(sp)
10100368:	dec00304 	addi	sp,sp,12
1010036c:	f800283a 	ret

10100370 <msgdma_transfer>:
#include "msgDMA.h"
#include <stdint-gcc.h>
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {
10100370:	defffa04 	addi	sp,sp,-24
10100374:	dd000415 	stw	r20,16(sp)
10100378:	dcc00315 	stw	r19,12(sp)
1010037c:	dc800215 	stw	r18,8(sp)
10100380:	dc400115 	stw	r17,4(sp)
10100384:	dc000015 	stw	r16,0(sp)
10100388:	dfc00515 	stw	ra,20(sp)
1010038c:	2027883a 	mov	r19,r4
10100390:	2829883a 	mov	r20,r5
10100394:	3025883a 	mov	r18,r6

	unsigned int i = 0;
	unsigned int error_dma = 0;
10100398:	0021883a 	mov	r16,zero
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {

	unsigned int i = 0;
1010039c:	0023883a 	mov	r17,zero
	unsigned int error_dma = 0;

	while (i < descriptor_number) {
101003a0:	8c80282e 	bgeu	r17,r18,10100444 <msgdma_transfer+0xd4>

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);
101003a4:	8804913a 	slli	r2,r17,4

	while (i < descriptor_number) {

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
101003a8:	9809883a 	mov	r4,r19
101003ac:	a08b883a 	add	r5,r20,r2
101003b0:	0101aec0 	call	10101aec <alt_msgdma_standard_descriptor_async_transfer>
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
101003b4:	00fff904 	movi	r3,-28
101003b8:	10c0041e 	bne	r2,r3,101003cc <msgdma_transfer+0x5c>
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003bc:	01040434 	movhi	r4,4112

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
			error_dma++;
101003c0:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003c4:	21077804 	addi	r4,r4,7648
101003c8:	00000506 	br	101003e0 <msgdma_transfer+0x70>
		} else if (result == -ETIME) {
101003cc:	00fff084 	movi	r3,-62
101003d0:	10c0051e 	bne	r2,r3,101003e8 <msgdma_transfer+0x78>
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003d4:	01040434 	movhi	r4,4112

		if ((result == -ENOSPC)) {
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
101003d8:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003dc:	21078304 	addi	r4,r4,7692
101003e0:	0100a740 	call	10100a74 <alt_printf>
101003e4:	00000b06 	br	10100414 <msgdma_transfer+0xa4>
		} else if (result == -EPERM) {
101003e8:	00ffffc4 	movi	r3,-1
101003ec:	10c0041e 	bne	r2,r3,10100400 <msgdma_transfer+0x90>
			error_dma++;
			alt_printf(
101003f0:	01040434 	movhi	r4,4112
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
		} else if (result == -EPERM) {
			error_dma++;
101003f4:	84000044 	addi	r16,r16,1
			alt_printf(
101003f8:	21078f04 	addi	r4,r4,7740
101003fc:	003ff806 	br	101003e0 <msgdma_transfer+0x70>
					"msgdma_transfer dma_mm_interface_read: operation not permitted due to descriptor type conflict\n");
		} else {
			i++;
10100400:	8c400044 	addi	r17,r17,1
			alt_printf(
10100404:	01040434 	movhi	r4,4112
10100408:	2107a704 	addi	r4,r4,7836
1010040c:	880b883a 	mov	r5,r17
10100410:	0100a740 	call	10100a74 <alt_printf>
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
10100414:	00801904 	movi	r2,100
10100418:	80bfe11e 	bne	r16,r2,101003a0 <msgdma_transfer+0x30>
			alt_printf("Error DMA exceeded\n");
1010041c:	01040434 	movhi	r4,4112
10100420:	2107ba04 	addi	r4,r4,7912
		}

	}

	//alt_printf("Transfer successful\n");
}
10100424:	dfc00517 	ldw	ra,20(sp)
10100428:	dd000417 	ldw	r20,16(sp)
1010042c:	dcc00317 	ldw	r19,12(sp)
10100430:	dc800217 	ldw	r18,8(sp)
10100434:	dc400117 	ldw	r17,4(sp)
10100438:	dc000017 	ldw	r16,0(sp)
1010043c:	dec00604 	addi	sp,sp,24
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
			alt_printf("Error DMA exceeded\n");
10100440:	0100a741 	jmpi	10100a74 <alt_printf>
		}

	}

	//alt_printf("Transfer successful\n");
}
10100444:	dfc00517 	ldw	ra,20(sp)
10100448:	dd000417 	ldw	r20,16(sp)
1010044c:	dcc00317 	ldw	r19,12(sp)
10100450:	dc800217 	ldw	r18,8(sp)
10100454:	dc400117 	ldw	r17,4(sp)
10100458:	dc000017 	ldw	r16,0(sp)
1010045c:	dec00604 	addi	sp,sp,24
10100460:	f800283a 	ret

10100464 <msgdma_create_mm_to_mm_descriptor_list>:

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100464:	defff204 	addi	sp,sp,-56
10100468:	dc000415 	stw	r16,16(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
1010046c:	d8800e17 	ldw	r2,56(sp)
uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
10100470:	24001217 	ldw	r16,72(r4)
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100474:	dd800a15 	stw	r22,40(sp)
10100478:	dd400915 	stw	r21,36(sp)
1010047c:	202d883a 	mov	r22,r4
10100480:	282b883a 	mov	r21,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100484:	113fffc4 	addi	r4,r2,-1
10100488:	800b883a 	mov	r5,r16
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
1010048c:	df000c15 	stw	fp,48(sp)
10100490:	dcc00715 	stw	r19,28(sp)
10100494:	dfc00d15 	stw	ra,52(sp)
10100498:	ddc00b15 	stw	r23,44(sp)
1010049c:	dd000815 	stw	r20,32(sp)
101004a0:	dc800615 	stw	r18,24(sp)
101004a4:	dc400515 	stw	r17,20(sp)
101004a8:	3027883a 	mov	r19,r6
101004ac:	d9c00315 	stw	r7,12(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101004b0:	01008140 	call	10100814 <__udivsi3>
101004b4:	1039883a 	mov	fp,r2
101004b8:	10800044 	addi	r2,r2,1
101004bc:	d8800215 	stw	r2,8(sp)

	if (msgdma_desc == NULL) {
101004c0:	a800051e 	bne	r21,zero,101004d8 <msgdma_create_mm_to_mm_descriptor_list+0x74>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
101004c4:	01040434 	movhi	r4,4112
101004c8:	2107bf04 	addi	r4,r4,7932
101004cc:	0100a740 	call	10100a74 <alt_printf>
		return 0;
101004d0:	0005883a 	mov	r2,zero
101004d4:	00002f06 	br	10100594 <msgdma_create_mm_to_mm_descriptor_list+0x130>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
101004d8:	d9800217 	ldw	r6,8(sp)
101004dc:	01040434 	movhi	r4,4112
101004e0:	2107cc04 	addi	r4,r4,7984
101004e4:	800b883a 	mov	r5,r16
101004e8:	0100a740 	call	10100a74 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;
101004ec:	dc800317 	ldw	r18,12(sp)
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
101004f0:	9823883a 	mov	r17,r19
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
101004f4:	0029883a 	mov	r20,zero
101004f8:	a02e913a 	slli	r23,r20,4
101004fc:	a7001126 	beq	r20,fp,10100544 <msgdma_create_mm_to_mm_descriptor_list+0xe0>
		alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100500:	01040434 	movhi	r4,4112
10100504:	a00b883a 	mov	r5,r20
10100508:	880d883a 	mov	r6,r17
1010050c:	900f883a 	mov	r7,r18
10100510:	2107d904 	addi	r4,r4,8036
10100514:	0100a740 	call	10100a74 <alt_printf>
				_address_dst_descriptor);

		alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma,
10100518:	880d883a 	mov	r6,r17
1010051c:	900f883a 	mov	r7,r18
10100520:	dc000015 	stw	r16,0(sp)
10100524:	d8000115 	stw	zero,4(sp)
10100528:	b009883a 	mov	r4,r22
1010052c:	adcb883a 	add	r5,r21,r23
10100530:	010122c0 	call	1010122c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor,
				(uint32_t *) _address_dst_descriptor, max_descriptor_size, 0);
		_address_dst_descriptor += max_descriptor_size;
10100534:	9425883a 	add	r18,r18,r16
		_address_src_descriptor += max_descriptor_size;
10100538:	8c23883a 	add	r17,r17,r16

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010053c:	a5000044 	addi	r20,r20,1
10100540:	003fed06 	br	101004f8 <msgdma_create_mm_to_mm_descriptor_list+0x94>
10100544:	a421383a 	mul	r16,r20,r16
10100548:	d8800317 	ldw	r2,12(sp)
		_address_dst_descriptor += max_descriptor_size;
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
1010054c:	01040434 	movhi	r4,4112
10100550:	9c27883a 	add	r19,r19,r16
10100554:	1425883a 	add	r18,r2,r16
10100558:	2107d904 	addi	r4,r4,8036
1010055c:	a00b883a 	mov	r5,r20
10100560:	980d883a 	mov	r6,r19
10100564:	900f883a 	mov	r7,r18
10100568:	0100a740 	call	10100a74 <alt_printf>
			_address_dst_descriptor);
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma, msgdma_desc + i,
1010056c:	d8800e17 	ldw	r2,56(sp)
10100570:	d8000115 	stw	zero,4(sp)
10100574:	b009883a 	mov	r4,r22
10100578:	1421c83a 	sub	r16,r2,r16
1010057c:	dc000015 	stw	r16,0(sp)
10100580:	adcb883a 	add	r5,r21,r23
10100584:	980d883a 	mov	r6,r19
10100588:	900f883a 	mov	r7,r18
1010058c:	010122c0 	call	1010122c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
			(uint32_t *) _address_src_descriptor,
			(uint32_t *) _address_dst_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
10100590:	d8800217 	ldw	r2,8(sp)
}
10100594:	dfc00d17 	ldw	ra,52(sp)
10100598:	df000c17 	ldw	fp,48(sp)
1010059c:	ddc00b17 	ldw	r23,44(sp)
101005a0:	dd800a17 	ldw	r22,40(sp)
101005a4:	dd400917 	ldw	r21,36(sp)
101005a8:	dd000817 	ldw	r20,32(sp)
101005ac:	dcc00717 	ldw	r19,28(sp)
101005b0:	dc800617 	ldw	r18,24(sp)
101005b4:	dc400517 	ldw	r17,20(sp)
101005b8:	dc000417 	ldw	r16,16(sp)
101005bc:	dec00e04 	addi	sp,sp,56
101005c0:	f800283a 	ret

101005c4 <msgdma_create_mm_to_st_descriptor_list>:



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005c4:	defff404 	addi	sp,sp,-48
101005c8:	dc000215 	stw	r16,8(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
101005cc:	24001217 	ldw	r16,72(r4)



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005d0:	dd400715 	stw	r21,28(sp)
101005d4:	dd000615 	stw	r20,24(sp)
101005d8:	202b883a 	mov	r21,r4
101005dc:	2829883a 	mov	r20,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101005e0:	393fffc4 	addi	r4,r7,-1
101005e4:	800b883a 	mov	r5,r16



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005e8:	df000a15 	stw	fp,40(sp)
101005ec:	dd800815 	stw	r22,32(sp)
101005f0:	dcc00515 	stw	r19,20(sp)
101005f4:	dfc00b15 	stw	ra,44(sp)
101005f8:	ddc00915 	stw	r23,36(sp)
101005fc:	dc800415 	stw	r18,16(sp)
10100600:	dc400315 	stw	r17,12(sp)
10100604:	3027883a 	mov	r19,r6
10100608:	382d883a 	mov	r22,r7

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
1010060c:	01008140 	call	10100814 <__udivsi3>
10100610:	1039883a 	mov	fp,r2
10100614:	10800044 	addi	r2,r2,1
10100618:	d8800115 	stw	r2,4(sp)

	if (msgdma_desc == NULL) {
1010061c:	a000051e 	bne	r20,zero,10100634 <msgdma_create_mm_to_st_descriptor_list+0x70>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
10100620:	01040434 	movhi	r4,4112
10100624:	2107bf04 	addi	r4,r4,7932
10100628:	0100a740 	call	10100a74 <alt_printf>
		return 0;
1010062c:	0005883a 	mov	r2,zero
10100630:	00002506 	br	101006c8 <msgdma_create_mm_to_st_descriptor_list+0x104>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
10100634:	d9800117 	ldw	r6,4(sp)
10100638:	01040434 	movhi	r4,4112
1010063c:	2107cc04 	addi	r4,r4,7984
10100640:	800b883a 	mov	r5,r16
10100644:	0100a740 	call	10100a74 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100648:	9825883a 	mov	r18,r19

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010064c:	0023883a 	mov	r17,zero
10100650:	882e913a 	slli	r23,r17,4
10100654:	8f000e26 	beq	r17,fp,10100690 <msgdma_create_mm_to_st_descriptor_list+0xcc>
		alt_printf("i=%d, src=0x%x\n", i, _address_src_descriptor);
10100658:	01040434 	movhi	r4,4112
1010065c:	880b883a 	mov	r5,r17
10100660:	900d883a 	mov	r6,r18
10100664:	2107e004 	addi	r4,r4,8064
10100668:	0100a740 	call	10100a74 <alt_printf>

		alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma,
1010066c:	900d883a 	mov	r6,r18
10100670:	d8000015 	stw	zero,0(sp)
10100674:	a809883a 	mov	r4,r21
10100678:	a5cb883a 	add	r5,r20,r23
1010067c:	800f883a 	mov	r7,r16
10100680:	01011f40 	call	101011f4 <alt_msgdma_construct_standard_mm_to_st_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;
10100684:	9425883a 	add	r18,r18,r16
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100688:	8c400044 	addi	r17,r17,1
1010068c:	003ff006 	br	10100650 <msgdma_create_mm_to_st_descriptor_list+0x8c>
10100690:	8c21383a 	mul	r16,r17,r16
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor);
10100694:	01040434 	movhi	r4,4112
10100698:	2107d904 	addi	r4,r4,8036
1010069c:	9c27883a 	add	r19,r19,r16
101006a0:	880b883a 	mov	r5,r17
101006a4:	980d883a 	mov	r6,r19
101006a8:	0100a740 	call	10100a74 <alt_printf>
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma, msgdma_desc + i,
101006ac:	a809883a 	mov	r4,r21
101006b0:	d8000015 	stw	zero,0(sp)
101006b4:	a5cb883a 	add	r5,r20,r23
101006b8:	980d883a 	mov	r6,r19
101006bc:	b40fc83a 	sub	r7,r22,r16
101006c0:	01011f40 	call	101011f4 <alt_msgdma_construct_standard_mm_to_st_descriptor>
			(uint32_t *) _address_src_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101006c4:	d8800117 	ldw	r2,4(sp)
}
101006c8:	dfc00b17 	ldw	ra,44(sp)
101006cc:	df000a17 	ldw	fp,40(sp)
101006d0:	ddc00917 	ldw	r23,36(sp)
101006d4:	dd800817 	ldw	r22,32(sp)
101006d8:	dd400717 	ldw	r21,28(sp)
101006dc:	dd000617 	ldw	r20,24(sp)
101006e0:	dcc00517 	ldw	r19,20(sp)
101006e4:	dc800417 	ldw	r18,16(sp)
101006e8:	dc400317 	ldw	r17,12(sp)
101006ec:	dc000217 	ldw	r16,8(sp)
101006f0:	dec00c04 	addi	sp,sp,48
101006f4:	f800283a 	ret

101006f8 <udivmodsi4>:
101006f8:	2900182e 	bgeu	r5,r4,1010075c <udivmodsi4+0x64>
101006fc:	28001716 	blt	r5,zero,1010075c <udivmodsi4+0x64>
10100700:	00800804 	movi	r2,32
10100704:	00c00044 	movi	r3,1
10100708:	00000206 	br	10100714 <udivmodsi4+0x1c>
1010070c:	10001126 	beq	r2,zero,10100754 <udivmodsi4+0x5c>
10100710:	28000516 	blt	r5,zero,10100728 <udivmodsi4+0x30>
10100714:	294b883a 	add	r5,r5,r5
10100718:	10bfffc4 	addi	r2,r2,-1
1010071c:	18c7883a 	add	r3,r3,r3
10100720:	293ffa36 	bltu	r5,r4,1010070c <udivmodsi4+0x14>
10100724:	18000b26 	beq	r3,zero,10100754 <udivmodsi4+0x5c>
10100728:	0005883a 	mov	r2,zero
1010072c:	21400236 	bltu	r4,r5,10100738 <udivmodsi4+0x40>
10100730:	2149c83a 	sub	r4,r4,r5
10100734:	10c4b03a 	or	r2,r2,r3
10100738:	1806d07a 	srli	r3,r3,1
1010073c:	280ad07a 	srli	r5,r5,1
10100740:	183ffa1e 	bne	r3,zero,1010072c <udivmodsi4+0x34>
10100744:	3000011e 	bne	r6,zero,1010074c <udivmodsi4+0x54>
10100748:	f800283a 	ret
1010074c:	2005883a 	mov	r2,r4
10100750:	f800283a 	ret
10100754:	0005883a 	mov	r2,zero
10100758:	003ffa06 	br	10100744 <udivmodsi4+0x4c>
1010075c:	00c00044 	movi	r3,1
10100760:	003ff106 	br	10100728 <udivmodsi4+0x30>

10100764 <__divsi3>:
10100764:	defffe04 	addi	sp,sp,-8
10100768:	dfc00115 	stw	ra,4(sp)
1010076c:	dc000015 	stw	r16,0(sp)
10100770:	20000b16 	blt	r4,zero,101007a0 <__divsi3+0x3c>
10100774:	0021883a 	mov	r16,zero
10100778:	28000c16 	blt	r5,zero,101007ac <__divsi3+0x48>
1010077c:	000d883a 	mov	r6,zero
10100780:	01006f80 	call	101006f8 <udivmodsi4>
10100784:	0407c83a 	sub	r3,zero,r16
10100788:	1884f03a 	xor	r2,r3,r2
1010078c:	1405883a 	add	r2,r2,r16
10100790:	dfc00117 	ldw	ra,4(sp)
10100794:	dc000017 	ldw	r16,0(sp)
10100798:	dec00204 	addi	sp,sp,8
1010079c:	f800283a 	ret
101007a0:	0109c83a 	sub	r4,zero,r4
101007a4:	04000044 	movi	r16,1
101007a8:	283ff40e 	bge	r5,zero,1010077c <__divsi3+0x18>
101007ac:	014bc83a 	sub	r5,zero,r5
101007b0:	8400005c 	xori	r16,r16,1
101007b4:	003ff106 	br	1010077c <__divsi3+0x18>

101007b8 <__modsi3>:
101007b8:	defffd04 	addi	sp,sp,-12
101007bc:	dfc00215 	stw	ra,8(sp)
101007c0:	dc400115 	stw	r17,4(sp)
101007c4:	dc000015 	stw	r16,0(sp)
101007c8:	20000c16 	blt	r4,zero,101007fc <__modsi3+0x44>
101007cc:	0023883a 	mov	r17,zero
101007d0:	0021883a 	mov	r16,zero
101007d4:	28000d16 	blt	r5,zero,1010080c <__modsi3+0x54>
101007d8:	01800044 	movi	r6,1
101007dc:	01006f80 	call	101006f8 <udivmodsi4>
101007e0:	1404f03a 	xor	r2,r2,r16
101007e4:	8885883a 	add	r2,r17,r2
101007e8:	dfc00217 	ldw	ra,8(sp)
101007ec:	dc400117 	ldw	r17,4(sp)
101007f0:	dc000017 	ldw	r16,0(sp)
101007f4:	dec00304 	addi	sp,sp,12
101007f8:	f800283a 	ret
101007fc:	0109c83a 	sub	r4,zero,r4
10100800:	04400044 	movi	r17,1
10100804:	043fffc4 	movi	r16,-1
10100808:	283ff30e 	bge	r5,zero,101007d8 <__modsi3+0x20>
1010080c:	014bc83a 	sub	r5,zero,r5
10100810:	003ff106 	br	101007d8 <__modsi3+0x20>

10100814 <__udivsi3>:
10100814:	000d883a 	mov	r6,zero
10100818:	01006f81 	jmpi	101006f8 <udivmodsi4>

1010081c <__umodsi3>:
1010081c:	01800044 	movi	r6,1
10100820:	01006f81 	jmpi	101006f8 <udivmodsi4>

10100824 <memcpy>:
10100824:	2005883a 	mov	r2,r4
10100828:	0007883a 	mov	r3,zero
1010082c:	19800626 	beq	r3,r6,10100848 <memcpy+0x24>
10100830:	28c9883a 	add	r4,r5,r3
10100834:	21c00003 	ldbu	r7,0(r4)
10100838:	10c9883a 	add	r4,r2,r3
1010083c:	18c00044 	addi	r3,r3,1
10100840:	21c00005 	stb	r7,0(r4)
10100844:	003ff906 	br	1010082c <memcpy+0x8>
10100848:	f800283a 	ret

1010084c <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
1010084c:	01008e81 	jmpi	101008e8 <alt_iic_isr_register>

10100850 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100850:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100854:	00bfff84 	movi	r2,-2
10100858:	3084703a 	and	r2,r6,r2
1010085c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
10100860:	00840434 	movhi	r2,4112
10100864:	10889504 	addi	r2,r2,8788
10100868:	01000044 	movi	r4,1
1010086c:	10c00017 	ldw	r3,0(r2)
10100870:	214a983a 	sll	r5,r4,r5
10100874:	28cab03a 	or	r5,r5,r3
10100878:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
1010087c:	10800017 	ldw	r2,0(r2)
10100880:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100884:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
10100888:	0005883a 	mov	r2,zero
1010088c:	f800283a 	ret

10100890 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100890:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100894:	00bfff84 	movi	r2,-2
10100898:	3084703a 	and	r2,r6,r2
1010089c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
101008a0:	00840434 	movhi	r2,4112
101008a4:	10889504 	addi	r2,r2,8788
101008a8:	013fff84 	movi	r4,-2
101008ac:	10c00017 	ldw	r3,0(r2)
101008b0:	214a183a 	rol	r5,r4,r5
101008b4:	28ca703a 	and	r5,r5,r3
101008b8:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
101008bc:	10800017 	ldw	r2,0(r2)
101008c0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101008c4:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
101008c8:	0005883a 	mov	r2,zero
101008cc:	f800283a 	ret

101008d0 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
101008d0:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
101008d4:	00c00044 	movi	r3,1
101008d8:	194a983a 	sll	r5,r3,r5
101008dc:	1144703a 	and	r2,r2,r5
}
101008e0:	1004c03a 	cmpne	r2,r2,zero
101008e4:	f800283a 	ret

101008e8 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
101008e8:	00c007c4 	movi	r3,31
101008ec:	19401616 	blt	r3,r5,10100948 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
101008f0:	defffe04 	addi	sp,sp,-8
101008f4:	dfc00115 	stw	ra,4(sp)
101008f8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101008fc:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100900:	00ffff84 	movi	r3,-2
10100904:	80c6703a 	and	r3,r16,r3
10100908:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
1010090c:	280490fa 	slli	r2,r5,3
10100910:	00c40434 	movhi	r3,4112
10100914:	18c8b804 	addi	r3,r3,8928
10100918:	1891883a 	add	r8,r3,r2
1010091c:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
10100920:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
10100924:	30000226 	beq	r6,zero,10100930 <alt_iic_isr_register+0x48>
10100928:	01008500 	call	10100850 <alt_ic_irq_enable>
1010092c:	00000106 	br	10100934 <alt_iic_isr_register+0x4c>
10100930:	01008900 	call	10100890 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100934:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
10100938:	dfc00117 	ldw	ra,4(sp)
1010093c:	dc000017 	ldw	r16,0(sp)
10100940:	dec00204 	addi	sp,sp,8
10100944:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
10100948:	00bffa84 	movi	r2,-22
1010094c:	f800283a 	ret

10100950 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
10100950:	deffff04 	addi	sp,sp,-4
10100954:	01040434 	movhi	r4,4112
10100958:	01440434 	movhi	r5,4112
1010095c:	dfc00015 	stw	ra,0(sp)
10100960:	21085804 	addi	r4,r4,8544
10100964:	29487504 	addi	r5,r5,8660

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100968:	2140061e 	bne	r4,r5,10100984 <alt_load+0x34>
1010096c:	01040434 	movhi	r4,4112
10100970:	01440434 	movhi	r5,4112
10100974:	21000804 	addi	r4,r4,32
10100978:	29400804 	addi	r5,r5,32
1010097c:	2140141e 	bne	r4,r5,101009d0 <alt_load+0x80>
10100980:	00000d06 	br	101009b8 <alt_load+0x68>
10100984:	00c40434 	movhi	r3,4112
10100988:	18c87504 	addi	r3,r3,8660
1010098c:	00bfff04 	movi	r2,-4
10100990:	1907c83a 	sub	r3,r3,r4
10100994:	1886703a 	and	r3,r3,r2
10100998:	0005883a 	mov	r2,zero
  {
    while( to != end )
1010099c:	10fff326 	beq	r2,r3,1010096c <alt_load+0x1c>
101009a0:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
101009a4:	39c00017 	ldw	r7,0(r7)
101009a8:	110d883a 	add	r6,r2,r4
101009ac:	10800104 	addi	r2,r2,4
101009b0:	31c00015 	stw	r7,0(r6)
101009b4:	003ff906 	br	1010099c <alt_load+0x4c>
101009b8:	01040434 	movhi	r4,4112
101009bc:	01440434 	movhi	r5,4112
101009c0:	21074a04 	addi	r4,r4,7464
101009c4:	29474a04 	addi	r5,r5,7464

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
101009c8:	2140121e 	bne	r4,r5,10100a14 <alt_load+0xc4>
101009cc:	00000d06 	br	10100a04 <alt_load+0xb4>
101009d0:	00c40434 	movhi	r3,4112
101009d4:	18c05404 	addi	r3,r3,336
101009d8:	00bfff04 	movi	r2,-4
101009dc:	1907c83a 	sub	r3,r3,r4
101009e0:	1886703a 	and	r3,r3,r2
101009e4:	0005883a 	mov	r2,zero
  {
    while( to != end )
101009e8:	10fff326 	beq	r2,r3,101009b8 <alt_load+0x68>
101009ec:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
101009f0:	39c00017 	ldw	r7,0(r7)
101009f4:	110d883a 	add	r6,r2,r4
101009f8:	10800104 	addi	r2,r2,4
101009fc:	31c00015 	stw	r7,0(r6)
10100a00:	003ff906 	br	101009e8 <alt_load+0x98>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10100a04:	0101b8c0 	call	10101b8c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10100a08:	dfc00017 	ldw	ra,0(sp)
10100a0c:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
10100a10:	0101c901 	jmpi	10101c90 <alt_icache_flush_all>
10100a14:	00c40434 	movhi	r3,4112
10100a18:	18c85804 	addi	r3,r3,8544
10100a1c:	00bfff04 	movi	r2,-4
10100a20:	1907c83a 	sub	r3,r3,r4
10100a24:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100a28:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100a2c:	10fff526 	beq	r2,r3,10100a04 <alt_load+0xb4>
10100a30:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100a34:	39c00017 	ldw	r7,0(r7)
10100a38:	110d883a 	add	r6,r2,r4
10100a3c:	10800104 	addi	r2,r2,4
10100a40:	31c00015 	stw	r7,0(r6)
10100a44:	003ff906 	br	10100a2c <alt_load+0xdc>

10100a48 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a48:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a4c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a50:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a54:	0100c600 	call	10100c60 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10100a58:	0100c800 	call	10100c80 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a5c:	d1202817 	ldw	r4,-32608(gp)
10100a60:	d1602717 	ldw	r5,-32612(gp)
10100a64:	d1a02617 	ldw	r6,-32616(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
10100a68:	dfc00017 	ldw	ra,0(sp)
10100a6c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a70:	01002201 	jmpi	10100220 <main>

10100a74 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100a74:	defff204 	addi	sp,sp,-56
10100a78:	dfc00a15 	stw	ra,40(sp)
10100a7c:	df000915 	stw	fp,36(sp)
10100a80:	ddc00815 	stw	r23,32(sp)
10100a84:	dd800715 	stw	r22,28(sp)
10100a88:	dd400615 	stw	r21,24(sp)
10100a8c:	dd000515 	stw	r20,20(sp)
10100a90:	dcc00415 	stw	r19,16(sp)
10100a94:	dc800315 	stw	r18,12(sp)
10100a98:	dc400215 	stw	r17,8(sp)
10100a9c:	dc000115 	stw	r16,4(sp)
10100aa0:	d9400b15 	stw	r5,44(sp)
10100aa4:	d9800c15 	stw	r6,48(sp)
10100aa8:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100aac:	04000944 	movi	r16,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100ab0:	2005883a 	mov	r2,r4
	va_list args;
	va_start(args, fmt);
10100ab4:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
10100ab8:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
10100abc:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100ac0:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100ac4:	11000007 	ldb	r4,0(r2)
10100ac8:	20003926 	beq	r4,zero,10100bb0 <alt_printf+0x13c>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100acc:	24000226 	beq	r4,r16,10100ad8 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100ad0:	14400044 	addi	r17,r2,1
10100ad4:	00001106 	br	10100b1c <alt_printf+0xa8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
10100ad8:	14400084 	addi	r17,r2,2
10100adc:	10800047 	ldb	r2,1(r2)
10100ae0:	10003326 	beq	r2,zero,10100bb0 <alt_printf+0x13c>
            {
                if (c == '%')
10100ae4:	1400021e 	bne	r2,r16,10100af0 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
10100ae8:	8009883a 	mov	r4,r16
10100aec:	00000b06 	br	10100b1c <alt_printf+0xa8>
                } 
                else if (c == 'c')
10100af0:	1480051e 	bne	r2,r18,10100b08 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
10100af4:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100af8:	ad800104 	addi	r22,r21,4
10100afc:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
10100b00:	0100be00 	call	10100be0 <alt_putchar>
10100b04:	00002806 	br	10100ba8 <alt_printf+0x134>
                }
                else if (c == 'x')
10100b08:	14c01f1e 	bne	r2,r19,10100b88 <alt_printf+0x114>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
10100b0c:	adc00017 	ldw	r23,0(r21)
10100b10:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
10100b14:	b800031e 	bne	r23,zero,10100b24 <alt_printf+0xb0>
                    {
                        alt_putchar('0');
10100b18:	01000c04 	movi	r4,48
10100b1c:	0100be00 	call	10100be0 <alt_putchar>
                        continue;
10100b20:	00002106 	br	10100ba8 <alt_printf+0x134>
10100b24:	05800704 	movi	r22,28
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
10100b28:	00c003c4 	movi	r3,15
10100b2c:	1d84983a 	sll	r2,r3,r22
10100b30:	15c4703a 	and	r2,r2,r23
10100b34:	1000021e 	bne	r2,zero,10100b40 <alt_printf+0xcc>
                        digit_shift -= 4;
10100b38:	b5bfff04 	addi	r22,r22,-4
10100b3c:	003ffb06 	br	10100b2c <alt_printf+0xb8>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b40:	070003c4 	movi	fp,15
                        if (digit <= 9)
10100b44:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b48:	b0001716 	blt	r22,zero,10100ba8 <alt_printf+0x134>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b4c:	e584983a 	sll	r2,fp,r22
10100b50:	15c4703a 	and	r2,r2,r23
10100b54:	1584d83a 	srl	r2,r2,r22
                        if (digit <= 9)
10100b58:	18800236 	bltu	r3,r2,10100b64 <alt_printf+0xf0>
                            c = '0' + digit;
10100b5c:	11000c04 	addi	r4,r2,48
10100b60:	00000106 	br	10100b68 <alt_printf+0xf4>
                        else
                            c = 'a' + digit - 10;
10100b64:	110015c4 	addi	r4,r2,87
                        alt_putchar(c);
10100b68:	21003fcc 	andi	r4,r4,255
10100b6c:	2100201c 	xori	r4,r4,128
10100b70:	213fe004 	addi	r4,r4,-128
10100b74:	d8c00015 	stw	r3,0(sp)
10100b78:	0100be00 	call	10100be0 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b7c:	b5bfff04 	addi	r22,r22,-4
10100b80:	d8c00017 	ldw	r3,0(sp)
10100b84:	003ff006 	br	10100b48 <alt_printf+0xd4>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100b88:	1500071e 	bne	r2,r20,10100ba8 <alt_printf+0x134>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
10100b8c:	ad800017 	ldw	r22,0(r21)
10100b90:	ad400104 	addi	r21,r21,4

                    while(*s)
10100b94:	b1000007 	ldb	r4,0(r22)
10100b98:	20000326 	beq	r4,zero,10100ba8 <alt_printf+0x134>
                      alt_putchar(*s++);
10100b9c:	b5800044 	addi	r22,r22,1
10100ba0:	0100be00 	call	10100be0 <alt_putchar>
10100ba4:	003ffb06 	br	10100b94 <alt_printf+0x120>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100ba8:	8805883a 	mov	r2,r17
10100bac:	003fc506 	br	10100ac4 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
10100bb0:	dfc00a17 	ldw	ra,40(sp)
10100bb4:	df000917 	ldw	fp,36(sp)
10100bb8:	ddc00817 	ldw	r23,32(sp)
10100bbc:	dd800717 	ldw	r22,28(sp)
10100bc0:	dd400617 	ldw	r21,24(sp)
10100bc4:	dd000517 	ldw	r20,20(sp)
10100bc8:	dcc00417 	ldw	r19,16(sp)
10100bcc:	dc800317 	ldw	r18,12(sp)
10100bd0:	dc400217 	ldw	r17,8(sp)
10100bd4:	dc000117 	ldw	r16,4(sp)
10100bd8:	dec00e04 	addi	sp,sp,56
10100bdc:	f800283a 	ret

10100be0 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100be0:	defffd04 	addi	sp,sp,-12
10100be4:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
10100be8:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100bec:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100bf0:	01040434 	movhi	r4,4112
10100bf4:	21087104 	addi	r4,r4,8644
10100bf8:	d80b883a 	mov	r5,sp
10100bfc:	01800044 	movi	r6,1
10100c00:	000f883a 	mov	r7,zero
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c04:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100c08:	0100c940 	call	10100c94 <altera_avalon_jtag_uart_write>
10100c0c:	00ffffc4 	movi	r3,-1
10100c10:	10c00126 	beq	r2,r3,10100c18 <alt_putchar+0x38>
        return -1;
    }
    return c;
10100c14:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
10100c18:	dfc00217 	ldw	ra,8(sp)
10100c1c:	dc000117 	ldw	r16,4(sp)
10100c20:	dec00304 	addi	sp,sp,12
10100c24:	f800283a 	ret

10100c28 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
10100c28:	defffe04 	addi	sp,sp,-8
10100c2c:	dc000015 	stw	r16,0(sp)
10100c30:	dfc00115 	stw	ra,4(sp)
10100c34:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c38:	0101d0c0 	call	10101d0c <strlen>
10100c3c:	01040434 	movhi	r4,4112
10100c40:	21087104 	addi	r4,r4,8644
10100c44:	800b883a 	mov	r5,r16
10100c48:	100d883a 	mov	r6,r2
10100c4c:	000f883a 	mov	r7,zero
#else
    return fputs(str, stdout);
#endif
#endif
}
10100c50:	dfc00117 	ldw	ra,4(sp)
10100c54:	dc000017 	ldw	r16,0(sp)
10100c58:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c5c:	0100c941 	jmpi	10100c94 <altera_avalon_jtag_uart_write>

10100c60 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10100c60:	deffff04 	addi	sp,sp,-4
10100c64:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
10100c68:	0101c9c0 	call	10101c9c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10100c6c:	00800044 	movi	r2,1
10100c70:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10100c74:	dfc00017 	ldw	ra,0(sp)
10100c78:	dec00104 	addi	sp,sp,4
10100c7c:	f800283a 	ret

10100c80 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_MSGDMA_INIT ( MSGDMA_0, msgdma_0);
10100c80:	01040434 	movhi	r4,4112
10100c84:	21085804 	addi	r4,r4,8544
10100c88:	21400717 	ldw	r5,28(r4)
10100c8c:	21800817 	ldw	r6,32(r4)
10100c90:	01019f81 	jmpi	101019f8 <alt_msgdma_init>

10100c94 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10100c94:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10100c98:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
10100c9c:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100ca0:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10100ca4:	2980072e 	bgeu	r5,r6,10100cc4 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100ca8:	38c00037 	ldwio	r3,0(r7)
10100cac:	18ffffec 	andhi	r3,r3,65535
10100cb0:	183ffc26 	beq	r3,zero,10100ca4 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10100cb4:	28c00007 	ldb	r3,0(r5)
10100cb8:	20c00035 	stwio	r3,0(r4)
10100cbc:	29400044 	addi	r5,r5,1
10100cc0:	003ff806 	br	10100ca4 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
10100cc4:	f800283a 	ret

10100cc8 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100cc8:	defffd04 	addi	sp,sp,-12
10100ccc:	dc000015 	stw	r16,0(sp)
10100cd0:	dfc00215 	stw	ra,8(sp)
10100cd4:	dc400115 	stw	r17,4(sp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100cd8:	20801783 	ldbu	r2,94(r4)
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100cdc:	2021883a 	mov	r16,r4
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100ce0:	10000926 	beq	r2,zero,10100d08 <alt_msgdma_irq+0x40>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100ce4:	20c00617 	ldw	r3,24(r4)
10100ce8:	19000037 	ldwio	r4,0(r3)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
10100cec:	00bffdc4 	movi	r2,-9
10100cf0:	2084703a 	and	r2,r4,r2
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100cf4:	18800035 	stwio	r2,0(r3)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
10100cf8:	80800617 	ldw	r2,24(r16)
10100cfc:	00c00044 	movi	r3,1
10100d00:	10c00435 	stwio	r3,16(r2)
10100d04:	00000906 	br	10100d2c <alt_msgdma_irq+0x64>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10100d08:	20800317 	ldw	r2,12(r4)
10100d0c:	10800104 	addi	r2,r2,4
10100d10:	11000037 	ldwio	r4,0(r2)
10100d14:	00fffbc4 	movi	r3,-17
10100d18:	20c6703a 	and	r3,r4,r3
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d1c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
10100d20:	80800317 	ldw	r2,12(r16)
10100d24:	00c08004 	movi	r3,512
10100d28:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
10100d2c:	80c00b17 	ldw	r3,44(r16)
10100d30:	18000726 	beq	r3,zero,10100d50 <alt_msgdma_irq+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100d34:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100d38:	00bfff84 	movi	r2,-2
10100d3c:	8884703a 	and	r2,r17,r2
10100d40:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        dev->callback (dev->callback_context);
10100d44:	81000c17 	ldw	r4,48(r16)
10100d48:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100d4c:	8801703a 	wrctl	status,r17
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
10100d50:	80801783 	ldbu	r2,94(r16)
10100d54:	10000526 	beq	r2,zero,10100d6c <alt_msgdma_irq+0xa4>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100d58:	80c00617 	ldw	r3,24(r16)
10100d5c:	18800037 	ldwio	r2,0(r3)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10100d60:	10800214 	ori	r2,r2,8
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100d64:	18800035 	stwio	r2,0(r3)
10100d68:	00000506 	br	10100d80 <alt_msgdma_irq+0xb8>
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
10100d6c:	80800317 	ldw	r2,12(r16)
10100d70:	10800104 	addi	r2,r2,4
10100d74:	10c00037 	ldwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
10100d78:	18c00414 	ori	r3,r3,16
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d7c:	10c00035 	stwio	r3,0(r2)
    }

    return;
}
10100d80:	dfc00217 	ldw	ra,8(sp)
10100d84:	dc400117 	ldw	r17,4(sp)
10100d88:	dc000017 	ldw	r16,0(sp)
10100d8c:	dec00304 	addi	sp,sp,12
10100d90:	f800283a 	ret

10100d94 <alt_msgdma_write_extended_descriptor>:
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100d94:	20800037 	ldwio	r2,0(r4)
10100d98:	1080010c 	andi	r2,r2,4
10100d9c:	1000151e 	bne	r2,zero,10100df4 <alt_msgdma_write_extended_descriptor+0x60>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
10100da0:	30c00017 	ldw	r3,0(r6)
10100da4:	28c00035 	stwio	r3,0(r5)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
10100da8:	30c00117 	ldw	r3,4(r6)
10100dac:	28c00135 	stwio	r3,4(r5)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
10100db0:	30c00217 	ldw	r3,8(r6)
10100db4:	28c00235 	stwio	r3,8(r5)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
10100db8:	30c0030b 	ldhu	r3,12(r6)
10100dbc:	28c0032d 	sthio	r3,12(r5)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
10100dc0:	30c00383 	ldbu	r3,14(r6)
10100dc4:	28c003a5 	stbio	r3,14(r5)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
10100dc8:	30c003c3 	ldbu	r3,15(r6)
10100dcc:	28c003e5 	stbio	r3,15(r5)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
10100dd0:	30c0040b 	ldhu	r3,16(r6)
10100dd4:	28c0042d 	sthio	r3,16(r5)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
10100dd8:	30c0048b 	ldhu	r3,18(r6)
10100ddc:	28c004ad 	sthio	r3,18(r5)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
10100de0:	28000535 	stwio	zero,20(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
10100de4:	28000635 	stwio	zero,24(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
10100de8:	30c00717 	ldw	r3,28(r6)
10100dec:	28c00735 	stwio	r3,28(r5)
		descriptor_base, 
    	descriptor->control);
    return 0;
10100df0:	f800283a 	ret
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
10100df4:	00bff904 	movi	r2,-28
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
		descriptor_base, 
    	descriptor->control);
    return 0;
}
10100df8:	f800283a 	ret

10100dfc <alt_msgdma_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100dfc:	20c00317 	ldw	r3,12(r4)
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e00:	defffb04 	addi	sp,sp,-20
10100e04:	dc800215 	stw	r18,8(sp)
10100e08:	dc400115 	stw	r17,4(sp)
10100e0c:	dc000015 	stw	r16,0(sp)
10100e10:	2823883a 	mov	r17,r5
10100e14:	2021883a 	mov	r16,r4
10100e18:	3025883a 	mov	r18,r6
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e1c:	18c00204 	addi	r3,r3,8
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e20:	dfc00415 	stw	ra,16(sp)
10100e24:	dcc00315 	stw	r19,12(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e28:	18800037 	ldwio	r2,0(r3)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10100e2c:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e30:	18c00037 	ldwio	r3,0(r3)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e34:	04c4e244 	movi	r19,5001
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10100e38:	1806d43a 	srli	r3,r3,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e3c:	81000917 	ldw	r4,36(r16)
10100e40:	19001036 	bltu	r3,r4,10100e84 <alt_msgdma_descriptor_sync_transfer+0x88>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
10100e44:	01000044 	movi	r4,1
10100e48:	0101b140 	call	10101b14 <alt_busy_sleep>
10100e4c:	98bfffc4 	addi	r2,r19,-1
10100e50:	1027883a 	mov	r19,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100e54:	10bfffcc 	andi	r2,r2,65535
10100e58:	1000031e 	bne	r2,zero,10100e68 <alt_msgdma_descriptor_sync_transfer+0x6c>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
10100e5c:	01040434 	movhi	r4,4112
10100e60:	2107e404 	addi	r4,r4,8080
10100e64:	00004806 	br	10100f88 <alt_msgdma_descriptor_sync_transfer+0x18c>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e68:	80c00317 	ldw	r3,12(r16)
10100e6c:	18c00204 	addi	r3,r3,8
10100e70:	18800037 	ldwio	r2,0(r3)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
10100e74:	10bfffcc 	andi	r2,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e78:	18c00037 	ldwio	r3,0(r3)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
10100e7c:	1806d43a 	srli	r3,r3,16
10100e80:	003fee06 	br	10100e3c <alt_msgdma_descriptor_sync_transfer+0x40>
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e84:	113fef2e 	bgeu	r2,r4,10100e44 <alt_msgdma_descriptor_sync_transfer+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100e88:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100e8c:	00bfff84 	movi	r2,-2
10100e90:	9884703a 	and	r2,r19,r2
10100e94:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100e98:	80800317 	ldw	r2,12(r16)
10100e9c:	00c00804 	movi	r3,32
10100ea0:	10c00135 	stwio	r3,4(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10100ea4:	80800317 	ldw	r2,12(r16)
10100ea8:	10c00037 	ldwio	r3,0(r2)
10100eac:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
10100eb0:	88001026 	beq	r17,zero,10100ef4 <alt_msgdma_descriptor_sync_transfer+0xf8>
10100eb4:	9000101e 	bne	r18,zero,10100ef8 <alt_msgdma_descriptor_sync_transfer+0xfc>
10100eb8:	0484e244 	movi	r18,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
10100ebc:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100ec0:	80c00317 	ldw	r3,12(r16)
10100ec4:	18c00037 	ldwio	r3,0(r3)
10100ec8:	18c0010c 	andi	r3,r3,4
10100ecc:	1800261e 	bne	r3,zero,10100f68 <alt_msgdma_descriptor_sync_transfer+0x16c>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
10100ed0:	88c00017 	ldw	r3,0(r17)
10100ed4:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
10100ed8:	88c00117 	ldw	r3,4(r17)
10100edc:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
10100ee0:	88c00217 	ldw	r3,8(r17)
10100ee4:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
10100ee8:	88c00317 	ldw	r3,12(r17)
10100eec:	10c00335 	stwio	r3,12(r2)
10100ef0:	00001206 	br	10100f3c <alt_msgdma_descriptor_sync_transfer+0x140>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
10100ef4:	9000021e 	bne	r18,zero,10100f00 <alt_msgdma_descriptor_sync_transfer+0x104>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10100ef8:	00bfffc4 	movi	r2,-1
10100efc:	00004406 	br	10101010 <alt_msgdma_descriptor_sync_transfer+0x214>
10100f00:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
10100f04:	81000317 	ldw	r4,12(r16)
10100f08:	81400417 	ldw	r5,16(r16)
10100f0c:	900d883a 	mov	r6,r18
10100f10:	0100d940 	call	10100d94 <alt_msgdma_write_extended_descriptor>
10100f14:	10000926 	beq	r2,zero,10100f3c <alt_msgdma_descriptor_sync_transfer+0x140>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10100f18:	01000044 	movi	r4,1
10100f1c:	0101b140 	call	10101b14 <alt_busy_sleep>
10100f20:	88bfffc4 	addi	r2,r17,-1
10100f24:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f28:	10bfffcc 	andi	r2,r2,65535
10100f2c:	103ff51e 	bne	r2,zero,10100f04 <alt_msgdma_descriptor_sync_transfer+0x108>
            {
                alt_printf("time out after 5 msec while writing extended" 
10100f30:	01040434 	movhi	r4,4112
10100f34:	21080904 	addi	r4,r4,8228
10100f38:	00001306 	br	10100f88 <alt_msgdma_descriptor_sync_transfer+0x18c>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100f3c:	81000d17 	ldw	r4,52(r16)
10100f40:	80c00317 	ldw	r3,12(r16)
10100f44:	00bff2c4 	movi	r2,-53
10100f48:	2084703a 	and	r2,r4,r2
10100f4c:	10800114 	ori	r2,r2,4
10100f50:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100f54:	9801703a 	wrctl	status,r19
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100f58:	80800317 	ldw	r2,12(r16)
10100f5c:	10800037 	ldwio	r2,0(r2)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100f60:	0444e244 	movi	r17,5001
10100f64:	00000d06 	br	10100f9c <alt_msgdma_descriptor_sync_transfer+0x1a0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
10100f68:	01000044 	movi	r4,1
10100f6c:	0101b140 	call	10101b14 <alt_busy_sleep>
10100f70:	90bfffc4 	addi	r2,r18,-1
10100f74:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f78:	10bfffcc 	andi	r2,r2,65535
10100f7c:	103fcf1e 	bne	r2,zero,10100ebc <alt_msgdma_descriptor_sync_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while writing standard" 
10100f80:	01040434 	movhi	r4,4112
10100f84:	2107f804 	addi	r4,r4,8160
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100f88:	0100a740 	call	10100a74 <alt_printf>
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
10100f8c:	00bff084 	movi	r2,-62
10100f90:	00001f06 	br	10101010 <alt_msgdma_descriptor_sync_transfer+0x214>
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100f94:	80800317 	ldw	r2,12(r16)
10100f98:	10800037 	ldwio	r2,0(r2)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100f9c:	10c0780c 	andi	r3,r2,480
10100fa0:	18000b1e 	bne	r3,zero,10100fd0 <alt_msgdma_descriptor_sync_transfer+0x1d4>
10100fa4:	1080004c 	andi	r2,r2,1
10100fa8:	10000b26 	beq	r2,zero,10100fd8 <alt_msgdma_descriptor_sync_transfer+0x1dc>
    {
        alt_busy_sleep(1); /* delay 1us */
10100fac:	01000044 	movi	r4,1
10100fb0:	0101b140 	call	10101b14 <alt_busy_sleep>
10100fb4:	88bfffc4 	addi	r2,r17,-1
10100fb8:	1023883a 	mov	r17,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100fbc:	10bfffcc 	andi	r2,r2,65535
10100fc0:	103ff41e 	bne	r2,zero,10100f94 <alt_msgdma_descriptor_sync_transfer+0x198>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100fc4:	01040434 	movhi	r4,4112
10100fc8:	21081a04 	addi	r4,r4,8296
10100fcc:	003fee06 	br	10100f88 <alt_msgdma_descriptor_sync_transfer+0x18c>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
10100fd0:	00807804 	movi	r2,480
10100fd4:	00000e06 	br	10101010 <alt_msgdma_descriptor_sync_transfer+0x214>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
10100fd8:	80800317 	ldw	r2,12(r16)
10100fdc:	10800104 	addi	r2,r2,4
10100fe0:	10c00037 	ldwio	r3,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100fe4:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100fe8:	013fff84 	movi	r4,-2
10100fec:	2908703a 	and	r4,r5,r4
10100ff0:	2001703a 	wrctl	status,r4
10100ff4:	18c00814 	ori	r3,r3,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10100ff8:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10100ffc:	80800317 	ldw	r2,12(r16)
10101000:	10c00037 	ldwio	r3,0(r2)
10101004:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101008:	2801703a 	wrctl	status,r5
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
1010100c:	0005883a 	mov	r2,zero

}
10101010:	dfc00417 	ldw	ra,16(sp)
10101014:	dcc00317 	ldw	r19,12(sp)
10101018:	dc800217 	ldw	r18,8(sp)
1010101c:	dc400117 	ldw	r17,4(sp)
10101020:	dc000017 	ldw	r16,0(sp)
10101024:	dec00504 	addi	sp,sp,20
10101028:	f800283a 	ret

1010102c <alt_msgdma_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
1010102c:	21c00317 	ldw	r7,12(r4)
10101030:	38c00204 	addi	r3,r7,8
10101034:	18800037 	ldwio	r2,0(r3)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10101038:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
1010103c:	18c00037 	ldwio	r3,0(r3)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101040:	22000917 	ldw	r8,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10101044:	1806d43a 	srli	r3,r3,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101048:	1a004b2e 	bgeu	r3,r8,10101178 <alt_msgdma_descriptor_async_transfer+0x14c>
1010104c:	12004a2e 	bgeu	r2,r8,10101178 <alt_msgdma_descriptor_async_transfer+0x14c>
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10101050:	defffc04 	addi	sp,sp,-16
10101054:	dc800215 	stw	r18,8(sp)
10101058:	dc400115 	stw	r17,4(sp)
1010105c:	dc000015 	stw	r16,0(sp)
10101060:	3025883a 	mov	r18,r6
10101064:	2823883a 	mov	r17,r5
10101068:	2021883a 	mov	r16,r4
1010106c:	dfc00315 	stw	ra,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101070:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101074:	00bfff84 	movi	r2,-2
10101078:	1884703a 	and	r2,r3,r2
1010107c:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101080:	00800804 	movi	r2,32
10101084:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
10101088:	20800317 	ldw	r2,12(r4)
1010108c:	11000037 	ldwio	r4,0(r2)
10101090:	11000035 	stwio	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101094:	1801703a 	wrctl	status,r3
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
10101098:	28001026 	beq	r5,zero,101010dc <alt_msgdma_descriptor_async_transfer+0xb0>
1010109c:	3000101e 	bne	r6,zero,101010e0 <alt_msgdma_descriptor_async_transfer+0xb4>
101010a0:	0484e244 	movi	r18,5001
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
101010a4:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
101010a8:	80c00317 	ldw	r3,12(r16)
101010ac:	18c00037 	ldwio	r3,0(r3)
101010b0:	18c0010c 	andi	r3,r3,4
101010b4:	1800321e 	bne	r3,zero,10101180 <alt_msgdma_descriptor_async_transfer+0x154>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
101010b8:	88c00017 	ldw	r3,0(r17)
101010bc:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
101010c0:	88c00117 	ldw	r3,4(r17)
101010c4:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
101010c8:	88c00217 	ldw	r3,8(r17)
101010cc:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
101010d0:	88c00317 	ldw	r3,12(r17)
101010d4:	10c00335 	stwio	r3,12(r2)
101010d8:	00001406 	br	1010112c <alt_msgdma_descriptor_async_transfer+0x100>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
101010dc:	3000021e 	bne	r6,zero,101010e8 <alt_msgdma_descriptor_async_transfer+0xbc>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
101010e0:	00bfffc4 	movi	r2,-1
101010e4:	00002f06 	br	101011a4 <alt_msgdma_descriptor_async_transfer+0x178>
101010e8:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
101010ec:	81000317 	ldw	r4,12(r16)
101010f0:	81400417 	ldw	r5,16(r16)
101010f4:	900d883a 	mov	r6,r18
101010f8:	0100d940 	call	10100d94 <alt_msgdma_write_extended_descriptor>
101010fc:	10000b26 	beq	r2,zero,1010112c <alt_msgdma_descriptor_async_transfer+0x100>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101100:	01000044 	movi	r4,1
10101104:	0101b140 	call	10101b14 <alt_busy_sleep>
10101108:	88bfffc4 	addi	r2,r17,-1
1010110c:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101110:	10bfffcc 	andi	r2,r2,65535
10101114:	103ff51e 	bne	r2,zero,101010ec <alt_msgdma_descriptor_async_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
10101118:	01040434 	movhi	r4,4112
1010111c:	21084204 	addi	r4,r4,8456
10101120:	0100a740 	call	10100a74 <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
10101124:	00bff084 	movi	r2,-62
10101128:	00001e06 	br	101011a4 <alt_msgdma_descriptor_async_transfer+0x178>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
1010112c:	81000b17 	ldw	r4,44(r16)
10101130:	81400317 	ldw	r5,12(r16)
10101134:	00bfff84 	movi	r2,-2
10101138:	80c00d17 	ldw	r3,52(r16)
1010113c:	20000426 	beq	r4,zero,10101150 <alt_msgdma_descriptor_async_transfer+0x124>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101140:	013ff7c4 	movi	r4,-33
10101144:	1906703a 	and	r3,r3,r4
10101148:	18c00514 	ori	r3,r3,20
1010114c:	00000306 	br	1010115c <alt_msgdma_descriptor_async_transfer+0x130>
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
10101150:	013ff3c4 	movi	r4,-49
10101154:	1906703a 	and	r3,r3,r4
10101158:	18c00114 	ori	r3,r3,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
1010115c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101160:	2084703a 	and	r2,r4,r2
10101164:	1001703a 	wrctl	status,r2
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101168:	28c00135 	stwio	r3,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1010116c:	2001703a 	wrctl	status,r4
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101170:	0005883a 	mov	r2,zero
10101174:	00000b06 	br	101011a4 <alt_msgdma_descriptor_async_transfer+0x178>
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
10101178:	00bff904 	movi	r2,-28
1010117c:	f800283a 	ret
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101180:	01000044 	movi	r4,1
10101184:	0101b140 	call	10101b14 <alt_busy_sleep>
10101188:	90bfffc4 	addi	r2,r18,-1
1010118c:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101190:	10bfffcc 	andi	r2,r2,65535
10101194:	103fc31e 	bne	r2,zero,101010a4 <alt_msgdma_descriptor_async_transfer+0x78>
            {
                alt_printf("time out after 5 msec while waiting" 
10101198:	01040434 	movhi	r4,4112
1010119c:	21082c04 	addi	r4,r4,8368
101011a0:	003fdf06 	br	10101120 <alt_msgdma_descriptor_async_transfer+0xf4>
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
}
101011a4:	dfc00317 	ldw	ra,12(sp)
101011a8:	dc800217 	ldw	r18,8(sp)
101011ac:	dc400117 	ldw	r17,4(sp)
101011b0:	dc000017 	ldw	r16,0(sp)
101011b4:	dec00404 	addi	sp,sp,16
101011b8:	f800283a 	ret

101011bc <alt_msgdma_construct_standard_st_to_mm_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101011bc:	20801217 	ldw	r2,72(r4)
101011c0:	11c00a36 	bltu	r2,r7,101011ec <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
101011c4:	20801703 	ldbu	r2,92(r4)
101011c8:	1000081e 	bne	r2,zero,101011ec <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011cc:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101011d0:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
101011d4:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011d8:	10a00034 	orhi	r2,r2,32768
101011dc:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
101011e0:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101011e4:	0005883a 	mov	r2,zero
101011e8:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
101011ec:	00bffa84 	movi	r2,-22
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
            write_address, length, control);
}
101011f0:	f800283a 	ret

101011f4 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101011f4:	20801217 	ldw	r2,72(r4)
101011f8:	11c00a36 	bltu	r2,r7,10101224 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
101011fc:	20801703 	ldbu	r2,92(r4)
10101200:	1000081e 	bne	r2,zero,10101224 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101204:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101208:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010120c:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101210:	10a00034 	orhi	r2,r2,32768
10101214:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101218:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010121c:	0005883a 	mov	r2,zero
10101220:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101224:	00bffa84 	movi	r2,-22
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            NULL, length, control);

}
10101228:	f800283a 	ret

1010122c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
1010122c:	d8800017 	ldw	r2,0(sp)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101230:	20c01217 	ldw	r3,72(r4)
10101234:	18800a36 	bltu	r3,r2,10101260 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
10101238:	20c01703 	ldbu	r3,92(r4)
1010123c:	1800081e 	bne	r3,zero,10101260 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101240:	28800215 	stw	r2,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101244:	d8800117 	ldw	r2,4(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101248:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010124c:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101250:	10a00034 	orhi	r2,r2,32768
10101254:	28800315 	stw	r2,12(r5)
    
    return 0;
10101258:	0005883a 	mov	r2,zero
1010125c:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101260:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            write_address, length, control);
}
10101264:	f800283a 	ret

10101268 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101268:	22401217 	ldw	r9,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
1010126c:	da000117 	ldw	r8,4(sp)
10101270:	d8c00217 	ldw	r3,8(sp)
10101274:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101278:	49c01736 	bltu	r9,r7,101012d8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < read_stride ||
1010127c:	22801417 	ldw	r10,80(r4)
       dev->max_stride < write_stride ||
10101280:	127fffcc 	andi	r9,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101284:	5000021e 	bne	r10,zero,10101290 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x28>
10101288:	22801317 	ldw	r10,76(r4)
1010128c:	52401236 	bltu	r10,r9,101012d8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < write_stride ||
10101290:	22401703 	ldbu	r9,92(r4)
10101294:	01000044 	movi	r4,1
10101298:	49000f1e 	bne	r9,r4,101012d8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010129c:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012a0:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101012a4:	28000015 	stw	zero,0(r5)
    descriptor->write_address_low = write_address;
101012a8:	29800115 	stw	r6,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012ac:	10a00034 	orhi	r2,r2,32768
101012b0:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101012b4:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
101012b8:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
101012bc:	28000385 	stb	zero,14(r5)
    descriptor->write_burst_count = write_burst_count;
101012c0:	28c003c5 	stb	r3,15(r5)
    descriptor->read_stride = read_stride;
101012c4:	2800040d 	sth	zero,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101012c8:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101012cc:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101012d0:	0005883a 	mov	r2,zero
101012d4:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101012d8:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
101012dc:	f800283a 	ret

101012e0 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101012e0:	22401217 	ldw	r9,72(r4)
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
101012e4:	da000117 	ldw	r8,4(sp)
101012e8:	d8c00217 	ldw	r3,8(sp)
101012ec:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101012f0:	49c01736 	bltu	r9,r7,10101350 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
101012f4:	22801417 	ldw	r10,80(r4)
       dev->max_stride < read_stride ||
101012f8:	127fffcc 	andi	r9,r2,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101012fc:	5000021e 	bne	r10,zero,10101308 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x28>
10101300:	22801317 	ldw	r10,76(r4)
10101304:	52401236 	bltu	r10,r9,10101350 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101308:	22401703 	ldbu	r9,92(r4)
1010130c:	01000044 	movi	r4,1
10101310:	49000f1e 	bne	r9,r4,10101350 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101314:	2880040d 	sth	r2,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101318:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
1010131c:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
10101320:	28000115 	stw	zero,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101324:	10a00034 	orhi	r2,r2,32768
10101328:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
1010132c:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
10101330:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
10101334:	28c00385 	stb	r3,14(r5)
    descriptor->write_burst_count = write_burst_count;
10101338:	280003c5 	stb	zero,15(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010133c:	2800048d 	sth	zero,18(r5)
    descriptor->read_address_high = NULL;
10101340:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
10101344:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101348:	0005883a 	mov	r2,zero
1010134c:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101350:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
10101354:	f800283a 	ret

10101358 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101358:	da000017 	ldw	r8,0(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010135c:	22401217 	ldw	r9,72(r4)
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101360:	db400217 	ldw	r13,8(sp)
10101364:	db000317 	ldw	r12,12(sp)
10101368:	dac00417 	ldw	r11,16(sp)
1010136c:	d8c00517 	ldw	r3,20(sp)
10101370:	d8800617 	ldw	r2,24(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101374:	4a001a36 	bltu	r9,r8,101013e0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
10101378:	22801417 	ldw	r10,80(r4)
1010137c:	22401317 	ldw	r9,76(r4)
10101380:	1bbfffcc 	andi	r14,r3,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101384:	5000011e 	bne	r10,zero,1010138c <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x34>
10101388:	4b801536 	bltu	r9,r14,101013e0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
1010138c:	13bfffcc 	andi	r14,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101390:	5000011e 	bne	r10,zero,10101398 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x40>
10101394:	4b801236 	bltu	r9,r14,101013e0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
10101398:	22401703 	ldbu	r9,92(r4)
1010139c:	01000044 	movi	r4,1
101013a0:	49000f1e 	bne	r9,r4,101013e0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101013a4:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013a8:	d8800117 	ldw	r2,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101013ac:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
101013b0:	29c00115 	stw	r7,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013b4:	10a00034 	orhi	r2,r2,32768
101013b8:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101013bc:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
101013c0:	2b40030d 	sth	r13,12(r5)
    descriptor->read_burst_count = read_burst_count;
101013c4:	2b000385 	stb	r12,14(r5)
    descriptor->write_burst_count = write_burst_count;
101013c8:	2ac003c5 	stb	r11,15(r5)
    descriptor->read_stride = read_stride;
101013cc:	28c0040d 	sth	r3,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101013d0:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101013d4:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101013d8:	0005883a 	mov	r2,zero
101013dc:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101013e0:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
101013e4:	f800283a 	ret

101013e8 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
101013e8:	d8800017 	ldw	r2,0(sp)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101013ec:	20c01217 	ldw	r3,72(r4)
101013f0:	18800e36 	bltu	r3,r2,1010142c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
101013f4:	20c01703 	ldbu	r3,92(r4)
101013f8:	18000c1e 	bne	r3,zero,1010142c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013fc:	d8c00117 	ldw	r3,4(sp)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101400:	28800215 	stw	r2,8(r5)
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101404:	00900034 	movhi	r2,16384
10101408:	10bfffc4 	addi	r2,r2,-1
1010140c:	1884703a 	and	r2,r3,r2
10101410:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101414:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101418:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010141c:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101420:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101424:	0005883a 	mov	r2,zero
10101428:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
1010142c:	00bffa84 	movi	r2,-22
	alt_u32 length,
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, write_address, length, control);
}
10101430:	f800283a 	ret

10101434 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101434:	20801217 	ldw	r2,72(r4)
10101438:	11c00e36 	bltu	r2,r7,10101474 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
1010143c:	20801703 	ldbu	r2,92(r4)
10101440:	10000c1e 	bne	r2,zero,10101474 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101444:	d8c00017 	ldw	r3,0(sp)
10101448:	00900034 	movhi	r2,16384
1010144c:	10bfffc4 	addi	r2,r2,-1
10101450:	1884703a 	and	r2,r3,r2
10101454:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101458:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
1010145c:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
10101460:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
10101464:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101468:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010146c:	0005883a 	mov	r2,zero
10101470:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101474:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		0, write_address, length, control);
}
10101478:	f800283a 	ret

1010147c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
1010147c:	20801217 	ldw	r2,72(r4)
10101480:	11c00e36 	bltu	r2,r7,101014bc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
10101484:	20801703 	ldbu	r2,92(r4)
10101488:	10000c1e 	bne	r2,zero,101014bc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010148c:	d8c00017 	ldw	r3,0(sp)
10101490:	00900034 	movhi	r2,16384
10101494:	10bfffc4 	addi	r2,r2,-1
10101498:	1884703a 	and	r2,r3,r2
1010149c:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
101014a0:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101014a4:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
101014a8:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
101014ac:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
101014b0:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101014b4:	0005883a 	mov	r2,zero
101014b8:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
101014bc:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, 0, length, control);
}
101014c0:	f800283a 	ret

101014c4 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014c4:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014c8:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014cc:	da400217 	ldw	r9,8(sp)
101014d0:	da000317 	ldw	r8,12(sp)
101014d4:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014d8:	50c01c36 	bltu	r10,r3,1010154c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
101014dc:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < write_stride ||
101014e0:	12bfffcc 	andi	r10,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101014e4:	5800021e 	bne	r11,zero,101014f0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x2c>
101014e8:	22c01317 	ldw	r11,76(r4)
101014ec:	5a801736 	bltu	r11,r10,1010154c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
101014f0:	22801703 	ldbu	r10,92(r4)
101014f4:	01000044 	movi	r4,1
101014f8:	5100141e 	bne	r10,r4,1010154c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
101014fc:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101500:	d8c00117 	ldw	r3,4(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101504:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101508:	00900034 	movhi	r2,16384
1010150c:	10bfffc4 	addi	r2,r2,-1
10101510:	1884703a 	and	r2,r3,r2
10101514:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101518:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
1010151c:	28000915 	stw	zero,36(r5)
    descriptor->read_address_low = read_address_low;
10101520:	28000015 	stw	zero,0(r5)
    descriptor->write_address_high = write_address_high;
10101524:	29800a15 	stw	r6,40(r5)
    descriptor->write_address_low = write_address_low;
10101528:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
1010152c:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101530:	28000785 	stb	zero,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101534:	2a0007c5 	stb	r8,31(r5)
    descriptor->read_stride = read_stride;
10101538:	2800080d 	sth	zero,32(r5)
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
1010153c:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
10101540:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101544:	0005883a 	mov	r2,zero
10101548:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
1010154c:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
10101550:	f800283a 	ret

10101554 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101554:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101558:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
1010155c:	da400217 	ldw	r9,8(sp)
10101560:	da000317 	ldw	r8,12(sp)
10101564:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101568:	50c01c36 	bltu	r10,r3,101015dc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
1010156c:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < read_stride ||
10101570:	12bfffcc 	andi	r10,r2,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101574:	5800021e 	bne	r11,zero,10101580 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x2c>
10101578:	22c01317 	ldw	r11,76(r4)
1010157c:	5a801736 	bltu	r11,r10,101015dc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101580:	22801703 	ldbu	r10,92(r4)
10101584:	01000044 	movi	r4,1
10101588:	5100141e 	bne	r10,r4,101015dc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
1010158c:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101590:	d8c00117 	ldw	r3,4(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101594:	2880080d 	sth	r2,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101598:	00900034 	movhi	r2,16384
1010159c:	10bfffc4 	addi	r2,r2,-1
101015a0:	1884703a 	and	r2,r3,r2
101015a4:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
101015a8:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
101015ac:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
101015b0:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
101015b4:	28000a15 	stw	zero,40(r5)
    descriptor->write_address_low = write_address_low;
101015b8:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
101015bc:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
101015c0:	2a000785 	stb	r8,30(r5)
    descriptor->write_burst_count = write_burst_count;
101015c4:	280007c5 	stb	zero,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101015c8:	2800088d 	sth	zero,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
101015cc:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
101015d0:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101015d4:	0005883a 	mov	r2,zero
101015d8:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101015dc:	00bffa84 	movi	r2,-22
	alt_u16 read_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
101015e0:	f800283a 	ret

101015e4 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
101015e4:	da000217 	ldw	r8,8(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101015e8:	22401217 	ldw	r9,72(r4)
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
101015ec:	db400417 	ldw	r13,16(sp)
101015f0:	db000517 	ldw	r12,20(sp)
101015f4:	dac00617 	ldw	r11,24(sp)
101015f8:	d8c00717 	ldw	r3,28(sp)
101015fc:	d8800817 	ldw	r2,32(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101600:	4a002136 	bltu	r9,r8,10101688 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
10101604:	22801417 	ldw	r10,80(r4)
10101608:	22401317 	ldw	r9,76(r4)
1010160c:	1bbfffcc 	andi	r14,r3,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101610:	5000011e 	bne	r10,zero,10101618 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x34>
10101614:	4b801c36 	bltu	r9,r14,10101688 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101618:	13bfffcc 	andi	r14,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
1010161c:	5000011e 	bne	r10,zero,10101624 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x40>
10101620:	4b801936 	bltu	r9,r14,10101688 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < write_stride ||
10101624:	22401703 	ldbu	r9,92(r4)
10101628:	01000044 	movi	r4,1
1010162c:	4900161e 	bne	r9,r4,10101688 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101630:	d9000017 	ldw	r4,0(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101634:	28c0080d 	sth	r3,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101638:	d8c00317 	ldw	r3,12(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010163c:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101640:	00900034 	movhi	r2,16384
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101644:	29000a15 	stw	r4,40(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101648:	10bfffc4 	addi	r2,r2,-1
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
1010164c:	d9000117 	ldw	r4,4(sp)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101650:	1884703a 	and	r2,r3,r2
10101654:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101658:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
1010165c:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
10101660:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
10101664:	29000115 	stw	r4,4(r5)
    descriptor->transfer_length = length;
10101668:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
1010166c:	2b40070d 	sth	r13,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101670:	2b000785 	stb	r12,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101674:	2ac007c5 	stb	r11,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
10101678:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
1010167c:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101680:	0005883a 	mov	r2,zero
10101684:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101688:	00bffa84 	movi	r2,-22
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
1010168c:	f800283a 	ret

10101690 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
10101690:	28001126 	beq	r5,zero,101016d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
10101694:	29800317 	ldw	r6,12(r5)
10101698:	29800f1e 	bne	r5,r6,101016d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
1010169c:	20800017 	ldw	r2,0(r4)
101016a0:	1000021e 	bne	r2,zero,101016ac <alt_msgdma_prefetcher_add_standard_desc_to_list+0x1c>
	{
		*list = descriptor;  /* make this root-node if list is empty */
101016a4:	21400015 	stw	r5,0(r4)
		return 0;  /* successfully added */
101016a8:	f800283a 	ret
	}
	if (*list == descriptor)
101016ac:	11400a26 	beq	r2,r5,101016d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
101016b0:	1007883a 	mov	r3,r2
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
101016b4:	19000317 	ldw	r4,12(r3)
101016b8:	20800326 	beq	r4,r2,101016c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x38>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
101016bc:	21800626 	beq	r4,r6,101016d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
101016c0:	2007883a 	mov	r3,r4
101016c4:	003ffb06 	br	101016b4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x24>
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
101016c8:	19800315 	stw	r6,12(r3)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
101016cc:	28800315 	stw	r2,12(r5)
	return 0; /* successfully added */
101016d0:	0005883a 	mov	r2,zero
101016d4:	f800283a 	ret
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
101016d8:	00bffa84 	movi	r2,-22
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
	return 0; /* successfully added */
}
101016dc:	f800283a 	ret

101016e0 <alt_msgdma_prefetcher_add_extended_desc_to_list>:
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
101016e0:	2800021e 	bne	r5,zero,101016ec <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
101016e4:	00bffa84 	movi	r2,-22
101016e8:	f800283a 	ret
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
101016ec:	28800317 	ldw	r2,12(r5)
101016f0:	11400226 	beq	r2,r5,101016fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x1c>
101016f4:	28800b17 	ldw	r2,44(r5)
101016f8:	103ffa1e 	bne	r2,zero,101016e4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
101016fc:	20800017 	ldw	r2,0(r4)
10101700:	1000021e 	bne	r2,zero,1010170c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
10101704:	21400015 	stw	r5,0(r4)
		return 0;
10101708:	f800283a 	ret
	}
	if (*list == descriptor)
1010170c:	117ff526 	beq	r2,r5,101016e4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
10101710:	1007883a 	mov	r3,r2
10101714:	11000317 	ldw	r4,12(r2)
10101718:	20c0061e 	bne	r4,r3,10101734 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x54>
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
1010171c:	11400315 	stw	r5,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
10101720:	10000b15 	stw	zero,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
10101724:	28c00315 	stw	r3,12(r5)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
10101728:	28000b15 	stw	zero,44(r5)
	return 0;
1010172c:	0005883a 	mov	r2,zero
10101730:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
10101734:	11800b17 	ldw	r6,44(r2)
10101738:	303ff826 	beq	r6,zero,1010171c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x3c>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
1010173c:	2005883a 	mov	r2,r4
10101740:	003ff406 	br	10101714 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x34>

10101744 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
10101744:	20000a26 	beq	r4,zero,10101770 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
10101748:	2005883a 	mov	r2,r4
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
1010174c:	10c00717 	ldw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101750:	11400317 	ldw	r5,12(r2)
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101754:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
10101758:	10c00715 	stw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
1010175c:	21400226 	beq	r4,r5,10101768 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x24>
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
10101760:	2805883a 	mov	r2,r5
10101764:	003ff906 	br	1010174c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x8>
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
10101768:	0005883a 	mov	r2,zero
1010176c:	f800283a 	ret
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
10101770:	00bffa84 	movi	r2,-22
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
}
10101774:	f800283a 	ret

10101778 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
10101778:	20000f26 	beq	r4,zero,101017b8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
1010177c:	200b883a 	mov	r5,r4
10101780:	20c00317 	ldw	r3,12(r4)
10101784:	1940051e 	bne	r3,r5,1010179c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x24>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101788:	20800f17 	ldw	r2,60(r4)
1010178c:	10900034 	orhi	r2,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
10101790:	20800f15 	stw	r2,60(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
10101794:	0005883a 	mov	r2,zero
10101798:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
1010179c:	20800b17 	ldw	r2,44(r4)
101017a0:	103ff926 	beq	r2,zero,10101788 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x10>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101017a4:	20800f17 	ldw	r2,60(r4)
101017a8:	10900034 	orhi	r2,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
101017ac:	20800f15 	stw	r2,60(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
101017b0:	1809883a 	mov	r4,r3
101017b4:	003ff206 	br	10101780 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8>
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
101017b8:	00bffa84 	movi	r2,-22
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
}
101017bc:	f800283a 	ret

101017c0 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
101017c0:	da800017 	ldw	r10,0(sp)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
101017c4:	20800617 	ldw	r2,24(r4)
101017c8:	10800037 	ldwio	r2,0(r2)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
101017cc:	10c0004c 	andi	r3,r2,1
101017d0:	18003b1e 	bne	r3,zero,101018c0 <alt_msgdma_start_prefetcher_with_list_addr+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101017d4:	0011303a 	rdctl	r8,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101017d8:	00ffff84 	movi	r3,-2
101017dc:	40d2703a 	and	r9,r8,r3
101017e0:	4801703a 	wrctl	status,r9
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
101017e4:	22400317 	ldw	r9,12(r4)
101017e8:	02c00804 	movi	r11,32
101017ec:	4ac00135 	stwio	r11,4(r9)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
101017f0:	22400317 	ldw	r9,12(r4)
101017f4:	4ac00037 	ldwio	r11,0(r9)
101017f8:	4ac00035 	stwio	r11,0(r9)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101017fc:	4001703a 	wrctl	status,r8
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
10101800:	22400b17 	ldw	r9,44(r4)
10101804:	22c00317 	ldw	r11,12(r4)
10101808:	22000d17 	ldw	r8,52(r4)
1010180c:	48000526 	beq	r9,zero,10101824 <alt_msgdma_start_prefetcher_with_list_addr+0x64>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101810:	027ff7c4 	movi	r9,-33
10101814:	4250703a 	and	r8,r8,r9
10101818:	42000514 	ori	r8,r8,20
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
1010181c:	10800214 	ori	r2,r2,8
10101820:	00000506 	br	10101838 <alt_msgdma_start_prefetcher_with_list_addr+0x78>
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101824:	027ff3c4 	movi	r9,-49
10101828:	4250703a 	and	r8,r8,r9
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
1010182c:	027ffdc4 	movi	r9,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101830:	42000114 	ori	r8,r8,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
10101834:	1244703a 	and	r2,r2,r9
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101838:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
1010183c:	48c6703a 	and	r3,r9,r3
10101840:	1801703a 	wrctl	status,r3
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
10101844:	5a000135 	stwio	r8,4(r11)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
10101848:	20c00617 	ldw	r3,24(r4)
1010184c:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101850:	4801703a 	wrctl	status,r9
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
10101854:	20c00617 	ldw	r3,24(r4)
10101858:	19400135 	stwio	r5,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
1010185c:	20c00617 	ldw	r3,24(r4)
10101860:	19800235 	stwio	r6,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
10101864:	39c03fcc 	andi	r7,r7,255
10101868:	38000226 	beq	r7,zero,10101874 <alt_msgdma_start_prefetcher_with_list_addr+0xb4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
1010186c:	10800414 	ori	r2,r2,16
10101870:	00000206 	br	1010187c <alt_msgdma_start_prefetcher_with_list_addr+0xbc>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
10101874:	00fffbc4 	movi	r3,-17
10101878:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
1010187c:	50c03fcc 	andi	r3,r10,255
10101880:	18000826 	beq	r3,zero,101018a4 <alt_msgdma_start_prefetcher_with_list_addr+0xe4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
10101884:	20c00617 	ldw	r3,24(r4)
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
10101888:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
1010188c:	18c00304 	addi	r3,r3,12
10101890:	19400037 	ldwio	r5,0(r3)
10101894:	2800051e 	bne	r5,zero,101018ac <alt_msgdma_start_prefetcher_with_list_addr+0xec>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
10101898:	01403fc4 	movi	r5,255
1010189c:	19400035 	stwio	r5,0(r3)
101018a0:	00000206 	br	101018ac <alt_msgdma_start_prefetcher_with_list_addr+0xec>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
101018a4:	00ffff44 	movi	r3,-3
101018a8:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018ac:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
101018b0:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018b4:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
101018b8:	0005883a 	mov	r2,zero
101018bc:	f800283a 	ret
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
101018c0:	00bffc04 	movi	r2,-16
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
}
101018c4:	f800283a 	ret

101018c8 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018c8:	defffa04 	addi	sp,sp,-24
101018cc:	dc800415 	stw	r18,16(sp)
101018d0:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018d4:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018d8:	dc400315 	stw	r17,12(sp)
101018dc:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018e0:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018e4:	dfc00515 	stw	ra,20(sp)
101018e8:	3023883a 	mov	r17,r6
101018ec:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018f0:	01017440 	call	10101744 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
101018f4:	d9400117 	ldw	r5,4(sp)
101018f8:	1000071e 	bne	r2,zero,10101918 <alt_msgdma_start_prefetcher_with_std_desc_list+0x50>
		return -EINVAL;
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
101018fc:	84003fcc 	andi	r16,r16,255
10101900:	dc000015 	stw	r16,0(sp)
10101904:	9009883a 	mov	r4,r18
10101908:	000d883a 	mov	r6,zero
1010190c:	89c03fcc 	andi	r7,r17,255
10101910:	01017c00 	call	101017c0 <alt_msgdma_start_prefetcher_with_list_addr>
10101914:	00000106 	br	1010191c <alt_msgdma_start_prefetcher_with_std_desc_list+0x54>
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101918:	00bffa84 	movi	r2,-22
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
			park_mode_en, poll_en);
}
1010191c:	dfc00517 	ldw	ra,20(sp)
10101920:	dc800417 	ldw	r18,16(sp)
10101924:	dc400317 	ldw	r17,12(sp)
10101928:	dc000217 	ldw	r16,8(sp)
1010192c:	dec00604 	addi	sp,sp,24
10101930:	f800283a 	ret

10101934 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101934:	defffa04 	addi	sp,sp,-24
10101938:	dc800415 	stw	r18,16(sp)
1010193c:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101940:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101944:	dc400315 	stw	r17,12(sp)
10101948:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
1010194c:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101950:	dfc00515 	stw	ra,20(sp)
10101954:	3023883a 	mov	r17,r6
10101958:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
1010195c:	01017780 	call	10101778 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
10101960:	d9400117 	ldw	r5,4(sp)
10101964:	1000071e 	bne	r2,zero,10101984 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
10101968:	84003fcc 	andi	r16,r16,255
1010196c:	dc000015 	stw	r16,0(sp)
10101970:	9009883a 	mov	r4,r18
10101974:	000d883a 	mov	r6,zero
10101978:	89c03fcc 	andi	r7,r17,255
1010197c:	01017c00 	call	101017c0 <alt_msgdma_start_prefetcher_with_list_addr>
10101980:	00000106 	br	10101988 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x54>
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101984:	00bffa84 	movi	r2,-22
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
			park_mode_en, poll_en);
}
10101988:	dfc00517 	ldw	ra,20(sp)
1010198c:	dc800417 	ldw	r18,16(sp)
10101990:	dc400317 	ldw	r17,12(sp)
10101994:	dc000217 	ldw	r16,8(sp)
10101998:	dec00604 	addi	sp,sp,24
1010199c:	f800283a 	ret

101019a0 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019a0:	defffe04 	addi	sp,sp,-8
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019a4:	d1600204 	addi	r5,gp,-32760
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019a8:	dc000015 	stw	r16,0(sp)
101019ac:	dfc00115 	stw	ra,4(sp)
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019b0:	0101c1c0 	call	10101c1c <alt_find_dev>
101019b4:	1021883a 	mov	r16,r2

    if (NULL == dev)
101019b8:	10000a1e 	bne	r2,zero,101019e4 <alt_msgdma_open+0x44>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
101019bc:	00840434 	movhi	r2,4112
101019c0:	10887404 	addi	r2,r2,8656
101019c4:	10800017 	ldw	r2,0(r2)
101019c8:	10000226 	beq	r2,zero,101019d4 <alt_msgdma_open+0x34>
101019cc:	103ee83a 	callr	r2
101019d0:	00000206 	br	101019dc <alt_msgdma_open+0x3c>
101019d4:	00840434 	movhi	r2,4112
101019d8:	10889904 	addi	r2,r2,8804
    {
        ALT_ERRNO = ENODEV;
101019dc:	00c004c4 	movi	r3,19
101019e0:	10c00015 	stw	r3,0(r2)
    }

    return dev;
}
101019e4:	8005883a 	mov	r2,r16
101019e8:	dfc00117 	ldw	ra,4(sp)
101019ec:	dc000017 	ldw	r16,0(sp)
101019f0:	dec00204 	addi	sp,sp,8
101019f4:	f800283a 	ret

101019f8 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
101019f8:	defffb04 	addi	sp,sp,-20
101019fc:	dc800315 	stw	r18,12(sp)
10101a00:	dc400215 	stw	r17,8(sp)
10101a04:	dc000115 	stw	r16,4(sp)
10101a08:	dfc00415 	stw	ra,16(sp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a0c:	20801783 	ldbu	r2,94(r4)
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101a10:	2021883a 	mov	r16,r4
10101a14:	2825883a 	mov	r18,r5
10101a18:	3023883a 	mov	r17,r6
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a1c:	1000041e 	bne	r2,zero,10101a30 <alt_msgdma_init+0x38>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
10101a20:	80800317 	ldw	r2,12(r16)
10101a24:	00c00084 	movi	r3,2
10101a28:	10c00135 	stwio	r3,4(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a2c:	00000806 	br	10101a50 <alt_msgdma_init+0x58>
    int error;

    if (dev->prefetcher_enable)
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
10101a30:	20800617 	ldw	r2,24(r4)
10101a34:	00c00104 	movi	r3,4
10101a38:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
10101a3c:	80800617 	ldw	r2,24(r16)
10101a40:	10800037 	ldwio	r2,0(r2)
10101a44:	1080010c 	andi	r2,r2,4
10101a48:	103ffc1e 	bne	r2,zero,10101a3c <alt_msgdma_init+0x44>
10101a4c:	003ff406 	br	10101a20 <alt_msgdma_init+0x28>
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a50:	80800317 	ldw	r2,12(r16)
10101a54:	10c00037 	ldwio	r3,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
10101a58:	18c0100c 	andi	r3,r3,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a5c:	183ffc1e 	bne	r3,zero,10101a50 <alt_msgdma_init+0x58>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10101a60:	10800104 	addi	r2,r2,4
10101a64:	11000037 	ldwio	r4,0(r2)
10101a68:	00fffbc4 	movi	r3,-17
10101a6c:	20c6703a 	and	r3,r4,r3
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
10101a70:	18c00814 	ori	r3,r3,32
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10101a74:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
10101a78:	80800317 	ldw	r2,12(r16)
10101a7c:	10c00037 	ldwio	r3,0(r2)
10101a80:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
10101a84:	80801783 	ldbu	r2,94(r16)
10101a88:	10000426 	beq	r2,zero,10101a9c <alt_msgdma_init+0xa4>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
10101a8c:	80800617 	ldw	r2,24(r16)
10101a90:	10800404 	addi	r2,r2,16
10101a94:	10c00037 	ldwio	r3,0(r2)
10101a98:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
10101a9c:	8009883a 	mov	r4,r16
10101aa0:	d1600204 	addi	r5,gp,-32760
10101aa4:	0101ba40 	call	10101ba4 <alt_dev_llist_insert>
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
            
    if (!error)
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
10101aa8:	01840434 	movhi	r6,4112
10101aac:	d8000015 	stw	zero,0(sp)
10101ab0:	9009883a 	mov	r4,r18
10101ab4:	880b883a 	mov	r5,r17
10101ab8:	31833204 	addi	r6,r6,3272
10101abc:	800f883a 	mov	r7,r16
10101ac0:	010084c0 	call	1010084c <alt_ic_isr_register>
        alt_printf("failed to create semaphores\n");
    }
    
    return;

}
10101ac4:	dfc00417 	ldw	ra,16(sp)
10101ac8:	dc800317 	ldw	r18,12(sp)
10101acc:	dc400217 	ldw	r17,8(sp)
10101ad0:	dc000117 	ldw	r16,4(sp)
10101ad4:	dec00504 	addi	sp,sp,20
10101ad8:	f800283a 	ret

10101adc <alt_msgdma_register_callback>:
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
    dev->callback         = callback;
10101adc:	21400b15 	stw	r5,44(r4)
    dev->callback_context = context;
10101ae0:	21c00c15 	stw	r7,48(r4)
    dev->control          = control;
10101ae4:	21800d15 	stw	r6,52(r4)
10101ae8:	f800283a 	ret

10101aec <alt_msgdma_standard_descriptor_async_transfer>:
{
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
10101aec:	000d883a 	mov	r6,zero
10101af0:	010102c1 	jmpi	1010102c <alt_msgdma_descriptor_async_transfer>

10101af4 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101af4:	280d883a 	mov	r6,r5
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
10101af8:	000b883a 	mov	r5,zero
10101afc:	010102c1 	jmpi	1010102c <alt_msgdma_descriptor_async_transfer>

10101b00 <alt_msgdma_standard_descriptor_sync_transfer>:
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
10101b00:	000d883a 	mov	r6,zero
10101b04:	0100dfc1 	jmpi	10100dfc <alt_msgdma_descriptor_sync_transfer>

10101b08 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101b08:	280d883a 	mov	r6,r5
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
10101b0c:	000b883a 	mov	r5,zero
10101b10:	0100dfc1 	jmpi	10100dfc <alt_msgdma_descriptor_sync_transfer>

10101b14 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b14:	01420034 	movhi	r5,2048
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b18:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b1c:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b20:	dc000015 	stw	r16,0(sp)
10101b24:	dfc00115 	stw	ra,4(sp)
10101b28:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b2c:	01008140 	call	10100814 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b30:	10000e26 	beq	r2,zero,10101b6c <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b34:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b38:	013e0034 	movhi	r4,63488
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b3c:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b40:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b44:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b48:	297fffc4 	addi	r5,r5,-1
10101b4c:	283ffe1e 	bne	r5,zero,10101b48 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b50:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b54:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b58:	18bffb16 	blt	r3,r2,10101b48 <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b5c:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b60:	843fffc4 	addi	r16,r16,-1
10101b64:	803ffe1e 	bne	r16,zero,10101b60 <alt_busy_sleep+0x4c>
10101b68:	00000306 	br	10101b78 <alt_busy_sleep+0x64>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b6c:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b70:	843fffc4 	addi	r16,r16,-1
10101b74:	043ffe16 	blt	zero,r16,10101b70 <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
10101b78:	0005883a 	mov	r2,zero
10101b7c:	dfc00117 	ldw	ra,4(sp)
10101b80:	dc000017 	ldw	r16,0(sp)
10101b84:	dec00204 	addi	sp,sp,8
10101b88:	f800283a 	ret

10101b8c <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101b8c:	0005883a 	mov	r2,zero
10101b90:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10101b94:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101b98:	10800804 	addi	r2,r2,32
10101b9c:	10fffd1e 	bne	r2,r3,10101b94 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10101ba0:	f800283a 	ret

10101ba4 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10101ba4:	20000226 	beq	r4,zero,10101bb0 <alt_dev_llist_insert+0xc>
10101ba8:	20800217 	ldw	r2,8(r4)
10101bac:	1000131e 	bne	r2,zero,10101bfc <alt_dev_llist_insert+0x58>
10101bb0:	00840434 	movhi	r2,4112
10101bb4:	10887404 	addi	r2,r2,8656
10101bb8:	10800017 	ldw	r2,0(r2)
10101bbc:	10000926 	beq	r2,zero,10101be4 <alt_dev_llist_insert+0x40>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10101bc0:	deffff04 	addi	sp,sp,-4
10101bc4:	dfc00015 	stw	ra,0(sp)
10101bc8:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101bcc:	00c00584 	movi	r3,22
10101bd0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101bd4:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101bd8:	dfc00017 	ldw	ra,0(sp)
10101bdc:	dec00104 	addi	sp,sp,4
10101be0:	f800283a 	ret
10101be4:	00840434 	movhi	r2,4112
10101be8:	10889904 	addi	r2,r2,8804
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101bec:	00c00584 	movi	r3,22
10101bf0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101bf4:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101bf8:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
10101bfc:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10101c00:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
10101c04:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
10101c08:	28800017 	ldw	r2,0(r5)
10101c0c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
10101c10:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
10101c14:	0005883a 	mov	r2,zero
10101c18:	f800283a 	ret

10101c1c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10101c1c:	defffb04 	addi	sp,sp,-20
10101c20:	dcc00315 	stw	r19,12(sp)
10101c24:	dc800215 	stw	r18,8(sp)
10101c28:	dc400115 	stw	r17,4(sp)
10101c2c:	dc000015 	stw	r16,0(sp)
10101c30:	dfc00415 	stw	ra,16(sp)
10101c34:	2027883a 	mov	r19,r4
10101c38:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
10101c3c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
10101c40:	0101d0c0 	call	10101d0c <strlen>
10101c44:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10101c48:	84400726 	beq	r16,r17,10101c68 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10101c4c:	81000217 	ldw	r4,8(r16)
10101c50:	980b883a 	mov	r5,r19
10101c54:	900d883a 	mov	r6,r18
10101c58:	0101cdc0 	call	10101cdc <memcmp>
10101c5c:	10000426 	beq	r2,zero,10101c70 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
10101c60:	84000017 	ldw	r16,0(r16)
10101c64:	003ff806 	br	10101c48 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
10101c68:	0005883a 	mov	r2,zero
10101c6c:	00000106 	br	10101c74 <alt_find_dev+0x58>
10101c70:	8005883a 	mov	r2,r16
}
10101c74:	dfc00417 	ldw	ra,16(sp)
10101c78:	dcc00317 	ldw	r19,12(sp)
10101c7c:	dc800217 	ldw	r18,8(sp)
10101c80:	dc400117 	ldw	r17,4(sp)
10101c84:	dc000017 	ldw	r16,0(sp)
10101c88:	dec00504 	addi	sp,sp,20
10101c8c:	f800283a 	ret

10101c90 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
10101c90:	0009883a 	mov	r4,zero
10101c94:	01440004 	movi	r5,4096
10101c98:	0101ca41 	jmpi	10101ca4 <alt_icache_flush>

10101c9c <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10101c9c:	000170fa 	wrctl	ienable,zero
10101ca0:	f800283a 	ret

10101ca4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
10101ca4:	00840004 	movi	r2,4096
10101ca8:	1140012e 	bgeu	r2,r5,10101cb0 <alt_icache_flush+0xc>
10101cac:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
10101cb0:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101cb4:	2005883a 	mov	r2,r4
10101cb8:	1140032e 	bgeu	r2,r5,10101cc8 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
10101cbc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101cc0:	10800804 	addi	r2,r2,32
10101cc4:	003ffc06 	br	10101cb8 <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10101cc8:	210007cc 	andi	r4,r4,31
10101ccc:	20000126 	beq	r4,zero,10101cd4 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
10101cd0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
10101cd4:	0000203a 	flushp
10101cd8:	f800283a 	ret

10101cdc <memcmp>:
10101cdc:	218d883a 	add	r6,r4,r6
10101ce0:	21800826 	beq	r4,r6,10101d04 <memcmp+0x28>
10101ce4:	20800003 	ldbu	r2,0(r4)
10101ce8:	28c00003 	ldbu	r3,0(r5)
10101cec:	10c00226 	beq	r2,r3,10101cf8 <memcmp+0x1c>
10101cf0:	10c5c83a 	sub	r2,r2,r3
10101cf4:	f800283a 	ret
10101cf8:	21000044 	addi	r4,r4,1
10101cfc:	29400044 	addi	r5,r5,1
10101d00:	003ff706 	br	10101ce0 <memcmp+0x4>
10101d04:	0005883a 	mov	r2,zero
10101d08:	f800283a 	ret

10101d0c <strlen>:
10101d0c:	2005883a 	mov	r2,r4
10101d10:	10c00007 	ldb	r3,0(r2)
10101d14:	18000226 	beq	r3,zero,10101d20 <strlen+0x14>
10101d18:	10800044 	addi	r2,r2,1
10101d1c:	003ffc06 	br	10101d10 <strlen+0x4>
10101d20:	1105c83a 	sub	r2,r2,r4
10101d24:	f800283a 	ret
