
VGA_Display_Gen1.elf:     file format elf32-littlenios2
VGA_Display_Gen1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10100150

Program Header:
    LOAD off    0x00001000 vaddr 0x10100000 paddr 0x10100000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10100020 paddr 0x10100020 align 2**12
         filesz 0x00002164 memsz 0x00002164 flags r-x
    LOAD off    0x00003184 vaddr 0x10102184 paddr 0x10102bf8 align 2**12
         filesz 0x00000a74 memsz 0x00000a74 flags rw-
    LOAD off    0x0000466c vaddr 0x1010366c paddr 0x1010366c align 2**12
         filesz 0x00000000 memsz 0x00000194 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10100000  10100000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000130  10100020  10100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001bf8  10100150  10100150  00001150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000043c  10101d48  10101d48  00002d48  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000a74  10102184  10102bf8  00003184  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000194  1010366c  1010366c  0000466c  2**4
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  10103800  10103800  00003bf8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00003bf8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000400  00000000  00000000  00003c20  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000052f7  00000000  00000000  00004020  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001b58  00000000  00000000  00009317  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002082  00000000  00000000  0000ae6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000848  00000000  00000000  0000cef4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000184c  00000000  00000000  0000d73c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00002239  00000000  00000000  0000ef88  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  000111c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000208  00000000  00000000  00011228  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00013113  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00013116  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00013122  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00013123  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  00013124  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  0001312f  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  0001313a  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000006  00000000  00000000  00013145  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002c  00000000  00000000  0001314b  2**0
                  CONTENTS, READONLY
 26 .jdi          00003cd3  00000000  00000000  00013177  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     002a0b2b  00000000  00000000  00016e4a  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10100000 l    d  .entry	00000000 .entry
10100020 l    d  .exceptions	00000000 .exceptions
10100150 l    d  .text	00000000 .text
10101d48 l    d  .rodata	00000000 .rodata
10102184 l    d  .rwdata	00000000 .rwdata
1010366c l    d  .bss	00000000 .bss
10103800 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 /home/pokitoz/Dropbox/DE0_SoC_VGA/sw/nios/application/VGA_Display_Gen1_bsp//obj/HAL/src/crt0.o
10100198 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
10100094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 VGA_DMA_display.c
10101da4 l     O .rodata	00000060 msgdma.2774
00000000 l    df *ABS*	00000000 VGA_Display.c
00000000 l    df *ABS*	00000000 msgDMA.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
10100718 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
10102b84 l     O .rwdata	00000060 msgdma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_msgdma.c
10100ce8 l     F .text	000000cc alt_msgdma_irq
10100db4 l     F .text	00000068 alt_msgdma_write_extended_descriptor
10100e1c l     F .text	00000230 alt_msgdma_descriptor_sync_transfer
1010104c l     F .text	00000190 alt_msgdma_descriptor_async_transfer
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
10101b0c g     F .text	00000008 alt_msgdma_standard_descriptor_async_transfer
10100a68 g     F .text	0000002c alt_main
10103700 g     O .bss	00000100 alt_irq
10102bf8 g       *ABS*	00000000 __flash_rwdata_start
10100320 g     F .text	00000014 VGA_Display_changeVerticalPorch
1010124c g     F .text	0000003c alt_msgdma_construct_standard_mm_to_mm_descriptor
101005e4 g     F .text	00000134 msgdma_create_mm_to_st_descriptor_list
10103674 g     O .bss	00000004 descriptor_number
101011dc g     F .text	00000038 alt_msgdma_construct_standard_st_to_mm_descriptor
10100c48 g     F .text	00000038 alt_putstr
00000000  w      *UND*	00000000 __errno
10100000 g     F .entry	0000001c __reset
10100020 g       *ABS*	00000000 __flash_exceptions_start
10103688 g     O .bss	00000004 errno
10103680 g     O .bss	00000004 alt_argv
1010abe4 g       *ABS*	00000000 _gp
10101798 g     F .text	00000048 alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
10101c3c g     F .text	00000074 alt_find_dev
10100844 g     F .text	00000028 memcpy
10101954 g     F .text	0000006c alt_msgdma_start_prefetcher_with_extd_desc_list
10101b14 g     F .text	0000000c alt_msgdma_extended_descriptor_async_transfer
10101afc g     F .text	00000010 alt_msgdma_register_callback
101016b0 g     F .text	00000050 alt_msgdma_prefetcher_add_standard_desc_to_list
10100000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
10100834 g     F .text	00000008 .hidden __udivsi3
1010366c g     O .bss	00000004 next_desc
10101cc4 g     F .text	00000038 alt_icache_flush
10101454 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
10103800 g       *ABS*	00000000 __bss_end
10100908 g     F .text	00000068 alt_iic_isr_register
10101a18 g     F .text	000000e4 alt_msgdma_init
10101b28 g     F .text	0000000c alt_msgdma_extended_descriptor_sync_transfer
101008f0 g     F .text	00000018 alt_ic_irq_enabled
10103678 g     O .bss	00000004 alt_irq_active
101000ec g     F .exceptions	00000064 alt_irq_handler
10101300 g     F .text	00000078 alt_msgdma_construct_extended_mm_to_st_descriptor
101018e8 g     F .text	0000006c alt_msgdma_start_prefetcher_with_std_desc_list
10101bac g     F .text	00000018 alt_dcache_flush_all
10102bf8 g       *ABS*	00000000 __ram_rwdata_end
10102184 g       *ABS*	00000000 __ram_rodata_end
10102be8 g     O .rwdata	00000004 jtag_uart_0
1010083c g     F .text	00000008 .hidden __umodsi3
1010149c g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
10103800 g       *ABS*	00000000 end
10104000 g       *ABS*	00000000 __alt_stack_pointer
10100cb4 g     F .text	00000034 altera_avalon_jtag_uart_write
10100a94 g     F .text	0000016c alt_printf
10100150 g     F .text	0000004c _start
10101214 g     F .text	00000038 alt_msgdma_construct_standard_mm_to_st_descriptor
10100ca0 g     F .text	00000014 alt_sys_init
10100350 g     F .text	00000040 VGA_Display_set_irq
10102184 g       *ABS*	00000000 __ram_rwdata_start
10101d48 g       *ABS*	00000000 __ram_rodata_start
10103690 g     O .bss	00000060 msgdma_dev
101036f0 g     O .bss	00000010 msgdma_desc
10101b34 g     F .text	00000078 alt_busy_sleep
10101408 g     F .text	0000004c alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
10101cfc g     F .text	00000030 memcmp
10103800 g       *ABS*	00000000 __alt_stack_base
101014e4 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
10102184 g     O .rwdata	00000a00 const_img
10101bc4 g     F .text	00000078 alt_dev_llist_insert
1010366c g       *ABS*	00000000 __bss_start
101019c0 g     F .text	00000058 alt_msgdma_open
10100220 g     F .text	00000100 main
1010367c g     O .bss	00000004 alt_envp
10101700 g     F .text	00000064 alt_msgdma_prefetcher_add_extended_desc_to_list
101017e0 g     F .text	00000108 alt_msgdma_start_prefetcher_with_list_addr
10102bf4 g     O .rwdata	00000004 alt_errno
10101604 g     F .text	000000ac alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
10100784 g     F .text	00000054 .hidden __divsi3
10101d48 g       *ABS*	00000000 __flash_rodata_start
10100c80 g     F .text	00000020 alt_irq_init
10101b20 g     F .text	00000008 alt_msgdma_standard_descriptor_sync_transfer
10101574 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
10103684 g     O .bss	00000004 alt_argc
1010019c g     F .text	00000084 irq_vsync
10100020 g       .exceptions	00000000 alt_irq_entry
10100020 g       *ABS*	00000000 __ram_exceptions_start
1010086c g     F .text	00000004 alt_ic_isr_register
10102bf8 g       *ABS*	00000000 _edata
10103800 g       *ABS*	00000000 _end
10100150 g       *ABS*	00000000 __ram_exceptions_end
10100334 g     F .text	00000014 VGA_Display_changeHorizontalPorch
101008b0 g     F .text	00000040 alt_ic_irq_disable
10100348 g     F .text	00000008 VGA_Display_changeScreenColor
10101cbc g     F .text	00000008 altera_nios2_qsys_irq_init
10101764 g     F .text	00000034 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
101007d8 g     F .text	0000005c .hidden __modsi3
10104000 g       *ABS*	00000000 __alt_data_end
10100020 g     F .exceptions	00000000 alt_exception
10100390 g     F .text	000000f4 msgdma_transfer
10101378 g     F .text	00000090 alt_msgdma_construct_extended_mm_to_mm_descriptor
10101288 g     F .text	00000078 alt_msgdma_construct_extended_st_to_mm_descriptor
1010001c g       .entry	00000000 _exit
10102bec g     O .rwdata	00000008 alt_msgdma_list
10101d2c g     F .text	0000001c strlen
10100c00 g     F .text	00000048 alt_putchar
10103670 g     O .bss	00000004 vsync
10101cb0 g     F .text	0000000c alt_icache_flush_all
10102be4 g     O .rwdata	00000004 alt_priority_mask
10100870 g     F .text	00000040 alt_ic_irq_enable
10100484 g     F .text	00000160 msgdma_create_mm_to_mm_descriptor_list
10100970 g     F .text	000000f8 alt_load



Disassembly of section .entry:

10100000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10100000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10100004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10100008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1010000c:	00bffd16 	blt	zero,r2,10100004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10100010:	00440434 	movhi	at,4112
    ori r1, r1, %lo(_start)
10100014:	08405414 	ori	at,at,336
    jmp r1
10100018:	0800683a 	jmp	at

1010001c <_exit>:
1010001c:	00000000 	call	10000000 <__alt_mem_onchip_memory2_0-0x100000>

Disassembly of section .exceptions:

10100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
10100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
10100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
10100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1010002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1010003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
10100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
10100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1010004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1010005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1010006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1010007c:	10000326 	beq	r2,zero,1010008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10100080:	20000226 	beq	r4,zero,1010008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10100084:	01000ec0 	call	101000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10100088:	00000306 	br	10100098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1010008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10100090:	e8bfff17 	ldw	r2,-4(ea)

10100094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10100094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10100098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1010009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
101000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
101000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
101000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
101000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
101000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
101000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
101000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
101000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
101000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
101000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
101000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
101000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
101000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
101000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
101000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
101000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
101000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
101000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
101000e8:	ef80083a 	eret

101000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
101000ec:	defffe04 	addi	sp,sp,-8
101000f0:	dfc00115 	stw	ra,4(sp)
101000f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
101000f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
101000fc:	04040434 	movhi	r16,4112
10100100:	840dc004 	addi	r16,r16,14080

  active = alt_irq_pending ();

  do
  {
    i = 0;
10100104:	0005883a 	mov	r2,zero
    mask = 1;
10100108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
1010010c:	190a703a 	and	r5,r3,r4
10100110:	28000c26 	beq	r5,zero,10100144 <alt_irq_handler+0x58>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10100114:	100490fa 	slli	r2,r2,3
10100118:	8087883a 	add	r3,r16,r2
1010011c:	1805883a 	mov	r2,r3
10100120:	11000117 	ldw	r4,4(r2)
10100124:	18c00017 	ldw	r3,0(r3)
10100128:	183ee83a 	callr	r3
1010012c:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10100130:	203ff41e 	bne	r4,zero,10100104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
10100134:	dfc00117 	ldw	ra,4(sp)
10100138:	dc000017 	ldw	r16,0(sp)
1010013c:	dec00204 	addi	sp,sp,8
10100140:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10100144:	18c7883a 	add	r3,r3,r3
      i++;
10100148:	10800044 	addi	r2,r2,1

    } while (1);
1010014c:	003fef06 	br	1010010c <alt_irq_handler+0x20>

Disassembly of section .text:

10100150 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10100150:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
10100154:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
10100158:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
1010015c:	00bffd16 	blt	zero,r2,10100154 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10100160:	06c40434 	movhi	sp,4112
    ori sp, sp, %lo(__alt_stack_pointer)
10100164:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
10100168:	06840434 	movhi	gp,4112
    ori gp, gp, %lo(_gp)
1010016c:	d6aaf914 	ori	gp,gp,44004
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
10100170:	00840434 	movhi	r2,4112
    ori r2, r2, %lo(__bss_start)
10100174:	108d9b14 	ori	r2,r2,13932

    movhi r3, %hi(__bss_end)
10100178:	00c40434 	movhi	r3,4112
    ori r3, r3, %lo(__bss_end)
1010017c:	18ce0014 	ori	r3,r3,14336

    beq r2, r3, 1f
10100180:	10c00326 	beq	r2,r3,10100190 <_start+0x40>

0:
    stw zero, (r2)
10100184:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
10100188:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
1010018c:	10fffd36 	bltu	r2,r3,10100184 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
10100190:	01009700 	call	10100970 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
10100194:	0100a680 	call	10100a68 <alt_main>

10100198 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
10100198:	003fff06 	br	10100198 <alt_after_alt_main>

1010019c <irq_vsync>:

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
1010019c:	defffe04 	addi	sp,sp,-8
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev, &msgdma_desc, const_img, 640, 0);
101001a0:	01040434 	movhi	r4,4112
101001a4:	01440434 	movhi	r5,4112
101001a8:	01840434 	movhi	r6,4112
101001ac:	d8000015 	stw	zero,0(sp)
101001b0:	210da404 	addi	r4,r4,13968
101001b4:	294dbc04 	addi	r5,r5,14064
101001b8:	31886104 	addi	r6,r6,8580
101001bc:	01c0a004 	movi	r7,640

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
101001c0:	dfc00115 	stw	ra,4(sp)
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev, &msgdma_desc, const_img, 640, 0);
101001c4:	01012140 	call	10101214 <alt_msgdma_construct_standard_mm_to_st_descriptor>

	next_desc++;
101001c8:	d0a2a217 	ldw	r2,-30072(gp)
101001cc:	10800044 	addi	r2,r2,1
101001d0:	d0a2a215 	stw	r2,-30072(gp)
	vsync++;
101001d4:	d0a2a317 	ldw	r2,-30068(gp)
101001d8:	10800044 	addi	r2,r2,1
101001dc:	d0a2a315 	stw	r2,-30068(gp)
	if (next_desc == descriptor_number) {
101001e0:	d0e2a217 	ldw	r3,-30072(gp)
101001e4:	d0a2a417 	ldw	r2,-30064(gp)
101001e8:	1880011e 	bne	r3,r2,101001f0 <irq_vsync+0x54>
		next_desc = 0;
101001ec:	d022a215 	stw	zero,-30072(gp)
	}

	alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);
101001f0:	01040434 	movhi	r4,4112
101001f4:	01440434 	movhi	r5,4112
101001f8:	210da404 	addi	r4,r4,13968
101001fc:	294dbc04 	addi	r5,r5,14064
10100200:	0101b0c0 	call	10101b0c <alt_msgdma_standard_descriptor_async_transfer>

	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);
10100204:	00840034 	movhi	r2,4096
10100208:	10821704 	addi	r2,r2,2140
1010020c:	00c00044 	movi	r3,1
10100210:	10c00035 	stwio	r3,0(r2)

}
10100214:	dfc00117 	ldw	ra,4(sp)
10100218:	dec00204 	addi	sp,sp,8
1010021c:	f800283a 	ret

10100220 <main>:

int main(void) {

	alt_putstr("Hello from VGA_DMA Gen1 project!\n");
10100220:	01040434 	movhi	r4,4112
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
10100224:	defffc04 	addi	sp,sp,-16

	alt_putstr("Hello from VGA_DMA Gen1 project!\n");
10100228:	21075204 	addi	r4,r4,7496
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
1010022c:	dfc00315 	stw	ra,12(sp)
10100230:	dc000215 	stw	r16,8(sp)

	alt_putstr("Hello from VGA_DMA Gen1 project!\n");
10100234:	0100c480 	call	10100c48 <alt_putstr>

	VGA_Display_changeScreenColor(VGA_MODULE_0_BASE, 0x00FF00FF);
10100238:	01040034 	movhi	r4,4096
1010023c:	01403ff4 	movhi	r5,255
10100240:	21021004 	addi	r4,r4,2112
10100244:	29403fc4 	addi	r5,r5,255
10100248:	01003480 	call	10100348 <VGA_Display_changeScreenColor>

	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CONFIGURATION, 0x0);
1010024c:	00840034 	movhi	r2,4096
10100250:	10821104 	addi	r2,r2,2116
10100254:	10000035 	stwio	zero,0(r2)

	ALTERA_MSGDMA_CSR_DESCRIPTOR_SLAVE_INSTANCE(MSGDMA_0, MSGDMA_0_CSR, MSGDMA_0_DESCRIPTOR_SLAVE, msgdma);

	msgdma_dev = msgdma;
10100258:	01040434 	movhi	r4,4112
1010025c:	01440434 	movhi	r5,4112
10100260:	210da404 	addi	r4,r4,13968
10100264:	29476904 	addi	r5,r5,7588
10100268:	01801804 	movi	r6,96
1010026c:	01008440 	call	10100844 <memcpy>
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID, MSGDMA_0_CSR_IRQ);
10100270:	01040434 	movhi	r4,4112
10100274:	210da404 	addi	r4,r4,13968
10100278:	000b883a 	mov	r5,zero
1010027c:	01800044 	movi	r6,1
10100280:	0101a180 	call	10101a18 <alt_msgdma_init>
10100284:	00c40434 	movhi	r3,4112

	int j = 0;
	alt_u8* u8_array = (alt_u8*) const_img;
	for(j = 0; j < 640*3; j++){
10100288:	0005883a 	mov	r2,zero
1010028c:	18c86104 	addi	r3,r3,8580
		if(j%2 == 0){
			u8_array[j] = 0x0F;
		}else{
			u8_array[j] = 0xF0;
10100290:	017ffc04 	movi	r5,-16

	int j = 0;
	alt_u8* u8_array = (alt_u8*) const_img;
	for(j = 0; j < 640*3; j++){
		if(j%2 == 0){
			u8_array[j] = 0x0F;
10100294:	018003c4 	movi	r6,15
	msgdma_dev = msgdma;
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID, MSGDMA_0_CSR_IRQ);

	int j = 0;
	alt_u8* u8_array = (alt_u8*) const_img;
	for(j = 0; j < 640*3; j++){
10100298:	0101e004 	movi	r4,1920
		if(j%2 == 0){
1010029c:	11c0004c 	andi	r7,r2,1
101002a0:	3800031e 	bne	r7,zero,101002b0 <main+0x90>
101002a4:	10cf883a 	add	r7,r2,r3
			u8_array[j] = 0x0F;
101002a8:	39800005 	stb	r6,0(r7)
101002ac:	00000206 	br	101002b8 <main+0x98>
101002b0:	10cf883a 	add	r7,r2,r3
		}else{
			u8_array[j] = 0xF0;
101002b4:	39400005 	stb	r5,0(r7)
	msgdma_dev = msgdma;
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID, MSGDMA_0_CSR_IRQ);

	int j = 0;
	alt_u8* u8_array = (alt_u8*) const_img;
	for(j = 0; j < 640*3; j++){
101002b8:	10800044 	addi	r2,r2,1
101002bc:	113ff71e 	bne	r2,r4,1010029c <main+0x7c>
		}else{
			u8_array[j] = 0xF0;
		}
	}

	alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
101002c0:	01840434 	movhi	r6,4112
101002c4:	0009883a 	mov	r4,zero
101002c8:	000b883a 	mov	r5,zero
101002cc:	31806704 	addi	r6,r6,412
101002d0:	000f883a 	mov	r7,zero
101002d4:	d8000015 	stw	zero,0(sp)
101002d8:	010086c0 	call	1010086c <alt_ic_isr_register>
	VGA_MODULE_0_IRQ, (void*) irq_vsync, 0, 0);

	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
101002dc:	0009883a 	mov	r4,zero
101002e0:	000b883a 	mov	r5,zero
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002e4:	040003f4 	movhi	r16,15

	alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
	VGA_MODULE_0_IRQ, (void*) irq_vsync, 0, 0);

	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
101002e8:	01008700 	call	10100870 <alt_ic_irq_enable>
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002ec:	84108fc4 	addi	r16,r16,16959
	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
	VGA_MODULE_0_IRQ);


	volatile int kk = 0;
101002f0:	d8000115 	stw	zero,4(sp)
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
101002f4:	d162a217 	ldw	r5,-30072(gp)
101002f8:	01040434 	movhi	r4,4112
101002fc:	21075b04 	addi	r4,r4,7532
10100300:	0100a940 	call	10100a94 <alt_printf>
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
10100304:	d8000115 	stw	zero,4(sp)
10100308:	d8800117 	ldw	r2,4(sp)
1010030c:	80bff916 	blt	r16,r2,101002f4 <main+0xd4>
10100310:	d8800117 	ldw	r2,4(sp)
10100314:	10800044 	addi	r2,r2,1
10100318:	d8800115 	stw	r2,4(sp)
1010031c:	003ffa06 	br	10100308 <main+0xe8>

10100320 <VGA_Display_changeVerticalPorch>:
#include "alt_types.h"
#include "system.h"
#include "sys/alt_irq.h"

void VGA_Display_changeVerticalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
10100320:	300c943a 	slli	r6,r6,16
10100324:	297fffcc 	andi	r5,r5,65535
10100328:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_V_REG, concatenated);
1010032c:	21400235 	stwio	r5,8(r4)
10100330:	f800283a 	ret

10100334 <VGA_Display_changeHorizontalPorch>:

}

void VGA_Display_changeHorizontalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
10100334:	300c943a 	slli	r6,r6,16
10100338:	297fffcc 	andi	r5,r5,65535
1010033c:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_H_REG, concatenated);
10100340:	21400335 	stwio	r5,12(r4)
10100344:	f800283a 	ret

10100348 <VGA_Display_changeScreenColor>:
}

void VGA_Display_changeScreenColor(alt_u32 BASE, alt_u32 color) {
	IOWR_32DIRECT(BASE, VGA_DISPLAY_COLOR_REG, color);
10100348:	21400035 	stwio	r5,0(r4)
1010034c:	f800283a 	ret

10100350 <VGA_Display_set_irq>:
}

void VGA_Display_set_irq(void (*irq_handler)(void*, alt_u32)) {
10100350:	defffd04 	addi	sp,sp,-12
10100354:	dfc00215 	stw	ra,8(sp)
10100358:	d9000115 	stw	r4,4(sp)

	if (irq_handler != NULL) {
1010035c:	20000926 	beq	r4,zero,10100384 <VGA_Display_set_irq+0x34>
		// Register the ISR for sync
		alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100360:	0009883a 	mov	r4,zero
10100364:	000b883a 	mov	r5,zero
10100368:	d8000015 	stw	zero,0(sp)
1010036c:	d9800104 	addi	r6,sp,4
10100370:	000f883a 	mov	r7,zero
10100374:	010086c0 	call	1010086c <alt_ic_isr_register>
				VGA_MODULE_0_IRQ, (void*) &irq_handler, 0, 0);

		// Enable the interrupts
		alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100378:	0009883a 	mov	r4,zero
1010037c:	000b883a 	mov	r5,zero
10100380:	01008700 	call	10100870 <alt_ic_irq_enable>
				VGA_MODULE_0_IRQ);
	}

}
10100384:	dfc00217 	ldw	ra,8(sp)
10100388:	dec00304 	addi	sp,sp,12
1010038c:	f800283a 	ret

10100390 <msgdma_transfer>:
#include "msgDMA.h"
#include <stdint-gcc.h>
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {
10100390:	defffa04 	addi	sp,sp,-24
10100394:	dd000415 	stw	r20,16(sp)
10100398:	dcc00315 	stw	r19,12(sp)
1010039c:	dc800215 	stw	r18,8(sp)
101003a0:	dc400115 	stw	r17,4(sp)
101003a4:	dc000015 	stw	r16,0(sp)
101003a8:	dfc00515 	stw	ra,20(sp)
101003ac:	2027883a 	mov	r19,r4
101003b0:	2829883a 	mov	r20,r5
101003b4:	3025883a 	mov	r18,r6

	unsigned int i = 0;
	unsigned int error_dma = 0;
101003b8:	0021883a 	mov	r16,zero
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {

	unsigned int i = 0;
101003bc:	0023883a 	mov	r17,zero
	unsigned int error_dma = 0;

	while (i < descriptor_number) {
101003c0:	8c80282e 	bgeu	r17,r18,10100464 <msgdma_transfer+0xd4>

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);
101003c4:	8804913a 	slli	r2,r17,4

	while (i < descriptor_number) {

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
101003c8:	9809883a 	mov	r4,r19
101003cc:	a08b883a 	add	r5,r20,r2
101003d0:	0101b0c0 	call	10101b0c <alt_msgdma_standard_descriptor_async_transfer>
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
101003d4:	00fff904 	movi	r3,-28
101003d8:	10c0041e 	bne	r2,r3,101003ec <msgdma_transfer+0x5c>
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003dc:	01040434 	movhi	r4,4112

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
			error_dma++;
101003e0:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003e4:	21078104 	addi	r4,r4,7684
101003e8:	00000506 	br	10100400 <msgdma_transfer+0x70>
		} else if (result == -ETIME) {
101003ec:	00fff084 	movi	r3,-62
101003f0:	10c0051e 	bne	r2,r3,10100408 <msgdma_transfer+0x78>
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003f4:	01040434 	movhi	r4,4112

		if ((result == -ENOSPC)) {
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
101003f8:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003fc:	21078c04 	addi	r4,r4,7728
10100400:	0100a940 	call	10100a94 <alt_printf>
10100404:	00000b06 	br	10100434 <msgdma_transfer+0xa4>
		} else if (result == -EPERM) {
10100408:	00ffffc4 	movi	r3,-1
1010040c:	10c0041e 	bne	r2,r3,10100420 <msgdma_transfer+0x90>
			error_dma++;
			alt_printf(
10100410:	01040434 	movhi	r4,4112
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
		} else if (result == -EPERM) {
			error_dma++;
10100414:	84000044 	addi	r16,r16,1
			alt_printf(
10100418:	21079804 	addi	r4,r4,7776
1010041c:	003ff806 	br	10100400 <msgdma_transfer+0x70>
					"msgdma_transfer dma_mm_interface_read: operation not permitted due to descriptor type conflict\n");
		} else {
			i++;
10100420:	8c400044 	addi	r17,r17,1
			alt_printf(
10100424:	01040434 	movhi	r4,4112
10100428:	2107b004 	addi	r4,r4,7872
1010042c:	880b883a 	mov	r5,r17
10100430:	0100a940 	call	10100a94 <alt_printf>
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
10100434:	00801904 	movi	r2,100
10100438:	80bfe11e 	bne	r16,r2,101003c0 <msgdma_transfer+0x30>
			alt_printf("Error DMA exceeded\n");
1010043c:	01040434 	movhi	r4,4112
10100440:	2107c304 	addi	r4,r4,7948
		}

	}

	//alt_printf("Transfer successful\n");
}
10100444:	dfc00517 	ldw	ra,20(sp)
10100448:	dd000417 	ldw	r20,16(sp)
1010044c:	dcc00317 	ldw	r19,12(sp)
10100450:	dc800217 	ldw	r18,8(sp)
10100454:	dc400117 	ldw	r17,4(sp)
10100458:	dc000017 	ldw	r16,0(sp)
1010045c:	dec00604 	addi	sp,sp,24
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
			alt_printf("Error DMA exceeded\n");
10100460:	0100a941 	jmpi	10100a94 <alt_printf>
		}

	}

	//alt_printf("Transfer successful\n");
}
10100464:	dfc00517 	ldw	ra,20(sp)
10100468:	dd000417 	ldw	r20,16(sp)
1010046c:	dcc00317 	ldw	r19,12(sp)
10100470:	dc800217 	ldw	r18,8(sp)
10100474:	dc400117 	ldw	r17,4(sp)
10100478:	dc000017 	ldw	r16,0(sp)
1010047c:	dec00604 	addi	sp,sp,24
10100480:	f800283a 	ret

10100484 <msgdma_create_mm_to_mm_descriptor_list>:

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100484:	defff204 	addi	sp,sp,-56
10100488:	dc000415 	stw	r16,16(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
1010048c:	d8800e17 	ldw	r2,56(sp)
uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
10100490:	24001217 	ldw	r16,72(r4)
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100494:	dd800a15 	stw	r22,40(sp)
10100498:	dd400915 	stw	r21,36(sp)
1010049c:	202d883a 	mov	r22,r4
101004a0:	282b883a 	mov	r21,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101004a4:	113fffc4 	addi	r4,r2,-1
101004a8:	800b883a 	mov	r5,r16
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
101004ac:	df000c15 	stw	fp,48(sp)
101004b0:	dcc00715 	stw	r19,28(sp)
101004b4:	dfc00d15 	stw	ra,52(sp)
101004b8:	ddc00b15 	stw	r23,44(sp)
101004bc:	dd000815 	stw	r20,32(sp)
101004c0:	dc800615 	stw	r18,24(sp)
101004c4:	dc400515 	stw	r17,20(sp)
101004c8:	3027883a 	mov	r19,r6
101004cc:	d9c00315 	stw	r7,12(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101004d0:	01008340 	call	10100834 <__udivsi3>
101004d4:	1039883a 	mov	fp,r2
101004d8:	10800044 	addi	r2,r2,1
101004dc:	d8800215 	stw	r2,8(sp)

	if (msgdma_desc == NULL) {
101004e0:	a800051e 	bne	r21,zero,101004f8 <msgdma_create_mm_to_mm_descriptor_list+0x74>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
101004e4:	01040434 	movhi	r4,4112
101004e8:	2107c804 	addi	r4,r4,7968
101004ec:	0100a940 	call	10100a94 <alt_printf>
		return 0;
101004f0:	0005883a 	mov	r2,zero
101004f4:	00002f06 	br	101005b4 <msgdma_create_mm_to_mm_descriptor_list+0x130>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
101004f8:	d9800217 	ldw	r6,8(sp)
101004fc:	01040434 	movhi	r4,4112
10100500:	2107d504 	addi	r4,r4,8020
10100504:	800b883a 	mov	r5,r16
10100508:	0100a940 	call	10100a94 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;
1010050c:	dc800317 	ldw	r18,12(sp)
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100510:	9823883a 	mov	r17,r19
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100514:	0029883a 	mov	r20,zero
10100518:	a02e913a 	slli	r23,r20,4
1010051c:	a7001126 	beq	r20,fp,10100564 <msgdma_create_mm_to_mm_descriptor_list+0xe0>
		alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100520:	01040434 	movhi	r4,4112
10100524:	a00b883a 	mov	r5,r20
10100528:	880d883a 	mov	r6,r17
1010052c:	900f883a 	mov	r7,r18
10100530:	2107e204 	addi	r4,r4,8072
10100534:	0100a940 	call	10100a94 <alt_printf>
				_address_dst_descriptor);

		alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma,
10100538:	880d883a 	mov	r6,r17
1010053c:	900f883a 	mov	r7,r18
10100540:	dc000015 	stw	r16,0(sp)
10100544:	d8000115 	stw	zero,4(sp)
10100548:	b009883a 	mov	r4,r22
1010054c:	adcb883a 	add	r5,r21,r23
10100550:	010124c0 	call	1010124c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor,
				(uint32_t *) _address_dst_descriptor, max_descriptor_size, 0);
		_address_dst_descriptor += max_descriptor_size;
10100554:	9425883a 	add	r18,r18,r16
		_address_src_descriptor += max_descriptor_size;
10100558:	8c23883a 	add	r17,r17,r16

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010055c:	a5000044 	addi	r20,r20,1
10100560:	003fed06 	br	10100518 <msgdma_create_mm_to_mm_descriptor_list+0x94>
10100564:	a421383a 	mul	r16,r20,r16
10100568:	d8800317 	ldw	r2,12(sp)
		_address_dst_descriptor += max_descriptor_size;
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
1010056c:	01040434 	movhi	r4,4112
10100570:	9c27883a 	add	r19,r19,r16
10100574:	1425883a 	add	r18,r2,r16
10100578:	2107e204 	addi	r4,r4,8072
1010057c:	a00b883a 	mov	r5,r20
10100580:	980d883a 	mov	r6,r19
10100584:	900f883a 	mov	r7,r18
10100588:	0100a940 	call	10100a94 <alt_printf>
			_address_dst_descriptor);
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma, msgdma_desc + i,
1010058c:	d8800e17 	ldw	r2,56(sp)
10100590:	d8000115 	stw	zero,4(sp)
10100594:	b009883a 	mov	r4,r22
10100598:	1421c83a 	sub	r16,r2,r16
1010059c:	dc000015 	stw	r16,0(sp)
101005a0:	adcb883a 	add	r5,r21,r23
101005a4:	980d883a 	mov	r6,r19
101005a8:	900f883a 	mov	r7,r18
101005ac:	010124c0 	call	1010124c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
			(uint32_t *) _address_src_descriptor,
			(uint32_t *) _address_dst_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101005b0:	d8800217 	ldw	r2,8(sp)
}
101005b4:	dfc00d17 	ldw	ra,52(sp)
101005b8:	df000c17 	ldw	fp,48(sp)
101005bc:	ddc00b17 	ldw	r23,44(sp)
101005c0:	dd800a17 	ldw	r22,40(sp)
101005c4:	dd400917 	ldw	r21,36(sp)
101005c8:	dd000817 	ldw	r20,32(sp)
101005cc:	dcc00717 	ldw	r19,28(sp)
101005d0:	dc800617 	ldw	r18,24(sp)
101005d4:	dc400517 	ldw	r17,20(sp)
101005d8:	dc000417 	ldw	r16,16(sp)
101005dc:	dec00e04 	addi	sp,sp,56
101005e0:	f800283a 	ret

101005e4 <msgdma_create_mm_to_st_descriptor_list>:



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005e4:	defff404 	addi	sp,sp,-48
101005e8:	dc000215 	stw	r16,8(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
101005ec:	24001217 	ldw	r16,72(r4)



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005f0:	dd400715 	stw	r21,28(sp)
101005f4:	dd000615 	stw	r20,24(sp)
101005f8:	202b883a 	mov	r21,r4
101005fc:	2829883a 	mov	r20,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100600:	393fffc4 	addi	r4,r7,-1
10100604:	800b883a 	mov	r5,r16



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
10100608:	df000a15 	stw	fp,40(sp)
1010060c:	dd800815 	stw	r22,32(sp)
10100610:	dcc00515 	stw	r19,20(sp)
10100614:	dfc00b15 	stw	ra,44(sp)
10100618:	ddc00915 	stw	r23,36(sp)
1010061c:	dc800415 	stw	r18,16(sp)
10100620:	dc400315 	stw	r17,12(sp)
10100624:	3027883a 	mov	r19,r6
10100628:	382d883a 	mov	r22,r7

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
1010062c:	01008340 	call	10100834 <__udivsi3>
10100630:	1039883a 	mov	fp,r2
10100634:	10800044 	addi	r2,r2,1
10100638:	d8800115 	stw	r2,4(sp)

	if (msgdma_desc == NULL) {
1010063c:	a000051e 	bne	r20,zero,10100654 <msgdma_create_mm_to_st_descriptor_list+0x70>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
10100640:	01040434 	movhi	r4,4112
10100644:	2107c804 	addi	r4,r4,7968
10100648:	0100a940 	call	10100a94 <alt_printf>
		return 0;
1010064c:	0005883a 	mov	r2,zero
10100650:	00002506 	br	101006e8 <msgdma_create_mm_to_st_descriptor_list+0x104>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
10100654:	d9800117 	ldw	r6,4(sp)
10100658:	01040434 	movhi	r4,4112
1010065c:	2107d504 	addi	r4,r4,8020
10100660:	800b883a 	mov	r5,r16
10100664:	0100a940 	call	10100a94 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100668:	9825883a 	mov	r18,r19

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010066c:	0023883a 	mov	r17,zero
10100670:	882e913a 	slli	r23,r17,4
10100674:	8f000e26 	beq	r17,fp,101006b0 <msgdma_create_mm_to_st_descriptor_list+0xcc>
		alt_printf("i=%d, src=0x%x\n", i, _address_src_descriptor);
10100678:	01040434 	movhi	r4,4112
1010067c:	880b883a 	mov	r5,r17
10100680:	900d883a 	mov	r6,r18
10100684:	2107e904 	addi	r4,r4,8100
10100688:	0100a940 	call	10100a94 <alt_printf>

		alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma,
1010068c:	900d883a 	mov	r6,r18
10100690:	d8000015 	stw	zero,0(sp)
10100694:	a809883a 	mov	r4,r21
10100698:	a5cb883a 	add	r5,r20,r23
1010069c:	800f883a 	mov	r7,r16
101006a0:	01012140 	call	10101214 <alt_msgdma_construct_standard_mm_to_st_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;
101006a4:	9425883a 	add	r18,r18,r16
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
101006a8:	8c400044 	addi	r17,r17,1
101006ac:	003ff006 	br	10100670 <msgdma_create_mm_to_st_descriptor_list+0x8c>
101006b0:	8c21383a 	mul	r16,r17,r16
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor);
101006b4:	01040434 	movhi	r4,4112
101006b8:	2107e204 	addi	r4,r4,8072
101006bc:	9c27883a 	add	r19,r19,r16
101006c0:	880b883a 	mov	r5,r17
101006c4:	980d883a 	mov	r6,r19
101006c8:	0100a940 	call	10100a94 <alt_printf>
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma, msgdma_desc + i,
101006cc:	a809883a 	mov	r4,r21
101006d0:	d8000015 	stw	zero,0(sp)
101006d4:	a5cb883a 	add	r5,r20,r23
101006d8:	980d883a 	mov	r6,r19
101006dc:	b40fc83a 	sub	r7,r22,r16
101006e0:	01012140 	call	10101214 <alt_msgdma_construct_standard_mm_to_st_descriptor>
			(uint32_t *) _address_src_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101006e4:	d8800117 	ldw	r2,4(sp)
}
101006e8:	dfc00b17 	ldw	ra,44(sp)
101006ec:	df000a17 	ldw	fp,40(sp)
101006f0:	ddc00917 	ldw	r23,36(sp)
101006f4:	dd800817 	ldw	r22,32(sp)
101006f8:	dd400717 	ldw	r21,28(sp)
101006fc:	dd000617 	ldw	r20,24(sp)
10100700:	dcc00517 	ldw	r19,20(sp)
10100704:	dc800417 	ldw	r18,16(sp)
10100708:	dc400317 	ldw	r17,12(sp)
1010070c:	dc000217 	ldw	r16,8(sp)
10100710:	dec00c04 	addi	sp,sp,48
10100714:	f800283a 	ret

10100718 <udivmodsi4>:
10100718:	2900182e 	bgeu	r5,r4,1010077c <udivmodsi4+0x64>
1010071c:	28001716 	blt	r5,zero,1010077c <udivmodsi4+0x64>
10100720:	00800804 	movi	r2,32
10100724:	00c00044 	movi	r3,1
10100728:	00000206 	br	10100734 <udivmodsi4+0x1c>
1010072c:	10001126 	beq	r2,zero,10100774 <udivmodsi4+0x5c>
10100730:	28000516 	blt	r5,zero,10100748 <udivmodsi4+0x30>
10100734:	294b883a 	add	r5,r5,r5
10100738:	10bfffc4 	addi	r2,r2,-1
1010073c:	18c7883a 	add	r3,r3,r3
10100740:	293ffa36 	bltu	r5,r4,1010072c <udivmodsi4+0x14>
10100744:	18000b26 	beq	r3,zero,10100774 <udivmodsi4+0x5c>
10100748:	0005883a 	mov	r2,zero
1010074c:	21400236 	bltu	r4,r5,10100758 <udivmodsi4+0x40>
10100750:	2149c83a 	sub	r4,r4,r5
10100754:	10c4b03a 	or	r2,r2,r3
10100758:	1806d07a 	srli	r3,r3,1
1010075c:	280ad07a 	srli	r5,r5,1
10100760:	183ffa1e 	bne	r3,zero,1010074c <udivmodsi4+0x34>
10100764:	3000011e 	bne	r6,zero,1010076c <udivmodsi4+0x54>
10100768:	f800283a 	ret
1010076c:	2005883a 	mov	r2,r4
10100770:	f800283a 	ret
10100774:	0005883a 	mov	r2,zero
10100778:	003ffa06 	br	10100764 <udivmodsi4+0x4c>
1010077c:	00c00044 	movi	r3,1
10100780:	003ff106 	br	10100748 <udivmodsi4+0x30>

10100784 <__divsi3>:
10100784:	defffe04 	addi	sp,sp,-8
10100788:	dfc00115 	stw	ra,4(sp)
1010078c:	dc000015 	stw	r16,0(sp)
10100790:	20000b16 	blt	r4,zero,101007c0 <__divsi3+0x3c>
10100794:	0021883a 	mov	r16,zero
10100798:	28000c16 	blt	r5,zero,101007cc <__divsi3+0x48>
1010079c:	000d883a 	mov	r6,zero
101007a0:	01007180 	call	10100718 <udivmodsi4>
101007a4:	0407c83a 	sub	r3,zero,r16
101007a8:	1884f03a 	xor	r2,r3,r2
101007ac:	1405883a 	add	r2,r2,r16
101007b0:	dfc00117 	ldw	ra,4(sp)
101007b4:	dc000017 	ldw	r16,0(sp)
101007b8:	dec00204 	addi	sp,sp,8
101007bc:	f800283a 	ret
101007c0:	0109c83a 	sub	r4,zero,r4
101007c4:	04000044 	movi	r16,1
101007c8:	283ff40e 	bge	r5,zero,1010079c <__divsi3+0x18>
101007cc:	014bc83a 	sub	r5,zero,r5
101007d0:	8400005c 	xori	r16,r16,1
101007d4:	003ff106 	br	1010079c <__divsi3+0x18>

101007d8 <__modsi3>:
101007d8:	defffd04 	addi	sp,sp,-12
101007dc:	dfc00215 	stw	ra,8(sp)
101007e0:	dc400115 	stw	r17,4(sp)
101007e4:	dc000015 	stw	r16,0(sp)
101007e8:	20000c16 	blt	r4,zero,1010081c <__modsi3+0x44>
101007ec:	0023883a 	mov	r17,zero
101007f0:	0021883a 	mov	r16,zero
101007f4:	28000d16 	blt	r5,zero,1010082c <__modsi3+0x54>
101007f8:	01800044 	movi	r6,1
101007fc:	01007180 	call	10100718 <udivmodsi4>
10100800:	1404f03a 	xor	r2,r2,r16
10100804:	8885883a 	add	r2,r17,r2
10100808:	dfc00217 	ldw	ra,8(sp)
1010080c:	dc400117 	ldw	r17,4(sp)
10100810:	dc000017 	ldw	r16,0(sp)
10100814:	dec00304 	addi	sp,sp,12
10100818:	f800283a 	ret
1010081c:	0109c83a 	sub	r4,zero,r4
10100820:	04400044 	movi	r17,1
10100824:	043fffc4 	movi	r16,-1
10100828:	283ff30e 	bge	r5,zero,101007f8 <__modsi3+0x20>
1010082c:	014bc83a 	sub	r5,zero,r5
10100830:	003ff106 	br	101007f8 <__modsi3+0x20>

10100834 <__udivsi3>:
10100834:	000d883a 	mov	r6,zero
10100838:	01007181 	jmpi	10100718 <udivmodsi4>

1010083c <__umodsi3>:
1010083c:	01800044 	movi	r6,1
10100840:	01007181 	jmpi	10100718 <udivmodsi4>

10100844 <memcpy>:
10100844:	2005883a 	mov	r2,r4
10100848:	0007883a 	mov	r3,zero
1010084c:	19800626 	beq	r3,r6,10100868 <memcpy+0x24>
10100850:	28c9883a 	add	r4,r5,r3
10100854:	21c00003 	ldbu	r7,0(r4)
10100858:	10c9883a 	add	r4,r2,r3
1010085c:	18c00044 	addi	r3,r3,1
10100860:	21c00005 	stb	r7,0(r4)
10100864:	003ff906 	br	1010084c <memcpy+0x8>
10100868:	f800283a 	ret

1010086c <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
1010086c:	01009081 	jmpi	10100908 <alt_iic_isr_register>

10100870 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100870:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100874:	00bfff84 	movi	r2,-2
10100878:	3084703a 	and	r2,r6,r2
1010087c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
10100880:	00840434 	movhi	r2,4112
10100884:	108d9e04 	addi	r2,r2,13944
10100888:	01000044 	movi	r4,1
1010088c:	10c00017 	ldw	r3,0(r2)
10100890:	214a983a 	sll	r5,r4,r5
10100894:	28cab03a 	or	r5,r5,r3
10100898:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
1010089c:	10800017 	ldw	r2,0(r2)
101008a0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101008a4:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
101008a8:	0005883a 	mov	r2,zero
101008ac:	f800283a 	ret

101008b0 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101008b0:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101008b4:	00bfff84 	movi	r2,-2
101008b8:	3084703a 	and	r2,r6,r2
101008bc:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
101008c0:	00840434 	movhi	r2,4112
101008c4:	108d9e04 	addi	r2,r2,13944
101008c8:	013fff84 	movi	r4,-2
101008cc:	10c00017 	ldw	r3,0(r2)
101008d0:	214a183a 	rol	r5,r4,r5
101008d4:	28ca703a 	and	r5,r5,r3
101008d8:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
101008dc:	10800017 	ldw	r2,0(r2)
101008e0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101008e4:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
101008e8:	0005883a 	mov	r2,zero
101008ec:	f800283a 	ret

101008f0 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
101008f0:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
101008f4:	00c00044 	movi	r3,1
101008f8:	194a983a 	sll	r5,r3,r5
101008fc:	1144703a 	and	r2,r2,r5
}
10100900:	1004c03a 	cmpne	r2,r2,zero
10100904:	f800283a 	ret

10100908 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
10100908:	00c007c4 	movi	r3,31
1010090c:	19401616 	blt	r3,r5,10100968 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
10100910:	defffe04 	addi	sp,sp,-8
10100914:	dfc00115 	stw	ra,4(sp)
10100918:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
1010091c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100920:	00ffff84 	movi	r3,-2
10100924:	80c6703a 	and	r3,r16,r3
10100928:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
1010092c:	280490fa 	slli	r2,r5,3
10100930:	00c40434 	movhi	r3,4112
10100934:	18cdc004 	addi	r3,r3,14080
10100938:	1891883a 	add	r8,r3,r2
1010093c:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
10100940:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
10100944:	30000226 	beq	r6,zero,10100950 <alt_iic_isr_register+0x48>
10100948:	01008700 	call	10100870 <alt_ic_irq_enable>
1010094c:	00000106 	br	10100954 <alt_iic_isr_register+0x4c>
10100950:	01008b00 	call	101008b0 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100954:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
10100958:	dfc00117 	ldw	ra,4(sp)
1010095c:	dc000017 	ldw	r16,0(sp)
10100960:	dec00204 	addi	sp,sp,8
10100964:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
10100968:	00bffa84 	movi	r2,-22
1010096c:	f800283a 	ret

10100970 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
10100970:	deffff04 	addi	sp,sp,-4
10100974:	01040434 	movhi	r4,4112
10100978:	01440434 	movhi	r5,4112
1010097c:	dfc00015 	stw	ra,0(sp)
10100980:	21086104 	addi	r4,r4,8580
10100984:	294afe04 	addi	r5,r5,11256

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100988:	2140061e 	bne	r4,r5,101009a4 <alt_load+0x34>
1010098c:	01040434 	movhi	r4,4112
10100990:	01440434 	movhi	r5,4112
10100994:	21000804 	addi	r4,r4,32
10100998:	29400804 	addi	r5,r5,32
1010099c:	2140141e 	bne	r4,r5,101009f0 <alt_load+0x80>
101009a0:	00000d06 	br	101009d8 <alt_load+0x68>
101009a4:	00c40434 	movhi	r3,4112
101009a8:	18cafe04 	addi	r3,r3,11256
101009ac:	00bfff04 	movi	r2,-4
101009b0:	1907c83a 	sub	r3,r3,r4
101009b4:	1886703a 	and	r3,r3,r2
101009b8:	0005883a 	mov	r2,zero
  {
    while( to != end )
101009bc:	10fff326 	beq	r2,r3,1010098c <alt_load+0x1c>
101009c0:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
101009c4:	39c00017 	ldw	r7,0(r7)
101009c8:	110d883a 	add	r6,r2,r4
101009cc:	10800104 	addi	r2,r2,4
101009d0:	31c00015 	stw	r7,0(r6)
101009d4:	003ff906 	br	101009bc <alt_load+0x4c>
101009d8:	01040434 	movhi	r4,4112
101009dc:	01440434 	movhi	r5,4112
101009e0:	21075204 	addi	r4,r4,7496
101009e4:	29475204 	addi	r5,r5,7496

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
101009e8:	2140121e 	bne	r4,r5,10100a34 <alt_load+0xc4>
101009ec:	00000d06 	br	10100a24 <alt_load+0xb4>
101009f0:	00c40434 	movhi	r3,4112
101009f4:	18c05404 	addi	r3,r3,336
101009f8:	00bfff04 	movi	r2,-4
101009fc:	1907c83a 	sub	r3,r3,r4
10100a00:	1886703a 	and	r3,r3,r2
10100a04:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100a08:	10fff326 	beq	r2,r3,101009d8 <alt_load+0x68>
10100a0c:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100a10:	39c00017 	ldw	r7,0(r7)
10100a14:	110d883a 	add	r6,r2,r4
10100a18:	10800104 	addi	r2,r2,4
10100a1c:	31c00015 	stw	r7,0(r6)
10100a20:	003ff906 	br	10100a08 <alt_load+0x98>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10100a24:	0101bac0 	call	10101bac <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10100a28:	dfc00017 	ldw	ra,0(sp)
10100a2c:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
10100a30:	0101cb01 	jmpi	10101cb0 <alt_icache_flush_all>
10100a34:	00c40434 	movhi	r3,4112
10100a38:	18c86104 	addi	r3,r3,8580
10100a3c:	00bfff04 	movi	r2,-4
10100a40:	1907c83a 	sub	r3,r3,r4
10100a44:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100a48:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100a4c:	10fff526 	beq	r2,r3,10100a24 <alt_load+0xb4>
10100a50:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100a54:	39c00017 	ldw	r7,0(r7)
10100a58:	110d883a 	add	r6,r2,r4
10100a5c:	10800104 	addi	r2,r2,4
10100a60:	31c00015 	stw	r7,0(r6)
10100a64:	003ff906 	br	10100a4c <alt_load+0xdc>

10100a68 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a68:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a6c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a70:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a74:	0100c800 	call	10100c80 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10100a78:	0100ca00 	call	10100ca0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a7c:	d122a817 	ldw	r4,-30048(gp)
10100a80:	d162a717 	ldw	r5,-30052(gp)
10100a84:	d1a2a617 	ldw	r6,-30056(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
10100a88:	dfc00017 	ldw	ra,0(sp)
10100a8c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a90:	01002201 	jmpi	10100220 <main>

10100a94 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100a94:	defff204 	addi	sp,sp,-56
10100a98:	dfc00a15 	stw	ra,40(sp)
10100a9c:	df000915 	stw	fp,36(sp)
10100aa0:	ddc00815 	stw	r23,32(sp)
10100aa4:	dd800715 	stw	r22,28(sp)
10100aa8:	dd400615 	stw	r21,24(sp)
10100aac:	dd000515 	stw	r20,20(sp)
10100ab0:	dcc00415 	stw	r19,16(sp)
10100ab4:	dc800315 	stw	r18,12(sp)
10100ab8:	dc400215 	stw	r17,8(sp)
10100abc:	dc000115 	stw	r16,4(sp)
10100ac0:	d9400b15 	stw	r5,44(sp)
10100ac4:	d9800c15 	stw	r6,48(sp)
10100ac8:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100acc:	04000944 	movi	r16,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100ad0:	2005883a 	mov	r2,r4
	va_list args;
	va_start(args, fmt);
10100ad4:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
10100ad8:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
10100adc:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100ae0:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100ae4:	11000007 	ldb	r4,0(r2)
10100ae8:	20003926 	beq	r4,zero,10100bd0 <alt_printf+0x13c>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100aec:	24000226 	beq	r4,r16,10100af8 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100af0:	14400044 	addi	r17,r2,1
10100af4:	00001106 	br	10100b3c <alt_printf+0xa8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
10100af8:	14400084 	addi	r17,r2,2
10100afc:	10800047 	ldb	r2,1(r2)
10100b00:	10003326 	beq	r2,zero,10100bd0 <alt_printf+0x13c>
            {
                if (c == '%')
10100b04:	1400021e 	bne	r2,r16,10100b10 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
10100b08:	8009883a 	mov	r4,r16
10100b0c:	00000b06 	br	10100b3c <alt_printf+0xa8>
                } 
                else if (c == 'c')
10100b10:	1480051e 	bne	r2,r18,10100b28 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
10100b14:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100b18:	ad800104 	addi	r22,r21,4
10100b1c:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
10100b20:	0100c000 	call	10100c00 <alt_putchar>
10100b24:	00002806 	br	10100bc8 <alt_printf+0x134>
                }
                else if (c == 'x')
10100b28:	14c01f1e 	bne	r2,r19,10100ba8 <alt_printf+0x114>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
10100b2c:	adc00017 	ldw	r23,0(r21)
10100b30:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
10100b34:	b800031e 	bne	r23,zero,10100b44 <alt_printf+0xb0>
                    {
                        alt_putchar('0');
10100b38:	01000c04 	movi	r4,48
10100b3c:	0100c000 	call	10100c00 <alt_putchar>
                        continue;
10100b40:	00002106 	br	10100bc8 <alt_printf+0x134>
10100b44:	05800704 	movi	r22,28
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
10100b48:	00c003c4 	movi	r3,15
10100b4c:	1d84983a 	sll	r2,r3,r22
10100b50:	15c4703a 	and	r2,r2,r23
10100b54:	1000021e 	bne	r2,zero,10100b60 <alt_printf+0xcc>
                        digit_shift -= 4;
10100b58:	b5bfff04 	addi	r22,r22,-4
10100b5c:	003ffb06 	br	10100b4c <alt_printf+0xb8>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b60:	070003c4 	movi	fp,15
                        if (digit <= 9)
10100b64:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b68:	b0001716 	blt	r22,zero,10100bc8 <alt_printf+0x134>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b6c:	e584983a 	sll	r2,fp,r22
10100b70:	15c4703a 	and	r2,r2,r23
10100b74:	1584d83a 	srl	r2,r2,r22
                        if (digit <= 9)
10100b78:	18800236 	bltu	r3,r2,10100b84 <alt_printf+0xf0>
                            c = '0' + digit;
10100b7c:	11000c04 	addi	r4,r2,48
10100b80:	00000106 	br	10100b88 <alt_printf+0xf4>
                        else
                            c = 'a' + digit - 10;
10100b84:	110015c4 	addi	r4,r2,87
                        alt_putchar(c);
10100b88:	21003fcc 	andi	r4,r4,255
10100b8c:	2100201c 	xori	r4,r4,128
10100b90:	213fe004 	addi	r4,r4,-128
10100b94:	d8c00015 	stw	r3,0(sp)
10100b98:	0100c000 	call	10100c00 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b9c:	b5bfff04 	addi	r22,r22,-4
10100ba0:	d8c00017 	ldw	r3,0(sp)
10100ba4:	003ff006 	br	10100b68 <alt_printf+0xd4>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100ba8:	1500071e 	bne	r2,r20,10100bc8 <alt_printf+0x134>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
10100bac:	ad800017 	ldw	r22,0(r21)
10100bb0:	ad400104 	addi	r21,r21,4

                    while(*s)
10100bb4:	b1000007 	ldb	r4,0(r22)
10100bb8:	20000326 	beq	r4,zero,10100bc8 <alt_printf+0x134>
                      alt_putchar(*s++);
10100bbc:	b5800044 	addi	r22,r22,1
10100bc0:	0100c000 	call	10100c00 <alt_putchar>
10100bc4:	003ffb06 	br	10100bb4 <alt_printf+0x120>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100bc8:	8805883a 	mov	r2,r17
10100bcc:	003fc506 	br	10100ae4 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
10100bd0:	dfc00a17 	ldw	ra,40(sp)
10100bd4:	df000917 	ldw	fp,36(sp)
10100bd8:	ddc00817 	ldw	r23,32(sp)
10100bdc:	dd800717 	ldw	r22,28(sp)
10100be0:	dd400617 	ldw	r21,24(sp)
10100be4:	dd000517 	ldw	r20,20(sp)
10100be8:	dcc00417 	ldw	r19,16(sp)
10100bec:	dc800317 	ldw	r18,12(sp)
10100bf0:	dc400217 	ldw	r17,8(sp)
10100bf4:	dc000117 	ldw	r16,4(sp)
10100bf8:	dec00e04 	addi	sp,sp,56
10100bfc:	f800283a 	ret

10100c00 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c00:	defffd04 	addi	sp,sp,-12
10100c04:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
10100c08:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c0c:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100c10:	01040434 	movhi	r4,4112
10100c14:	210afa04 	addi	r4,r4,11240
10100c18:	d80b883a 	mov	r5,sp
10100c1c:	01800044 	movi	r6,1
10100c20:	000f883a 	mov	r7,zero
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c24:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100c28:	0100cb40 	call	10100cb4 <altera_avalon_jtag_uart_write>
10100c2c:	00ffffc4 	movi	r3,-1
10100c30:	10c00126 	beq	r2,r3,10100c38 <alt_putchar+0x38>
        return -1;
    }
    return c;
10100c34:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
10100c38:	dfc00217 	ldw	ra,8(sp)
10100c3c:	dc000117 	ldw	r16,4(sp)
10100c40:	dec00304 	addi	sp,sp,12
10100c44:	f800283a 	ret

10100c48 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
10100c48:	defffe04 	addi	sp,sp,-8
10100c4c:	dc000015 	stw	r16,0(sp)
10100c50:	dfc00115 	stw	ra,4(sp)
10100c54:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c58:	0101d2c0 	call	10101d2c <strlen>
10100c5c:	01040434 	movhi	r4,4112
10100c60:	210afa04 	addi	r4,r4,11240
10100c64:	800b883a 	mov	r5,r16
10100c68:	100d883a 	mov	r6,r2
10100c6c:	000f883a 	mov	r7,zero
#else
    return fputs(str, stdout);
#endif
#endif
}
10100c70:	dfc00117 	ldw	ra,4(sp)
10100c74:	dc000017 	ldw	r16,0(sp)
10100c78:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c7c:	0100cb41 	jmpi	10100cb4 <altera_avalon_jtag_uart_write>

10100c80 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10100c80:	deffff04 	addi	sp,sp,-4
10100c84:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
10100c88:	0101cbc0 	call	10101cbc <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10100c8c:	00800044 	movi	r2,1
10100c90:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10100c94:	dfc00017 	ldw	ra,0(sp)
10100c98:	dec00104 	addi	sp,sp,4
10100c9c:	f800283a 	ret

10100ca0 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_MSGDMA_INIT ( MSGDMA_0, msgdma_0);
10100ca0:	01040434 	movhi	r4,4112
10100ca4:	210ae104 	addi	r4,r4,11140
10100ca8:	21400717 	ldw	r5,28(r4)
10100cac:	21800817 	ldw	r6,32(r4)
10100cb0:	0101a181 	jmpi	10101a18 <alt_msgdma_init>

10100cb4 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10100cb4:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10100cb8:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
10100cbc:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100cc0:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10100cc4:	2980072e 	bgeu	r5,r6,10100ce4 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100cc8:	38c00037 	ldwio	r3,0(r7)
10100ccc:	18ffffec 	andhi	r3,r3,65535
10100cd0:	183ffc26 	beq	r3,zero,10100cc4 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10100cd4:	28c00007 	ldb	r3,0(r5)
10100cd8:	20c00035 	stwio	r3,0(r4)
10100cdc:	29400044 	addi	r5,r5,1
10100ce0:	003ff806 	br	10100cc4 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
10100ce4:	f800283a 	ret

10100ce8 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100ce8:	defffd04 	addi	sp,sp,-12
10100cec:	dc000015 	stw	r16,0(sp)
10100cf0:	dfc00215 	stw	ra,8(sp)
10100cf4:	dc400115 	stw	r17,4(sp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100cf8:	20801783 	ldbu	r2,94(r4)
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100cfc:	2021883a 	mov	r16,r4
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100d00:	10000926 	beq	r2,zero,10100d28 <alt_msgdma_irq+0x40>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100d04:	20c00617 	ldw	r3,24(r4)
10100d08:	19000037 	ldwio	r4,0(r3)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
10100d0c:	00bffdc4 	movi	r2,-9
10100d10:	2084703a 	and	r2,r4,r2
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100d14:	18800035 	stwio	r2,0(r3)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
10100d18:	80800617 	ldw	r2,24(r16)
10100d1c:	00c00044 	movi	r3,1
10100d20:	10c00435 	stwio	r3,16(r2)
10100d24:	00000906 	br	10100d4c <alt_msgdma_irq+0x64>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10100d28:	20800317 	ldw	r2,12(r4)
10100d2c:	10800104 	addi	r2,r2,4
10100d30:	11000037 	ldwio	r4,0(r2)
10100d34:	00fffbc4 	movi	r3,-17
10100d38:	20c6703a 	and	r3,r4,r3
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d3c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
10100d40:	80800317 	ldw	r2,12(r16)
10100d44:	00c08004 	movi	r3,512
10100d48:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
10100d4c:	80c00b17 	ldw	r3,44(r16)
10100d50:	18000726 	beq	r3,zero,10100d70 <alt_msgdma_irq+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100d54:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100d58:	00bfff84 	movi	r2,-2
10100d5c:	8884703a 	and	r2,r17,r2
10100d60:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        dev->callback (dev->callback_context);
10100d64:	81000c17 	ldw	r4,48(r16)
10100d68:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100d6c:	8801703a 	wrctl	status,r17
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
10100d70:	80801783 	ldbu	r2,94(r16)
10100d74:	10000526 	beq	r2,zero,10100d8c <alt_msgdma_irq+0xa4>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100d78:	80c00617 	ldw	r3,24(r16)
10100d7c:	18800037 	ldwio	r2,0(r3)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10100d80:	10800214 	ori	r2,r2,8
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100d84:	18800035 	stwio	r2,0(r3)
10100d88:	00000506 	br	10100da0 <alt_msgdma_irq+0xb8>
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
10100d8c:	80800317 	ldw	r2,12(r16)
10100d90:	10800104 	addi	r2,r2,4
10100d94:	10c00037 	ldwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
10100d98:	18c00414 	ori	r3,r3,16
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d9c:	10c00035 	stwio	r3,0(r2)
    }

    return;
}
10100da0:	dfc00217 	ldw	ra,8(sp)
10100da4:	dc400117 	ldw	r17,4(sp)
10100da8:	dc000017 	ldw	r16,0(sp)
10100dac:	dec00304 	addi	sp,sp,12
10100db0:	f800283a 	ret

10100db4 <alt_msgdma_write_extended_descriptor>:
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100db4:	20800037 	ldwio	r2,0(r4)
10100db8:	1080010c 	andi	r2,r2,4
10100dbc:	1000151e 	bne	r2,zero,10100e14 <alt_msgdma_write_extended_descriptor+0x60>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
10100dc0:	30c00017 	ldw	r3,0(r6)
10100dc4:	28c00035 	stwio	r3,0(r5)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
10100dc8:	30c00117 	ldw	r3,4(r6)
10100dcc:	28c00135 	stwio	r3,4(r5)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
10100dd0:	30c00217 	ldw	r3,8(r6)
10100dd4:	28c00235 	stwio	r3,8(r5)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
10100dd8:	30c0030b 	ldhu	r3,12(r6)
10100ddc:	28c0032d 	sthio	r3,12(r5)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
10100de0:	30c00383 	ldbu	r3,14(r6)
10100de4:	28c003a5 	stbio	r3,14(r5)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
10100de8:	30c003c3 	ldbu	r3,15(r6)
10100dec:	28c003e5 	stbio	r3,15(r5)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
10100df0:	30c0040b 	ldhu	r3,16(r6)
10100df4:	28c0042d 	sthio	r3,16(r5)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
10100df8:	30c0048b 	ldhu	r3,18(r6)
10100dfc:	28c004ad 	sthio	r3,18(r5)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
10100e00:	28000535 	stwio	zero,20(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
10100e04:	28000635 	stwio	zero,24(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
10100e08:	30c00717 	ldw	r3,28(r6)
10100e0c:	28c00735 	stwio	r3,28(r5)
		descriptor_base, 
    	descriptor->control);
    return 0;
10100e10:	f800283a 	ret
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
10100e14:	00bff904 	movi	r2,-28
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
		descriptor_base, 
    	descriptor->control);
    return 0;
}
10100e18:	f800283a 	ret

10100e1c <alt_msgdma_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e1c:	20c00317 	ldw	r3,12(r4)
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e20:	defffb04 	addi	sp,sp,-20
10100e24:	dc800215 	stw	r18,8(sp)
10100e28:	dc400115 	stw	r17,4(sp)
10100e2c:	dc000015 	stw	r16,0(sp)
10100e30:	2823883a 	mov	r17,r5
10100e34:	2021883a 	mov	r16,r4
10100e38:	3025883a 	mov	r18,r6
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e3c:	18c00204 	addi	r3,r3,8
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e40:	dfc00415 	stw	ra,16(sp)
10100e44:	dcc00315 	stw	r19,12(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e48:	18800037 	ldwio	r2,0(r3)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10100e4c:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e50:	18c00037 	ldwio	r3,0(r3)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e54:	04c4e244 	movi	r19,5001
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10100e58:	1806d43a 	srli	r3,r3,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e5c:	81000917 	ldw	r4,36(r16)
10100e60:	19001036 	bltu	r3,r4,10100ea4 <alt_msgdma_descriptor_sync_transfer+0x88>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
10100e64:	01000044 	movi	r4,1
10100e68:	0101b340 	call	10101b34 <alt_busy_sleep>
10100e6c:	98bfffc4 	addi	r2,r19,-1
10100e70:	1027883a 	mov	r19,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100e74:	10bfffcc 	andi	r2,r2,65535
10100e78:	1000031e 	bne	r2,zero,10100e88 <alt_msgdma_descriptor_sync_transfer+0x6c>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
10100e7c:	01040434 	movhi	r4,4112
10100e80:	2107ed04 	addi	r4,r4,8116
10100e84:	00004806 	br	10100fa8 <alt_msgdma_descriptor_sync_transfer+0x18c>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e88:	80c00317 	ldw	r3,12(r16)
10100e8c:	18c00204 	addi	r3,r3,8
10100e90:	18800037 	ldwio	r2,0(r3)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
10100e94:	10bfffcc 	andi	r2,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e98:	18c00037 	ldwio	r3,0(r3)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
10100e9c:	1806d43a 	srli	r3,r3,16
10100ea0:	003fee06 	br	10100e5c <alt_msgdma_descriptor_sync_transfer+0x40>
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100ea4:	113fef2e 	bgeu	r2,r4,10100e64 <alt_msgdma_descriptor_sync_transfer+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100ea8:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100eac:	00bfff84 	movi	r2,-2
10100eb0:	9884703a 	and	r2,r19,r2
10100eb4:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100eb8:	80800317 	ldw	r2,12(r16)
10100ebc:	00c00804 	movi	r3,32
10100ec0:	10c00135 	stwio	r3,4(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10100ec4:	80800317 	ldw	r2,12(r16)
10100ec8:	10c00037 	ldwio	r3,0(r2)
10100ecc:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
10100ed0:	88001026 	beq	r17,zero,10100f14 <alt_msgdma_descriptor_sync_transfer+0xf8>
10100ed4:	9000101e 	bne	r18,zero,10100f18 <alt_msgdma_descriptor_sync_transfer+0xfc>
10100ed8:	0484e244 	movi	r18,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
10100edc:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100ee0:	80c00317 	ldw	r3,12(r16)
10100ee4:	18c00037 	ldwio	r3,0(r3)
10100ee8:	18c0010c 	andi	r3,r3,4
10100eec:	1800261e 	bne	r3,zero,10100f88 <alt_msgdma_descriptor_sync_transfer+0x16c>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
10100ef0:	88c00017 	ldw	r3,0(r17)
10100ef4:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
10100ef8:	88c00117 	ldw	r3,4(r17)
10100efc:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
10100f00:	88c00217 	ldw	r3,8(r17)
10100f04:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
10100f08:	88c00317 	ldw	r3,12(r17)
10100f0c:	10c00335 	stwio	r3,12(r2)
10100f10:	00001206 	br	10100f5c <alt_msgdma_descriptor_sync_transfer+0x140>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
10100f14:	9000021e 	bne	r18,zero,10100f20 <alt_msgdma_descriptor_sync_transfer+0x104>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10100f18:	00bfffc4 	movi	r2,-1
10100f1c:	00004406 	br	10101030 <alt_msgdma_descriptor_sync_transfer+0x214>
10100f20:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
10100f24:	81000317 	ldw	r4,12(r16)
10100f28:	81400417 	ldw	r5,16(r16)
10100f2c:	900d883a 	mov	r6,r18
10100f30:	0100db40 	call	10100db4 <alt_msgdma_write_extended_descriptor>
10100f34:	10000926 	beq	r2,zero,10100f5c <alt_msgdma_descriptor_sync_transfer+0x140>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10100f38:	01000044 	movi	r4,1
10100f3c:	0101b340 	call	10101b34 <alt_busy_sleep>
10100f40:	88bfffc4 	addi	r2,r17,-1
10100f44:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f48:	10bfffcc 	andi	r2,r2,65535
10100f4c:	103ff51e 	bne	r2,zero,10100f24 <alt_msgdma_descriptor_sync_transfer+0x108>
            {
                alt_printf("time out after 5 msec while writing extended" 
10100f50:	01040434 	movhi	r4,4112
10100f54:	21081204 	addi	r4,r4,8264
10100f58:	00001306 	br	10100fa8 <alt_msgdma_descriptor_sync_transfer+0x18c>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100f5c:	81000d17 	ldw	r4,52(r16)
10100f60:	80c00317 	ldw	r3,12(r16)
10100f64:	00bff2c4 	movi	r2,-53
10100f68:	2084703a 	and	r2,r4,r2
10100f6c:	10800114 	ori	r2,r2,4
10100f70:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100f74:	9801703a 	wrctl	status,r19
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100f78:	80800317 	ldw	r2,12(r16)
10100f7c:	10800037 	ldwio	r2,0(r2)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100f80:	0444e244 	movi	r17,5001
10100f84:	00000d06 	br	10100fbc <alt_msgdma_descriptor_sync_transfer+0x1a0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
10100f88:	01000044 	movi	r4,1
10100f8c:	0101b340 	call	10101b34 <alt_busy_sleep>
10100f90:	90bfffc4 	addi	r2,r18,-1
10100f94:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f98:	10bfffcc 	andi	r2,r2,65535
10100f9c:	103fcf1e 	bne	r2,zero,10100edc <alt_msgdma_descriptor_sync_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while writing standard" 
10100fa0:	01040434 	movhi	r4,4112
10100fa4:	21080104 	addi	r4,r4,8196
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100fa8:	0100a940 	call	10100a94 <alt_printf>
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
10100fac:	00bff084 	movi	r2,-62
10100fb0:	00001f06 	br	10101030 <alt_msgdma_descriptor_sync_transfer+0x214>
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100fb4:	80800317 	ldw	r2,12(r16)
10100fb8:	10800037 	ldwio	r2,0(r2)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100fbc:	10c0780c 	andi	r3,r2,480
10100fc0:	18000b1e 	bne	r3,zero,10100ff0 <alt_msgdma_descriptor_sync_transfer+0x1d4>
10100fc4:	1080004c 	andi	r2,r2,1
10100fc8:	10000b26 	beq	r2,zero,10100ff8 <alt_msgdma_descriptor_sync_transfer+0x1dc>
    {
        alt_busy_sleep(1); /* delay 1us */
10100fcc:	01000044 	movi	r4,1
10100fd0:	0101b340 	call	10101b34 <alt_busy_sleep>
10100fd4:	88bfffc4 	addi	r2,r17,-1
10100fd8:	1023883a 	mov	r17,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100fdc:	10bfffcc 	andi	r2,r2,65535
10100fe0:	103ff41e 	bne	r2,zero,10100fb4 <alt_msgdma_descriptor_sync_transfer+0x198>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100fe4:	01040434 	movhi	r4,4112
10100fe8:	21082304 	addi	r4,r4,8332
10100fec:	003fee06 	br	10100fa8 <alt_msgdma_descriptor_sync_transfer+0x18c>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
10100ff0:	00807804 	movi	r2,480
10100ff4:	00000e06 	br	10101030 <alt_msgdma_descriptor_sync_transfer+0x214>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
10100ff8:	80800317 	ldw	r2,12(r16)
10100ffc:	10800104 	addi	r2,r2,4
10101000:	10c00037 	ldwio	r3,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101004:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101008:	013fff84 	movi	r4,-2
1010100c:	2908703a 	and	r4,r5,r4
10101010:	2001703a 	wrctl	status,r4
10101014:	18c00814 	ori	r3,r3,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101018:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
1010101c:	80800317 	ldw	r2,12(r16)
10101020:	10c00037 	ldwio	r3,0(r2)
10101024:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101028:	2801703a 	wrctl	status,r5
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
1010102c:	0005883a 	mov	r2,zero

}
10101030:	dfc00417 	ldw	ra,16(sp)
10101034:	dcc00317 	ldw	r19,12(sp)
10101038:	dc800217 	ldw	r18,8(sp)
1010103c:	dc400117 	ldw	r17,4(sp)
10101040:	dc000017 	ldw	r16,0(sp)
10101044:	dec00504 	addi	sp,sp,20
10101048:	f800283a 	ret

1010104c <alt_msgdma_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
1010104c:	21c00317 	ldw	r7,12(r4)
10101050:	38c00204 	addi	r3,r7,8
10101054:	18800037 	ldwio	r2,0(r3)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10101058:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
1010105c:	18c00037 	ldwio	r3,0(r3)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101060:	22000917 	ldw	r8,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10101064:	1806d43a 	srli	r3,r3,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101068:	1a004b2e 	bgeu	r3,r8,10101198 <alt_msgdma_descriptor_async_transfer+0x14c>
1010106c:	12004a2e 	bgeu	r2,r8,10101198 <alt_msgdma_descriptor_async_transfer+0x14c>
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10101070:	defffc04 	addi	sp,sp,-16
10101074:	dc800215 	stw	r18,8(sp)
10101078:	dc400115 	stw	r17,4(sp)
1010107c:	dc000015 	stw	r16,0(sp)
10101080:	3025883a 	mov	r18,r6
10101084:	2823883a 	mov	r17,r5
10101088:	2021883a 	mov	r16,r4
1010108c:	dfc00315 	stw	ra,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101090:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101094:	00bfff84 	movi	r2,-2
10101098:	1884703a 	and	r2,r3,r2
1010109c:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
101010a0:	00800804 	movi	r2,32
101010a4:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
101010a8:	20800317 	ldw	r2,12(r4)
101010ac:	11000037 	ldwio	r4,0(r2)
101010b0:	11000035 	stwio	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101010b4:	1801703a 	wrctl	status,r3
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
101010b8:	28001026 	beq	r5,zero,101010fc <alt_msgdma_descriptor_async_transfer+0xb0>
101010bc:	3000101e 	bne	r6,zero,10101100 <alt_msgdma_descriptor_async_transfer+0xb4>
101010c0:	0484e244 	movi	r18,5001
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
101010c4:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
101010c8:	80c00317 	ldw	r3,12(r16)
101010cc:	18c00037 	ldwio	r3,0(r3)
101010d0:	18c0010c 	andi	r3,r3,4
101010d4:	1800321e 	bne	r3,zero,101011a0 <alt_msgdma_descriptor_async_transfer+0x154>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
101010d8:	88c00017 	ldw	r3,0(r17)
101010dc:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
101010e0:	88c00117 	ldw	r3,4(r17)
101010e4:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
101010e8:	88c00217 	ldw	r3,8(r17)
101010ec:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
101010f0:	88c00317 	ldw	r3,12(r17)
101010f4:	10c00335 	stwio	r3,12(r2)
101010f8:	00001406 	br	1010114c <alt_msgdma_descriptor_async_transfer+0x100>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
101010fc:	3000021e 	bne	r6,zero,10101108 <alt_msgdma_descriptor_async_transfer+0xbc>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10101100:	00bfffc4 	movi	r2,-1
10101104:	00002f06 	br	101011c4 <alt_msgdma_descriptor_async_transfer+0x178>
10101108:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
1010110c:	81000317 	ldw	r4,12(r16)
10101110:	81400417 	ldw	r5,16(r16)
10101114:	900d883a 	mov	r6,r18
10101118:	0100db40 	call	10100db4 <alt_msgdma_write_extended_descriptor>
1010111c:	10000b26 	beq	r2,zero,1010114c <alt_msgdma_descriptor_async_transfer+0x100>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101120:	01000044 	movi	r4,1
10101124:	0101b340 	call	10101b34 <alt_busy_sleep>
10101128:	88bfffc4 	addi	r2,r17,-1
1010112c:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101130:	10bfffcc 	andi	r2,r2,65535
10101134:	103ff51e 	bne	r2,zero,1010110c <alt_msgdma_descriptor_async_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
10101138:	01040434 	movhi	r4,4112
1010113c:	21084b04 	addi	r4,r4,8492
10101140:	0100a940 	call	10100a94 <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
10101144:	00bff084 	movi	r2,-62
10101148:	00001e06 	br	101011c4 <alt_msgdma_descriptor_async_transfer+0x178>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
1010114c:	81000b17 	ldw	r4,44(r16)
10101150:	81400317 	ldw	r5,12(r16)
10101154:	00bfff84 	movi	r2,-2
10101158:	80c00d17 	ldw	r3,52(r16)
1010115c:	20000426 	beq	r4,zero,10101170 <alt_msgdma_descriptor_async_transfer+0x124>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101160:	013ff7c4 	movi	r4,-33
10101164:	1906703a 	and	r3,r3,r4
10101168:	18c00514 	ori	r3,r3,20
1010116c:	00000306 	br	1010117c <alt_msgdma_descriptor_async_transfer+0x130>
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
10101170:	013ff3c4 	movi	r4,-49
10101174:	1906703a 	and	r3,r3,r4
10101178:	18c00114 	ori	r3,r3,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
1010117c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101180:	2084703a 	and	r2,r4,r2
10101184:	1001703a 	wrctl	status,r2
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101188:	28c00135 	stwio	r3,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1010118c:	2001703a 	wrctl	status,r4
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101190:	0005883a 	mov	r2,zero
10101194:	00000b06 	br	101011c4 <alt_msgdma_descriptor_async_transfer+0x178>
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
10101198:	00bff904 	movi	r2,-28
1010119c:	f800283a 	ret
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
101011a0:	01000044 	movi	r4,1
101011a4:	0101b340 	call	10101b34 <alt_busy_sleep>
101011a8:	90bfffc4 	addi	r2,r18,-1
101011ac:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
101011b0:	10bfffcc 	andi	r2,r2,65535
101011b4:	103fc31e 	bne	r2,zero,101010c4 <alt_msgdma_descriptor_async_transfer+0x78>
            {
                alt_printf("time out after 5 msec while waiting" 
101011b8:	01040434 	movhi	r4,4112
101011bc:	21083504 	addi	r4,r4,8404
101011c0:	003fdf06 	br	10101140 <alt_msgdma_descriptor_async_transfer+0xf4>
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
}
101011c4:	dfc00317 	ldw	ra,12(sp)
101011c8:	dc800217 	ldw	r18,8(sp)
101011cc:	dc400117 	ldw	r17,4(sp)
101011d0:	dc000017 	ldw	r16,0(sp)
101011d4:	dec00404 	addi	sp,sp,16
101011d8:	f800283a 	ret

101011dc <alt_msgdma_construct_standard_st_to_mm_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101011dc:	20801217 	ldw	r2,72(r4)
101011e0:	11c00a36 	bltu	r2,r7,1010120c <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
101011e4:	20801703 	ldbu	r2,92(r4)
101011e8:	1000081e 	bne	r2,zero,1010120c <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011ec:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101011f0:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
101011f4:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011f8:	10a00034 	orhi	r2,r2,32768
101011fc:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101200:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101204:	0005883a 	mov	r2,zero
10101208:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
1010120c:	00bffa84 	movi	r2,-22
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
            write_address, length, control);
}
10101210:	f800283a 	ret

10101214 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101214:	20801217 	ldw	r2,72(r4)
10101218:	11c00a36 	bltu	r2,r7,10101244 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
1010121c:	20801703 	ldbu	r2,92(r4)
10101220:	1000081e 	bne	r2,zero,10101244 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101224:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101228:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010122c:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101230:	10a00034 	orhi	r2,r2,32768
10101234:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101238:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010123c:	0005883a 	mov	r2,zero
10101240:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101244:	00bffa84 	movi	r2,-22
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            NULL, length, control);

}
10101248:	f800283a 	ret

1010124c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
1010124c:	d8800017 	ldw	r2,0(sp)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101250:	20c01217 	ldw	r3,72(r4)
10101254:	18800a36 	bltu	r3,r2,10101280 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
10101258:	20c01703 	ldbu	r3,92(r4)
1010125c:	1800081e 	bne	r3,zero,10101280 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101260:	28800215 	stw	r2,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101264:	d8800117 	ldw	r2,4(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101268:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010126c:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101270:	10a00034 	orhi	r2,r2,32768
10101274:	28800315 	stw	r2,12(r5)
    
    return 0;
10101278:	0005883a 	mov	r2,zero
1010127c:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101280:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            write_address, length, control);
}
10101284:	f800283a 	ret

10101288 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101288:	22401217 	ldw	r9,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
1010128c:	da000117 	ldw	r8,4(sp)
10101290:	d8c00217 	ldw	r3,8(sp)
10101294:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101298:	49c01736 	bltu	r9,r7,101012f8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < read_stride ||
1010129c:	22801417 	ldw	r10,80(r4)
       dev->max_stride < write_stride ||
101012a0:	127fffcc 	andi	r9,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101012a4:	5000021e 	bne	r10,zero,101012b0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x28>
101012a8:	22801317 	ldw	r10,76(r4)
101012ac:	52401236 	bltu	r10,r9,101012f8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < write_stride ||
101012b0:	22401703 	ldbu	r9,92(r4)
101012b4:	01000044 	movi	r4,1
101012b8:	49000f1e 	bne	r9,r4,101012f8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101012bc:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012c0:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101012c4:	28000015 	stw	zero,0(r5)
    descriptor->write_address_low = write_address;
101012c8:	29800115 	stw	r6,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012cc:	10a00034 	orhi	r2,r2,32768
101012d0:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101012d4:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
101012d8:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
101012dc:	28000385 	stb	zero,14(r5)
    descriptor->write_burst_count = write_burst_count;
101012e0:	28c003c5 	stb	r3,15(r5)
    descriptor->read_stride = read_stride;
101012e4:	2800040d 	sth	zero,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101012e8:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101012ec:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101012f0:	0005883a 	mov	r2,zero
101012f4:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101012f8:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
101012fc:	f800283a 	ret

10101300 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101300:	22401217 	ldw	r9,72(r4)
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101304:	da000117 	ldw	r8,4(sp)
10101308:	d8c00217 	ldw	r3,8(sp)
1010130c:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101310:	49c01736 	bltu	r9,r7,10101370 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
10101314:	22801417 	ldw	r10,80(r4)
       dev->max_stride < read_stride ||
10101318:	127fffcc 	andi	r9,r2,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010131c:	5000021e 	bne	r10,zero,10101328 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x28>
10101320:	22801317 	ldw	r10,76(r4)
10101324:	52401236 	bltu	r10,r9,10101370 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101328:	22401703 	ldbu	r9,92(r4)
1010132c:	01000044 	movi	r4,1
10101330:	49000f1e 	bne	r9,r4,10101370 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101334:	2880040d 	sth	r2,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101338:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
1010133c:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
10101340:	28000115 	stw	zero,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101344:	10a00034 	orhi	r2,r2,32768
10101348:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
1010134c:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
10101350:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
10101354:	28c00385 	stb	r3,14(r5)
    descriptor->write_burst_count = write_burst_count;
10101358:	280003c5 	stb	zero,15(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010135c:	2800048d 	sth	zero,18(r5)
    descriptor->read_address_high = NULL;
10101360:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
10101364:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101368:	0005883a 	mov	r2,zero
1010136c:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101370:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
10101374:	f800283a 	ret

10101378 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101378:	da000017 	ldw	r8,0(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010137c:	22401217 	ldw	r9,72(r4)
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101380:	db400217 	ldw	r13,8(sp)
10101384:	db000317 	ldw	r12,12(sp)
10101388:	dac00417 	ldw	r11,16(sp)
1010138c:	d8c00517 	ldw	r3,20(sp)
10101390:	d8800617 	ldw	r2,24(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101394:	4a001a36 	bltu	r9,r8,10101400 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
10101398:	22801417 	ldw	r10,80(r4)
1010139c:	22401317 	ldw	r9,76(r4)
101013a0:	1bbfffcc 	andi	r14,r3,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101013a4:	5000011e 	bne	r10,zero,101013ac <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x34>
101013a8:	4b801536 	bltu	r9,r14,10101400 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
101013ac:	13bfffcc 	andi	r14,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101013b0:	5000011e 	bne	r10,zero,101013b8 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x40>
101013b4:	4b801236 	bltu	r9,r14,10101400 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
101013b8:	22401703 	ldbu	r9,92(r4)
101013bc:	01000044 	movi	r4,1
101013c0:	49000f1e 	bne	r9,r4,10101400 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101013c4:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013c8:	d8800117 	ldw	r2,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101013cc:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
101013d0:	29c00115 	stw	r7,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013d4:	10a00034 	orhi	r2,r2,32768
101013d8:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101013dc:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
101013e0:	2b40030d 	sth	r13,12(r5)
    descriptor->read_burst_count = read_burst_count;
101013e4:	2b000385 	stb	r12,14(r5)
    descriptor->write_burst_count = write_burst_count;
101013e8:	2ac003c5 	stb	r11,15(r5)
    descriptor->read_stride = read_stride;
101013ec:	28c0040d 	sth	r3,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101013f0:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101013f4:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101013f8:	0005883a 	mov	r2,zero
101013fc:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101400:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
10101404:	f800283a 	ret

10101408 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
10101408:	d8800017 	ldw	r2,0(sp)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
1010140c:	20c01217 	ldw	r3,72(r4)
10101410:	18800e36 	bltu	r3,r2,1010144c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
10101414:	20c01703 	ldbu	r3,92(r4)
10101418:	18000c1e 	bne	r3,zero,1010144c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010141c:	d8c00117 	ldw	r3,4(sp)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101420:	28800215 	stw	r2,8(r5)
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101424:	00900034 	movhi	r2,16384
10101428:	10bfffc4 	addi	r2,r2,-1
1010142c:	1884703a 	and	r2,r3,r2
10101430:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101434:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101438:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
1010143c:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101440:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101444:	0005883a 	mov	r2,zero
10101448:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
1010144c:	00bffa84 	movi	r2,-22
	alt_u32 length,
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, write_address, length, control);
}
10101450:	f800283a 	ret

10101454 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101454:	20801217 	ldw	r2,72(r4)
10101458:	11c00e36 	bltu	r2,r7,10101494 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
1010145c:	20801703 	ldbu	r2,92(r4)
10101460:	10000c1e 	bne	r2,zero,10101494 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101464:	d8c00017 	ldw	r3,0(sp)
10101468:	00900034 	movhi	r2,16384
1010146c:	10bfffc4 	addi	r2,r2,-1
10101470:	1884703a 	and	r2,r3,r2
10101474:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101478:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
1010147c:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
10101480:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
10101484:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101488:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010148c:	0005883a 	mov	r2,zero
10101490:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101494:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		0, write_address, length, control);
}
10101498:	f800283a 	ret

1010149c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
1010149c:	20801217 	ldw	r2,72(r4)
101014a0:	11c00e36 	bltu	r2,r7,101014dc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
101014a4:	20801703 	ldbu	r2,92(r4)
101014a8:	10000c1e 	bne	r2,zero,101014dc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101014ac:	d8c00017 	ldw	r3,0(sp)
101014b0:	00900034 	movhi	r2,16384
101014b4:	10bfffc4 	addi	r2,r2,-1
101014b8:	1884703a 	and	r2,r3,r2
101014bc:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
101014c0:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101014c4:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
101014c8:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
101014cc:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
101014d0:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101014d4:	0005883a 	mov	r2,zero
101014d8:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
101014dc:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, 0, length, control);
}
101014e0:	f800283a 	ret

101014e4 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014e4:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014e8:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014ec:	da400217 	ldw	r9,8(sp)
101014f0:	da000317 	ldw	r8,12(sp)
101014f4:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014f8:	50c01c36 	bltu	r10,r3,1010156c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
101014fc:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < write_stride ||
10101500:	12bfffcc 	andi	r10,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101504:	5800021e 	bne	r11,zero,10101510 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x2c>
10101508:	22c01317 	ldw	r11,76(r4)
1010150c:	5a801736 	bltu	r11,r10,1010156c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
10101510:	22801703 	ldbu	r10,92(r4)
10101514:	01000044 	movi	r4,1
10101518:	5100141e 	bne	r10,r4,1010156c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
1010151c:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101520:	d8c00117 	ldw	r3,4(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101524:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101528:	00900034 	movhi	r2,16384
1010152c:	10bfffc4 	addi	r2,r2,-1
10101530:	1884703a 	and	r2,r3,r2
10101534:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101538:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
1010153c:	28000915 	stw	zero,36(r5)
    descriptor->read_address_low = read_address_low;
10101540:	28000015 	stw	zero,0(r5)
    descriptor->write_address_high = write_address_high;
10101544:	29800a15 	stw	r6,40(r5)
    descriptor->write_address_low = write_address_low;
10101548:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
1010154c:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101550:	28000785 	stb	zero,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101554:	2a0007c5 	stb	r8,31(r5)
    descriptor->read_stride = read_stride;
10101558:	2800080d 	sth	zero,32(r5)
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
1010155c:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
10101560:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101564:	0005883a 	mov	r2,zero
10101568:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
1010156c:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
10101570:	f800283a 	ret

10101574 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101574:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101578:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
1010157c:	da400217 	ldw	r9,8(sp)
10101580:	da000317 	ldw	r8,12(sp)
10101584:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101588:	50c01c36 	bltu	r10,r3,101015fc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
1010158c:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < read_stride ||
10101590:	12bfffcc 	andi	r10,r2,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101594:	5800021e 	bne	r11,zero,101015a0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x2c>
10101598:	22c01317 	ldw	r11,76(r4)
1010159c:	5a801736 	bltu	r11,r10,101015fc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
101015a0:	22801703 	ldbu	r10,92(r4)
101015a4:	01000044 	movi	r4,1
101015a8:	5100141e 	bne	r10,r4,101015fc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
101015ac:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101015b0:	d8c00117 	ldw	r3,4(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
101015b4:	2880080d 	sth	r2,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101015b8:	00900034 	movhi	r2,16384
101015bc:	10bfffc4 	addi	r2,r2,-1
101015c0:	1884703a 	and	r2,r3,r2
101015c4:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
101015c8:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
101015cc:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
101015d0:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
101015d4:	28000a15 	stw	zero,40(r5)
    descriptor->write_address_low = write_address_low;
101015d8:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
101015dc:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
101015e0:	2a000785 	stb	r8,30(r5)
    descriptor->write_burst_count = write_burst_count;
101015e4:	280007c5 	stb	zero,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101015e8:	2800088d 	sth	zero,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
101015ec:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
101015f0:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101015f4:	0005883a 	mov	r2,zero
101015f8:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101015fc:	00bffa84 	movi	r2,-22
	alt_u16 read_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
10101600:	f800283a 	ret

10101604 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
10101604:	da000217 	ldw	r8,8(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101608:	22401217 	ldw	r9,72(r4)
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
1010160c:	db400417 	ldw	r13,16(sp)
10101610:	db000517 	ldw	r12,20(sp)
10101614:	dac00617 	ldw	r11,24(sp)
10101618:	d8c00717 	ldw	r3,28(sp)
1010161c:	d8800817 	ldw	r2,32(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101620:	4a002136 	bltu	r9,r8,101016a8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
10101624:	22801417 	ldw	r10,80(r4)
10101628:	22401317 	ldw	r9,76(r4)
1010162c:	1bbfffcc 	andi	r14,r3,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101630:	5000011e 	bne	r10,zero,10101638 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x34>
10101634:	4b801c36 	bltu	r9,r14,101016a8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101638:	13bfffcc 	andi	r14,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
1010163c:	5000011e 	bne	r10,zero,10101644 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x40>
10101640:	4b801936 	bltu	r9,r14,101016a8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < write_stride ||
10101644:	22401703 	ldbu	r9,92(r4)
10101648:	01000044 	movi	r4,1
1010164c:	4900161e 	bne	r9,r4,101016a8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101650:	d9000017 	ldw	r4,0(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101654:	28c0080d 	sth	r3,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101658:	d8c00317 	ldw	r3,12(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010165c:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101660:	00900034 	movhi	r2,16384
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101664:	29000a15 	stw	r4,40(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101668:	10bfffc4 	addi	r2,r2,-1
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
1010166c:	d9000117 	ldw	r4,4(sp)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101670:	1884703a 	and	r2,r3,r2
10101674:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101678:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
1010167c:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
10101680:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
10101684:	29000115 	stw	r4,4(r5)
    descriptor->transfer_length = length;
10101688:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
1010168c:	2b40070d 	sth	r13,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101690:	2b000785 	stb	r12,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101694:	2ac007c5 	stb	r11,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
10101698:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
1010169c:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101016a0:	0005883a 	mov	r2,zero
101016a4:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101016a8:	00bffa84 	movi	r2,-22
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
101016ac:	f800283a 	ret

101016b0 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
101016b0:	28001126 	beq	r5,zero,101016f8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
101016b4:	29800317 	ldw	r6,12(r5)
101016b8:	29800f1e 	bne	r5,r6,101016f8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
101016bc:	20800017 	ldw	r2,0(r4)
101016c0:	1000021e 	bne	r2,zero,101016cc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x1c>
	{
		*list = descriptor;  /* make this root-node if list is empty */
101016c4:	21400015 	stw	r5,0(r4)
		return 0;  /* successfully added */
101016c8:	f800283a 	ret
	}
	if (*list == descriptor)
101016cc:	11400a26 	beq	r2,r5,101016f8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
101016d0:	1007883a 	mov	r3,r2
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
101016d4:	19000317 	ldw	r4,12(r3)
101016d8:	20800326 	beq	r4,r2,101016e8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x38>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
101016dc:	21800626 	beq	r4,r6,101016f8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
101016e0:	2007883a 	mov	r3,r4
101016e4:	003ffb06 	br	101016d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x24>
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
101016e8:	19800315 	stw	r6,12(r3)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
101016ec:	28800315 	stw	r2,12(r5)
	return 0; /* successfully added */
101016f0:	0005883a 	mov	r2,zero
101016f4:	f800283a 	ret
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
101016f8:	00bffa84 	movi	r2,-22
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
	return 0; /* successfully added */
}
101016fc:	f800283a 	ret

10101700 <alt_msgdma_prefetcher_add_extended_desc_to_list>:
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
10101700:	2800021e 	bne	r5,zero,1010170c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
10101704:	00bffa84 	movi	r2,-22
10101708:	f800283a 	ret
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
1010170c:	28800317 	ldw	r2,12(r5)
10101710:	11400226 	beq	r2,r5,1010171c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x1c>
10101714:	28800b17 	ldw	r2,44(r5)
10101718:	103ffa1e 	bne	r2,zero,10101704 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
1010171c:	20800017 	ldw	r2,0(r4)
10101720:	1000021e 	bne	r2,zero,1010172c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
10101724:	21400015 	stw	r5,0(r4)
		return 0;
10101728:	f800283a 	ret
	}
	if (*list == descriptor)
1010172c:	117ff526 	beq	r2,r5,10101704 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
10101730:	1007883a 	mov	r3,r2
10101734:	11000317 	ldw	r4,12(r2)
10101738:	20c0061e 	bne	r4,r3,10101754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x54>
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
1010173c:	11400315 	stw	r5,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
10101740:	10000b15 	stw	zero,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
10101744:	28c00315 	stw	r3,12(r5)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
10101748:	28000b15 	stw	zero,44(r5)
	return 0;
1010174c:	0005883a 	mov	r2,zero
10101750:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
10101754:	11800b17 	ldw	r6,44(r2)
10101758:	303ff826 	beq	r6,zero,1010173c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x3c>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
1010175c:	2005883a 	mov	r2,r4
10101760:	003ff406 	br	10101734 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x34>

10101764 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
10101764:	20000a26 	beq	r4,zero,10101790 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
10101768:	2005883a 	mov	r2,r4
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
1010176c:	10c00717 	ldw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101770:	11400317 	ldw	r5,12(r2)
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101774:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
10101778:	10c00715 	stw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
1010177c:	21400226 	beq	r4,r5,10101788 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x24>
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
10101780:	2805883a 	mov	r2,r5
10101784:	003ff906 	br	1010176c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x8>
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
10101788:	0005883a 	mov	r2,zero
1010178c:	f800283a 	ret
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
10101790:	00bffa84 	movi	r2,-22
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
}
10101794:	f800283a 	ret

10101798 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
10101798:	20000f26 	beq	r4,zero,101017d8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
1010179c:	200b883a 	mov	r5,r4
101017a0:	20c00317 	ldw	r3,12(r4)
101017a4:	1940051e 	bne	r3,r5,101017bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x24>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101017a8:	20800f17 	ldw	r2,60(r4)
101017ac:	10900034 	orhi	r2,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
101017b0:	20800f15 	stw	r2,60(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
101017b4:	0005883a 	mov	r2,zero
101017b8:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
101017bc:	20800b17 	ldw	r2,44(r4)
101017c0:	103ff926 	beq	r2,zero,101017a8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x10>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101017c4:	20800f17 	ldw	r2,60(r4)
101017c8:	10900034 	orhi	r2,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
101017cc:	20800f15 	stw	r2,60(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
101017d0:	1809883a 	mov	r4,r3
101017d4:	003ff206 	br	101017a0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8>
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
101017d8:	00bffa84 	movi	r2,-22
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
}
101017dc:	f800283a 	ret

101017e0 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
101017e0:	da800017 	ldw	r10,0(sp)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
101017e4:	20800617 	ldw	r2,24(r4)
101017e8:	10800037 	ldwio	r2,0(r2)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
101017ec:	10c0004c 	andi	r3,r2,1
101017f0:	18003b1e 	bne	r3,zero,101018e0 <alt_msgdma_start_prefetcher_with_list_addr+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101017f4:	0011303a 	rdctl	r8,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101017f8:	00ffff84 	movi	r3,-2
101017fc:	40d2703a 	and	r9,r8,r3
10101800:	4801703a 	wrctl	status,r9
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
10101804:	22400317 	ldw	r9,12(r4)
10101808:	02c00804 	movi	r11,32
1010180c:	4ac00135 	stwio	r11,4(r9)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
10101810:	22400317 	ldw	r9,12(r4)
10101814:	4ac00037 	ldwio	r11,0(r9)
10101818:	4ac00035 	stwio	r11,0(r9)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1010181c:	4001703a 	wrctl	status,r8
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
10101820:	22400b17 	ldw	r9,44(r4)
10101824:	22c00317 	ldw	r11,12(r4)
10101828:	22000d17 	ldw	r8,52(r4)
1010182c:	48000526 	beq	r9,zero,10101844 <alt_msgdma_start_prefetcher_with_list_addr+0x64>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101830:	027ff7c4 	movi	r9,-33
10101834:	4250703a 	and	r8,r8,r9
10101838:	42000514 	ori	r8,r8,20
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
1010183c:	10800214 	ori	r2,r2,8
10101840:	00000506 	br	10101858 <alt_msgdma_start_prefetcher_with_list_addr+0x78>
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101844:	027ff3c4 	movi	r9,-49
10101848:	4250703a 	and	r8,r8,r9
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
1010184c:	027ffdc4 	movi	r9,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101850:	42000114 	ori	r8,r8,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
10101854:	1244703a 	and	r2,r2,r9
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101858:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
1010185c:	48c6703a 	and	r3,r9,r3
10101860:	1801703a 	wrctl	status,r3
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
10101864:	5a000135 	stwio	r8,4(r11)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
10101868:	20c00617 	ldw	r3,24(r4)
1010186c:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101870:	4801703a 	wrctl	status,r9
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
10101874:	20c00617 	ldw	r3,24(r4)
10101878:	19400135 	stwio	r5,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
1010187c:	20c00617 	ldw	r3,24(r4)
10101880:	19800235 	stwio	r6,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
10101884:	39c03fcc 	andi	r7,r7,255
10101888:	38000226 	beq	r7,zero,10101894 <alt_msgdma_start_prefetcher_with_list_addr+0xb4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
1010188c:	10800414 	ori	r2,r2,16
10101890:	00000206 	br	1010189c <alt_msgdma_start_prefetcher_with_list_addr+0xbc>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
10101894:	00fffbc4 	movi	r3,-17
10101898:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
1010189c:	50c03fcc 	andi	r3,r10,255
101018a0:	18000826 	beq	r3,zero,101018c4 <alt_msgdma_start_prefetcher_with_list_addr+0xe4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101018a4:	20c00617 	ldw	r3,24(r4)
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
101018a8:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101018ac:	18c00304 	addi	r3,r3,12
101018b0:	19400037 	ldwio	r5,0(r3)
101018b4:	2800051e 	bne	r5,zero,101018cc <alt_msgdma_start_prefetcher_with_list_addr+0xec>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101018b8:	01403fc4 	movi	r5,255
101018bc:	19400035 	stwio	r5,0(r3)
101018c0:	00000206 	br	101018cc <alt_msgdma_start_prefetcher_with_list_addr+0xec>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
101018c4:	00ffff44 	movi	r3,-3
101018c8:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018cc:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
101018d0:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018d4:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
101018d8:	0005883a 	mov	r2,zero
101018dc:	f800283a 	ret
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
101018e0:	00bffc04 	movi	r2,-16
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
}
101018e4:	f800283a 	ret

101018e8 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018e8:	defffa04 	addi	sp,sp,-24
101018ec:	dc800415 	stw	r18,16(sp)
101018f0:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018f4:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018f8:	dc400315 	stw	r17,12(sp)
101018fc:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
10101900:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
10101904:	dfc00515 	stw	ra,20(sp)
10101908:	3023883a 	mov	r17,r6
1010190c:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
10101910:	01017640 	call	10101764 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
10101914:	d9400117 	ldw	r5,4(sp)
10101918:	1000071e 	bne	r2,zero,10101938 <alt_msgdma_start_prefetcher_with_std_desc_list+0x50>
		return -EINVAL;
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
1010191c:	84003fcc 	andi	r16,r16,255
10101920:	dc000015 	stw	r16,0(sp)
10101924:	9009883a 	mov	r4,r18
10101928:	000d883a 	mov	r6,zero
1010192c:	89c03fcc 	andi	r7,r17,255
10101930:	01017e00 	call	101017e0 <alt_msgdma_start_prefetcher_with_list_addr>
10101934:	00000106 	br	1010193c <alt_msgdma_start_prefetcher_with_std_desc_list+0x54>
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101938:	00bffa84 	movi	r2,-22
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
			park_mode_en, poll_en);
}
1010193c:	dfc00517 	ldw	ra,20(sp)
10101940:	dc800417 	ldw	r18,16(sp)
10101944:	dc400317 	ldw	r17,12(sp)
10101948:	dc000217 	ldw	r16,8(sp)
1010194c:	dec00604 	addi	sp,sp,24
10101950:	f800283a 	ret

10101954 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101954:	defffa04 	addi	sp,sp,-24
10101958:	dc800415 	stw	r18,16(sp)
1010195c:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101960:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101964:	dc400315 	stw	r17,12(sp)
10101968:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
1010196c:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101970:	dfc00515 	stw	ra,20(sp)
10101974:	3023883a 	mov	r17,r6
10101978:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
1010197c:	01017980 	call	10101798 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
10101980:	d9400117 	ldw	r5,4(sp)
10101984:	1000071e 	bne	r2,zero,101019a4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
10101988:	84003fcc 	andi	r16,r16,255
1010198c:	dc000015 	stw	r16,0(sp)
10101990:	9009883a 	mov	r4,r18
10101994:	000d883a 	mov	r6,zero
10101998:	89c03fcc 	andi	r7,r17,255
1010199c:	01017e00 	call	101017e0 <alt_msgdma_start_prefetcher_with_list_addr>
101019a0:	00000106 	br	101019a8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x54>
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
101019a4:	00bffa84 	movi	r2,-22
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
			park_mode_en, poll_en);
}
101019a8:	dfc00517 	ldw	ra,20(sp)
101019ac:	dc800417 	ldw	r18,16(sp)
101019b0:	dc400317 	ldw	r17,12(sp)
101019b4:	dc000217 	ldw	r16,8(sp)
101019b8:	dec00604 	addi	sp,sp,24
101019bc:	f800283a 	ret

101019c0 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019c0:	defffe04 	addi	sp,sp,-8
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019c4:	d1600204 	addi	r5,gp,-32760
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019c8:	dc000015 	stw	r16,0(sp)
101019cc:	dfc00115 	stw	ra,4(sp)
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019d0:	0101c3c0 	call	10101c3c <alt_find_dev>
101019d4:	1021883a 	mov	r16,r2

    if (NULL == dev)
101019d8:	10000a1e 	bne	r2,zero,10101a04 <alt_msgdma_open+0x44>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
101019dc:	00840434 	movhi	r2,4112
101019e0:	108afd04 	addi	r2,r2,11252
101019e4:	10800017 	ldw	r2,0(r2)
101019e8:	10000226 	beq	r2,zero,101019f4 <alt_msgdma_open+0x34>
101019ec:	103ee83a 	callr	r2
101019f0:	00000206 	br	101019fc <alt_msgdma_open+0x3c>
101019f4:	00840434 	movhi	r2,4112
101019f8:	108da204 	addi	r2,r2,13960
    {
        ALT_ERRNO = ENODEV;
101019fc:	00c004c4 	movi	r3,19
10101a00:	10c00015 	stw	r3,0(r2)
    }

    return dev;
}
10101a04:	8005883a 	mov	r2,r16
10101a08:	dfc00117 	ldw	ra,4(sp)
10101a0c:	dc000017 	ldw	r16,0(sp)
10101a10:	dec00204 	addi	sp,sp,8
10101a14:	f800283a 	ret

10101a18 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101a18:	defffb04 	addi	sp,sp,-20
10101a1c:	dc800315 	stw	r18,12(sp)
10101a20:	dc400215 	stw	r17,8(sp)
10101a24:	dc000115 	stw	r16,4(sp)
10101a28:	dfc00415 	stw	ra,16(sp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a2c:	20801783 	ldbu	r2,94(r4)
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101a30:	2021883a 	mov	r16,r4
10101a34:	2825883a 	mov	r18,r5
10101a38:	3023883a 	mov	r17,r6
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a3c:	1000041e 	bne	r2,zero,10101a50 <alt_msgdma_init+0x38>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
10101a40:	80800317 	ldw	r2,12(r16)
10101a44:	00c00084 	movi	r3,2
10101a48:	10c00135 	stwio	r3,4(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a4c:	00000806 	br	10101a70 <alt_msgdma_init+0x58>
    int error;

    if (dev->prefetcher_enable)
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
10101a50:	20800617 	ldw	r2,24(r4)
10101a54:	00c00104 	movi	r3,4
10101a58:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
10101a5c:	80800617 	ldw	r2,24(r16)
10101a60:	10800037 	ldwio	r2,0(r2)
10101a64:	1080010c 	andi	r2,r2,4
10101a68:	103ffc1e 	bne	r2,zero,10101a5c <alt_msgdma_init+0x44>
10101a6c:	003ff406 	br	10101a40 <alt_msgdma_init+0x28>
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a70:	80800317 	ldw	r2,12(r16)
10101a74:	10c00037 	ldwio	r3,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
10101a78:	18c0100c 	andi	r3,r3,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a7c:	183ffc1e 	bne	r3,zero,10101a70 <alt_msgdma_init+0x58>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10101a80:	10800104 	addi	r2,r2,4
10101a84:	11000037 	ldwio	r4,0(r2)
10101a88:	00fffbc4 	movi	r3,-17
10101a8c:	20c6703a 	and	r3,r4,r3
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
10101a90:	18c00814 	ori	r3,r3,32
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10101a94:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
10101a98:	80800317 	ldw	r2,12(r16)
10101a9c:	10c00037 	ldwio	r3,0(r2)
10101aa0:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
10101aa4:	80801783 	ldbu	r2,94(r16)
10101aa8:	10000426 	beq	r2,zero,10101abc <alt_msgdma_init+0xa4>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
10101aac:	80800617 	ldw	r2,24(r16)
10101ab0:	10800404 	addi	r2,r2,16
10101ab4:	10c00037 	ldwio	r3,0(r2)
10101ab8:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
10101abc:	8009883a 	mov	r4,r16
10101ac0:	d1600204 	addi	r5,gp,-32760
10101ac4:	0101bc40 	call	10101bc4 <alt_dev_llist_insert>
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
            
    if (!error)
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
10101ac8:	01840434 	movhi	r6,4112
10101acc:	d8000015 	stw	zero,0(sp)
10101ad0:	9009883a 	mov	r4,r18
10101ad4:	880b883a 	mov	r5,r17
10101ad8:	31833a04 	addi	r6,r6,3304
10101adc:	800f883a 	mov	r7,r16
10101ae0:	010086c0 	call	1010086c <alt_ic_isr_register>
        alt_printf("failed to create semaphores\n");
    }
    
    return;

}
10101ae4:	dfc00417 	ldw	ra,16(sp)
10101ae8:	dc800317 	ldw	r18,12(sp)
10101aec:	dc400217 	ldw	r17,8(sp)
10101af0:	dc000117 	ldw	r16,4(sp)
10101af4:	dec00504 	addi	sp,sp,20
10101af8:	f800283a 	ret

10101afc <alt_msgdma_register_callback>:
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
    dev->callback         = callback;
10101afc:	21400b15 	stw	r5,44(r4)
    dev->callback_context = context;
10101b00:	21c00c15 	stw	r7,48(r4)
    dev->control          = control;
10101b04:	21800d15 	stw	r6,52(r4)
10101b08:	f800283a 	ret

10101b0c <alt_msgdma_standard_descriptor_async_transfer>:
{
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
10101b0c:	000d883a 	mov	r6,zero
10101b10:	010104c1 	jmpi	1010104c <alt_msgdma_descriptor_async_transfer>

10101b14 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101b14:	280d883a 	mov	r6,r5
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
10101b18:	000b883a 	mov	r5,zero
10101b1c:	010104c1 	jmpi	1010104c <alt_msgdma_descriptor_async_transfer>

10101b20 <alt_msgdma_standard_descriptor_sync_transfer>:
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
10101b20:	000d883a 	mov	r6,zero
10101b24:	0100e1c1 	jmpi	10100e1c <alt_msgdma_descriptor_sync_transfer>

10101b28 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101b28:	280d883a 	mov	r6,r5
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
10101b2c:	000b883a 	mov	r5,zero
10101b30:	0100e1c1 	jmpi	10100e1c <alt_msgdma_descriptor_sync_transfer>

10101b34 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b34:	01420034 	movhi	r5,2048
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b38:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b3c:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b40:	dc000015 	stw	r16,0(sp)
10101b44:	dfc00115 	stw	ra,4(sp)
10101b48:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b4c:	01008340 	call	10100834 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b50:	10000e26 	beq	r2,zero,10101b8c <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b54:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b58:	013e0034 	movhi	r4,63488
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b5c:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b60:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b64:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b68:	297fffc4 	addi	r5,r5,-1
10101b6c:	283ffe1e 	bne	r5,zero,10101b68 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b70:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b74:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b78:	18bffb16 	blt	r3,r2,10101b68 <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b7c:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b80:	843fffc4 	addi	r16,r16,-1
10101b84:	803ffe1e 	bne	r16,zero,10101b80 <alt_busy_sleep+0x4c>
10101b88:	00000306 	br	10101b98 <alt_busy_sleep+0x64>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b8c:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b90:	843fffc4 	addi	r16,r16,-1
10101b94:	043ffe16 	blt	zero,r16,10101b90 <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
10101b98:	0005883a 	mov	r2,zero
10101b9c:	dfc00117 	ldw	ra,4(sp)
10101ba0:	dc000017 	ldw	r16,0(sp)
10101ba4:	dec00204 	addi	sp,sp,8
10101ba8:	f800283a 	ret

10101bac <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101bac:	0005883a 	mov	r2,zero
10101bb0:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10101bb4:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101bb8:	10800804 	addi	r2,r2,32
10101bbc:	10fffd1e 	bne	r2,r3,10101bb4 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10101bc0:	f800283a 	ret

10101bc4 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10101bc4:	20000226 	beq	r4,zero,10101bd0 <alt_dev_llist_insert+0xc>
10101bc8:	20800217 	ldw	r2,8(r4)
10101bcc:	1000131e 	bne	r2,zero,10101c1c <alt_dev_llist_insert+0x58>
10101bd0:	00840434 	movhi	r2,4112
10101bd4:	108afd04 	addi	r2,r2,11252
10101bd8:	10800017 	ldw	r2,0(r2)
10101bdc:	10000926 	beq	r2,zero,10101c04 <alt_dev_llist_insert+0x40>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10101be0:	deffff04 	addi	sp,sp,-4
10101be4:	dfc00015 	stw	ra,0(sp)
10101be8:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101bec:	00c00584 	movi	r3,22
10101bf0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101bf4:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101bf8:	dfc00017 	ldw	ra,0(sp)
10101bfc:	dec00104 	addi	sp,sp,4
10101c00:	f800283a 	ret
10101c04:	00840434 	movhi	r2,4112
10101c08:	108da204 	addi	r2,r2,13960
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101c0c:	00c00584 	movi	r3,22
10101c10:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101c14:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101c18:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
10101c1c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10101c20:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
10101c24:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
10101c28:	28800017 	ldw	r2,0(r5)
10101c2c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
10101c30:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
10101c34:	0005883a 	mov	r2,zero
10101c38:	f800283a 	ret

10101c3c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10101c3c:	defffb04 	addi	sp,sp,-20
10101c40:	dcc00315 	stw	r19,12(sp)
10101c44:	dc800215 	stw	r18,8(sp)
10101c48:	dc400115 	stw	r17,4(sp)
10101c4c:	dc000015 	stw	r16,0(sp)
10101c50:	dfc00415 	stw	ra,16(sp)
10101c54:	2027883a 	mov	r19,r4
10101c58:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
10101c5c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
10101c60:	0101d2c0 	call	10101d2c <strlen>
10101c64:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10101c68:	84400726 	beq	r16,r17,10101c88 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10101c6c:	81000217 	ldw	r4,8(r16)
10101c70:	980b883a 	mov	r5,r19
10101c74:	900d883a 	mov	r6,r18
10101c78:	0101cfc0 	call	10101cfc <memcmp>
10101c7c:	10000426 	beq	r2,zero,10101c90 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
10101c80:	84000017 	ldw	r16,0(r16)
10101c84:	003ff806 	br	10101c68 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
10101c88:	0005883a 	mov	r2,zero
10101c8c:	00000106 	br	10101c94 <alt_find_dev+0x58>
10101c90:	8005883a 	mov	r2,r16
}
10101c94:	dfc00417 	ldw	ra,16(sp)
10101c98:	dcc00317 	ldw	r19,12(sp)
10101c9c:	dc800217 	ldw	r18,8(sp)
10101ca0:	dc400117 	ldw	r17,4(sp)
10101ca4:	dc000017 	ldw	r16,0(sp)
10101ca8:	dec00504 	addi	sp,sp,20
10101cac:	f800283a 	ret

10101cb0 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
10101cb0:	0009883a 	mov	r4,zero
10101cb4:	01440004 	movi	r5,4096
10101cb8:	0101cc41 	jmpi	10101cc4 <alt_icache_flush>

10101cbc <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10101cbc:	000170fa 	wrctl	ienable,zero
10101cc0:	f800283a 	ret

10101cc4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
10101cc4:	00840004 	movi	r2,4096
10101cc8:	1140012e 	bgeu	r2,r5,10101cd0 <alt_icache_flush+0xc>
10101ccc:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
10101cd0:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101cd4:	2005883a 	mov	r2,r4
10101cd8:	1140032e 	bgeu	r2,r5,10101ce8 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
10101cdc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101ce0:	10800804 	addi	r2,r2,32
10101ce4:	003ffc06 	br	10101cd8 <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10101ce8:	210007cc 	andi	r4,r4,31
10101cec:	20000126 	beq	r4,zero,10101cf4 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
10101cf0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
10101cf4:	0000203a 	flushp
10101cf8:	f800283a 	ret

10101cfc <memcmp>:
10101cfc:	218d883a 	add	r6,r4,r6
10101d00:	21800826 	beq	r4,r6,10101d24 <memcmp+0x28>
10101d04:	20800003 	ldbu	r2,0(r4)
10101d08:	28c00003 	ldbu	r3,0(r5)
10101d0c:	10c00226 	beq	r2,r3,10101d18 <memcmp+0x1c>
10101d10:	10c5c83a 	sub	r2,r2,r3
10101d14:	f800283a 	ret
10101d18:	21000044 	addi	r4,r4,1
10101d1c:	29400044 	addi	r5,r5,1
10101d20:	003ff706 	br	10101d00 <memcmp+0x4>
10101d24:	0005883a 	mov	r2,zero
10101d28:	f800283a 	ret

10101d2c <strlen>:
10101d2c:	2005883a 	mov	r2,r4
10101d30:	10c00007 	ldb	r3,0(r2)
10101d34:	18000226 	beq	r3,zero,10101d40 <strlen+0x14>
10101d38:	10800044 	addi	r2,r2,1
10101d3c:	003ffc06 	br	10101d30 <strlen+0x4>
10101d40:	1105c83a 	sub	r2,r2,r4
10101d44:	f800283a 	ret
