
VGA_Display_Gen1.elf:     file format elf32-littlenios2
VGA_Display_Gen1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10100150

Program Header:
    LOAD off    0x00001000 vaddr 0x10100000 paddr 0x10100000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10100020 paddr 0x10100020 align 2**12
         filesz 0x00002154 memsz 0x00002154 flags r-x
    LOAD off    0x00003174 vaddr 0x10102174 paddr 0x101021e8 align 2**12
         filesz 0x00000074 memsz 0x00000074 flags rw-
    LOAD off    0x0000325c vaddr 0x1010225c paddr 0x1010225c align 2**12
         filesz 0x00000000 memsz 0x00000194 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10100000  10100000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000130  10100020  10100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001bec  10100150  10100150  00001150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000438  10101d3c  10101d3c  00002d3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000074  10102174  101021e8  00003174  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000194  1010225c  1010225c  0000325c  2**4
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  101023f0  101023f0  000031e8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000031e8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000400  00000000  00000000  00003210  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000052e4  00000000  00000000  00003610  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001b39  00000000  00000000  000088f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000207c  00000000  00000000  0000a42d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000848  00000000  00000000  0000c4ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000184f  00000000  00000000  0000ccf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000225c  00000000  00000000  0000e543  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  000107a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000208  00000000  00000000  00010800  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000126cf  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  000126d2  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000126de  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000126df  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  000126e0  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  000126eb  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  000126f6  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000006  00000000  00000000  00012701  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002c  00000000  00000000  00012707  2**0
                  CONTENTS, READONLY
 26 .jdi          00003cd3  00000000  00000000  00012733  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     002a0b2b  00000000  00000000  00016406  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10100000 l    d  .entry	00000000 .entry
10100020 l    d  .exceptions	00000000 .exceptions
10100150 l    d  .text	00000000 .text
10101d3c l    d  .rodata	00000000 .rodata
10102174 l    d  .rwdata	00000000 .rwdata
1010225c l    d  .bss	00000000 .bss
101023f0 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 /home/pokitoz/Dropbox/DE0_SoC_VGA/sw/nios/application/VGA_Display_Gen1_bsp//obj/HAL/src/crt0.o
10100198 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
10100094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 VGA_DMA_display.c
10101d94 l     O .rodata	00000060 msgdma.2777
00000000 l    df *ABS*	00000000 VGA_Display.c
00000000 l    df *ABS*	00000000 msgDMA.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
1010070c l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
10102174 l     O .rwdata	00000060 msgdma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_msgdma.c
10100cdc l     F .text	000000cc alt_msgdma_irq
10100da8 l     F .text	00000068 alt_msgdma_write_extended_descriptor
10100e10 l     F .text	00000230 alt_msgdma_descriptor_sync_transfer
10101040 l     F .text	00000190 alt_msgdma_descriptor_async_transfer
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
10101b00 g     F .text	00000008 alt_msgdma_standard_descriptor_async_transfer
10100a5c g     F .text	0000002c alt_main
101022f0 g     O .bss	00000100 alt_irq
101021e8 g       *ABS*	00000000 __flash_rwdata_start
10101240 g     F .text	0000003c alt_msgdma_construct_standard_mm_to_mm_descriptor
101005d8 g     F .text	00000134 msgdma_create_mm_to_st_descriptor_list
10102264 g     O .bss	00000004 descriptor_number
101011d0 g     F .text	00000038 alt_msgdma_construct_standard_st_to_mm_descriptor
10100c3c g     F .text	00000038 alt_putstr
00000000  w      *UND*	00000000 __errno
10100000 g     F .entry	0000001c __reset
10100020 g       *ABS*	00000000 __flash_exceptions_start
10102278 g     O .bss	00000004 errno
10102270 g     O .bss	00000004 alt_argv
1010a1d4 g       *ABS*	00000000 _gp
1010178c g     F .text	00000048 alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
10101c30 g     F .text	00000074 alt_find_dev
10100838 g     F .text	00000028 memcpy
10101948 g     F .text	0000006c alt_msgdma_start_prefetcher_with_extd_desc_list
10101b08 g     F .text	0000000c alt_msgdma_extended_descriptor_async_transfer
10101af0 g     F .text	00000010 alt_msgdma_register_callback
101016a4 g     F .text	00000050 alt_msgdma_prefetcher_add_standard_desc_to_list
10100000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
10100828 g     F .text	00000008 .hidden __udivsi3
1010225c g     O .bss	00000004 next_desc
10101cb8 g     F .text	00000038 alt_icache_flush
10101448 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
101023f0 g       *ABS*	00000000 __bss_end
101008fc g     F .text	00000068 alt_iic_isr_register
10101a0c g     F .text	000000e4 alt_msgdma_init
10101b1c g     F .text	0000000c alt_msgdma_extended_descriptor_sync_transfer
101008e4 g     F .text	00000018 alt_ic_irq_enabled
10102268 g     O .bss	00000004 alt_irq_active
101000ec g     F .exceptions	00000064 alt_irq_handler
101012f4 g     F .text	00000078 alt_msgdma_construct_extended_mm_to_st_descriptor
101018dc g     F .text	0000006c alt_msgdma_start_prefetcher_with_std_desc_list
10101ba0 g     F .text	00000018 alt_dcache_flush_all
101021e8 g       *ABS*	00000000 __ram_rwdata_end
10102174 g       *ABS*	00000000 __ram_rodata_end
101021d8 g     O .rwdata	00000004 jtag_uart_0
10100310 g     F .text	0000002c VGA_Display_changeSyncHorizontal
10100830 g     F .text	00000008 .hidden __umodsi3
10101490 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
101023f0 g       *ABS*	00000000 end
101002e4 g     F .text	0000002c VGA_Display_changeSyncVertical
10104000 g       *ABS*	00000000 __alt_stack_pointer
10100ca8 g     F .text	00000034 altera_avalon_jtag_uart_write
10100a88 g     F .text	0000016c alt_printf
10100150 g     F .text	0000004c _start
10101208 g     F .text	00000038 alt_msgdma_construct_standard_mm_to_st_descriptor
10100c94 g     F .text	00000014 alt_sys_init
10100344 g     F .text	00000040 VGA_Display_set_irq
10102174 g       *ABS*	00000000 __ram_rwdata_start
10101d3c g       *ABS*	00000000 __ram_rodata_start
10102280 g     O .bss	00000060 msgdma_dev
101022e0 g     O .bss	00000010 msgdma_desc
10101b28 g     F .text	00000078 alt_busy_sleep
101013fc g     F .text	0000004c alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
10101cf0 g     F .text	00000030 memcmp
101023f0 g       *ABS*	00000000 __alt_stack_base
101014d8 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
10101bb8 g     F .text	00000078 alt_dev_llist_insert
1010225c g       *ABS*	00000000 __bss_start
101019b4 g     F .text	00000058 alt_msgdma_open
10100208 g     F .text	000000dc main
1010226c g     O .bss	00000004 alt_envp
101016f4 g     F .text	00000064 alt_msgdma_prefetcher_add_extended_desc_to_list
101017d4 g     F .text	00000108 alt_msgdma_start_prefetcher_with_list_addr
101021e4 g     O .rwdata	00000004 alt_errno
101015f8 g     F .text	000000ac alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
10100778 g     F .text	00000054 .hidden __divsi3
10101d3c g       *ABS*	00000000 __flash_rodata_start
10100c74 g     F .text	00000020 alt_irq_init
10101b14 g     F .text	00000008 alt_msgdma_standard_descriptor_sync_transfer
10101568 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
10102274 g     O .bss	00000004 alt_argc
1010019c g     F .text	0000006c irq_vsync
10100020 g       .exceptions	00000000 alt_irq_entry
10100020 g       *ABS*	00000000 __ram_exceptions_start
10100860 g     F .text	00000004 alt_ic_isr_register
101021e8 g       *ABS*	00000000 _edata
101023f0 g       *ABS*	00000000 _end
10100150 g       *ABS*	00000000 __ram_exceptions_end
101008a4 g     F .text	00000040 alt_ic_irq_disable
1010033c g     F .text	00000008 VGA_Display_changeScreenColor
10101cb0 g     F .text	00000008 altera_nios2_qsys_irq_init
10101758 g     F .text	00000034 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
101007cc g     F .text	0000005c .hidden __modsi3
10104000 g       *ABS*	00000000 __alt_data_end
10100020 g     F .exceptions	00000000 alt_exception
10100384 g     F .text	000000f4 msgdma_transfer
1010136c g     F .text	00000090 alt_msgdma_construct_extended_mm_to_mm_descriptor
1010127c g     F .text	00000078 alt_msgdma_construct_extended_st_to_mm_descriptor
1010001c g       .entry	00000000 _exit
101021dc g     O .rwdata	00000008 alt_msgdma_list
10101d20 g     F .text	0000001c strlen
10100bf4 g     F .text	00000048 alt_putchar
10102260 g     O .bss	00000004 vsync
10101ca4 g     F .text	0000000c alt_icache_flush_all
101021d4 g     O .rwdata	00000004 alt_priority_mask
10100864 g     F .text	00000040 alt_ic_irq_enable
10100478 g     F .text	00000160 msgdma_create_mm_to_mm_descriptor_list
10100964 g     F .text	000000f8 alt_load



Disassembly of section .entry:

10100000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10100000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10100004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10100008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1010000c:	00bffd16 	blt	zero,r2,10100004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10100010:	00440434 	movhi	at,4112
    ori r1, r1, %lo(_start)
10100014:	08405414 	ori	at,at,336
    jmp r1
10100018:	0800683a 	jmp	at

1010001c <_exit>:
1010001c:	00000000 	call	10000000 <__alt_mem_onchip_memory2_0-0x100000>

Disassembly of section .exceptions:

10100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
10100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
10100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
10100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1010002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1010003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
10100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
10100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1010004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1010005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1010006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1010007c:	10000326 	beq	r2,zero,1010008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10100080:	20000226 	beq	r4,zero,1010008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10100084:	01000ec0 	call	101000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10100088:	00000306 	br	10100098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1010008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10100090:	e8bfff17 	ldw	r2,-4(ea)

10100094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10100094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10100098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1010009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
101000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
101000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
101000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
101000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
101000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
101000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
101000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
101000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
101000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
101000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
101000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
101000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
101000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
101000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
101000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
101000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
101000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
101000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
101000e8:	ef80083a 	eret

101000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
101000ec:	defffe04 	addi	sp,sp,-8
101000f0:	dfc00115 	stw	ra,4(sp)
101000f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
101000f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
101000fc:	04040434 	movhi	r16,4112
10100100:	8408bc04 	addi	r16,r16,8944

  active = alt_irq_pending ();

  do
  {
    i = 0;
10100104:	0005883a 	mov	r2,zero
    mask = 1;
10100108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
1010010c:	190a703a 	and	r5,r3,r4
10100110:	28000c26 	beq	r5,zero,10100144 <alt_irq_handler+0x58>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10100114:	100490fa 	slli	r2,r2,3
10100118:	8087883a 	add	r3,r16,r2
1010011c:	1805883a 	mov	r2,r3
10100120:	11000117 	ldw	r4,4(r2)
10100124:	18c00017 	ldw	r3,0(r3)
10100128:	183ee83a 	callr	r3
1010012c:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10100130:	203ff41e 	bne	r4,zero,10100104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
10100134:	dfc00117 	ldw	ra,4(sp)
10100138:	dc000017 	ldw	r16,0(sp)
1010013c:	dec00204 	addi	sp,sp,8
10100140:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10100144:	18c7883a 	add	r3,r3,r3
      i++;
10100148:	10800044 	addi	r2,r2,1

    } while (1);
1010014c:	003fef06 	br	1010010c <alt_irq_handler+0x20>

Disassembly of section .text:

10100150 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10100150:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
10100154:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
10100158:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
1010015c:	00bffd16 	blt	zero,r2,10100154 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10100160:	06c40434 	movhi	sp,4112
    ori sp, sp, %lo(__alt_stack_pointer)
10100164:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
10100168:	06840434 	movhi	gp,4112
    ori gp, gp, %lo(_gp)
1010016c:	d6a87514 	ori	gp,gp,41428
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
10100170:	00840434 	movhi	r2,4112
    ori r2, r2, %lo(__bss_start)
10100174:	10889714 	ori	r2,r2,8796

    movhi r3, %hi(__bss_end)
10100178:	00c40434 	movhi	r3,4112
    ori r3, r3, %lo(__bss_end)
1010017c:	18c8fc14 	ori	r3,r3,9200

    beq r2, r3, 1f
10100180:	10c00326 	beq	r2,r3,10100190 <_start+0x40>

0:
    stw zero, (r2)
10100184:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
10100188:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
1010018c:	10fffd36 	bltu	r2,r3,10100184 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
10100190:	01009640 	call	10100964 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
10100194:	0100a5c0 	call	10100a5c <alt_main>

10100198 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
10100198:	003fff06 	br	10100198 <alt_after_alt_main>

1010019c <irq_vsync>:

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
1010019c:	defffe04 	addi	sp,sp,-8
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
101001a0:	01040434 	movhi	r4,4112
101001a4:	01440434 	movhi	r5,4112
101001a8:	d8000015 	stw	zero,0(sp)
101001ac:	2108a004 	addi	r4,r4,8832
101001b0:	2948b804 	addi	r5,r5,8928
101001b4:	01900004 	movi	r6,16384
101001b8:	01c0a004 	movi	r7,640

alt_msgdma_standard_descriptor msgdma_desc;
alt_msgdma_dev msgdma_dev;
alt_u32 descriptor_number;

void irq_vsync(void* context, alt_u32 id) {
101001bc:	dfc00115 	stw	ra,4(sp)
	// Total is 640 x 480 x 24 = 7372800 bytes
	// Need 7372800 / N  descriptors..
	// Send one descriptor at a time
	// Generate on the fly

	alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
101001c0:	01012080 	call	10101208 <alt_msgdma_construct_standard_mm_to_st_descriptor>
			&msgdma_desc, VGA_DISPLAY_ADDRESS_DST_IMAGE, 640, 0);

	next_desc++;
101001c4:	d0a02217 	ldw	r2,-32632(gp)
101001c8:	10800044 	addi	r2,r2,1
101001cc:	d0a02215 	stw	r2,-32632(gp)
	vsync++;
101001d0:	d0a02317 	ldw	r2,-32628(gp)
101001d4:	10800044 	addi	r2,r2,1
101001d8:	d0a02315 	stw	r2,-32628(gp)
	if (next_desc == descriptor_number) {
101001dc:	d0e02217 	ldw	r3,-32632(gp)
101001e0:	d0a02417 	ldw	r2,-32624(gp)
101001e4:	1880011e 	bne	r3,r2,101001ec <irq_vsync+0x50>
		next_desc = 0;
101001e8:	d0202215 	stw	zero,-32632(gp)
	}

	//alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);

	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_CLEAN_IRQ_REG, 0x1);
101001ec:	00840034 	movhi	r2,4096
101001f0:	10821704 	addi	r2,r2,2140
101001f4:	00c00044 	movi	r3,1
101001f8:	10c00035 	stwio	r3,0(r2)

}
101001fc:	dfc00117 	ldw	ra,4(sp)
10100200:	dec00204 	addi	sp,sp,8
10100204:	f800283a 	ret

10100208 <main>:

int main(void) {

	alt_putstr("Hello from VGA_DMA project!\n");
10100208:	01040434 	movhi	r4,4112
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
1010020c:	defffc04 	addi	sp,sp,-16

	alt_putstr("Hello from VGA_DMA project!\n");
10100210:	21074f04 	addi	r4,r4,7484
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
10100214:	dfc00315 	stw	ra,12(sp)
10100218:	dc000215 	stw	r16,8(sp)

	alt_putstr("Hello from VGA_DMA project!\n");
1010021c:	0100c3c0 	call	10100c3c <alt_putstr>

	VGA_Display_changeScreenColor(VGA_MODULE_0_BASE, 0x00FF00FF);
10100220:	01040034 	movhi	r4,4096
10100224:	01403ff4 	movhi	r5,255
10100228:	21021004 	addi	r4,r4,2112
1010022c:	29403fc4 	addi	r5,r5,255
10100230:	010033c0 	call	1010033c <VGA_Display_changeScreenColor>

	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CONFIGURATION, 0x0);
10100234:	00840034 	movhi	r2,4096
10100238:	10821104 	addi	r2,r2,2116
1010023c:	10000035 	stwio	zero,0(r2)

	ALTERA_MSGDMA_CSR_DESCRIPTOR_SLAVE_INSTANCE(MSGDMA_0, MSGDMA_0_CSR,
			MSGDMA_0_DESCRIPTOR_SLAVE, msgdma);

	msgdma_dev = msgdma;
10100240:	01040434 	movhi	r4,4112
10100244:	01440434 	movhi	r5,4112
10100248:	2108a004 	addi	r4,r4,8832
1010024c:	29476504 	addi	r5,r5,7572
10100250:	01801804 	movi	r6,96
10100254:	01008380 	call	10100838 <memcpy>
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID,
10100258:	01040434 	movhi	r4,4112
1010025c:	2108a004 	addi	r4,r4,8832
10100260:	000b883a 	mov	r5,zero
10100264:	01800044 	movi	r6,1
10100268:	0101a0c0 	call	10101a0c <alt_msgdma_init>
	MSGDMA_0_CSR_IRQ);

	alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
1010026c:	01840434 	movhi	r6,4112
10100270:	0009883a 	mov	r4,zero
10100274:	000b883a 	mov	r5,zero
10100278:	31806704 	addi	r6,r6,412
1010027c:	000f883a 	mov	r7,zero
10100280:	d8000015 	stw	zero,0(sp)
10100284:	01008600 	call	10100860 <alt_ic_isr_register>
	VGA_MODULE_0_IRQ, (void*) irq_vsync, 0, 0);

	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100288:	0009883a 	mov	r4,zero
1010028c:	000b883a 	mov	r5,zero
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
10100290:	040003f4 	movhi	r16,15

	alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
	VGA_MODULE_0_IRQ, (void*) irq_vsync, 0, 0);

	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100294:	01008640 	call	10100864 <alt_ic_irq_enable>
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
10100298:	84108fc4 	addi	r16,r16,16959
	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
	VGA_MODULE_0_IRQ);


	volatile int kk = 0;
1010029c:	d8000115 	stw	zero,4(sp)
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", next_desc);
101002a0:	d1602217 	ldw	r5,-32632(gp)
101002a4:	01040434 	movhi	r4,4112
101002a8:	21075704 	addi	r4,r4,7516
101002ac:	0100a880 	call	10100a88 <alt_printf>
		//usleep(100000);
		for(kk = 0; kk < 1000000; kk++){
101002b0:	d8000115 	stw	zero,4(sp)
101002b4:	d8800117 	ldw	r2,4(sp)
101002b8:	80800416 	blt	r16,r2,101002cc <main+0xc4>
101002bc:	d8800117 	ldw	r2,4(sp)
101002c0:	10800044 	addi	r2,r2,1
101002c4:	d8800115 	stw	r2,4(sp)
101002c8:	003ffa06 	br	101002b4 <main+0xac>
		}
		alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);
101002cc:	01040434 	movhi	r4,4112
101002d0:	01440434 	movhi	r5,4112
101002d4:	2108a004 	addi	r4,r4,8832
101002d8:	2948b804 	addi	r5,r5,8928
101002dc:	0101b000 	call	10101b00 <alt_msgdma_standard_descriptor_async_transfer>

	}
101002e0:	003fef06 	br	101002a0 <main+0x98>

101002e4 <VGA_Display_changeSyncVertical>:
#include "sys/alt_irq.h"

void VGA_Display_changeSyncVertical(alt_u32 BASE, alt_u16 visible_area, alt_u16 front_porch,
		alt_u16 sync_pulse, alt_u16 back_porch) {

	alt_u32 concatenated = front_porch | (sync_pulse << 8) | (back_porch << 16);
101002e4:	d880000b 	ldhu	r2,0(sp)
101002e8:	39ffffcc 	andi	r7,r7,65535
101002ec:	380e923a 	slli	r7,r7,8
101002f0:	1004943a 	slli	r2,r2,16
101002f4:	31bfffcc 	andi	r6,r6,65535
101002f8:	31ccb03a 	or	r6,r6,r7
101002fc:	308cb03a 	or	r6,r6,r2
	IOWR_32DIRECT(BASE, VGA_DISPLAY_SYNC_V_REG, concatenated);
10100300:	21800235 	stwio	r6,8(r4)
	IOWR_32DIRECT(BASE, VGA_DISPLAY_VISIBLE_AREA_V_REG, visible_area);
10100304:	297fffcc 	andi	r5,r5,65535
10100308:	21400435 	stwio	r5,16(r4)
1010030c:	f800283a 	ret

10100310 <VGA_Display_changeSyncHorizontal>:
}

void VGA_Display_changeSyncHorizontal(alt_u32 BASE, alt_u16 visible_area,
		alt_u16 front_porch, alt_u16 sync_pulse, alt_u16 back_porch) {

	alt_u32 concatenated = front_porch | (sync_pulse << 8) | (back_porch << 16);
10100310:	d880000b 	ldhu	r2,0(sp)
10100314:	39ffffcc 	andi	r7,r7,65535
10100318:	380e923a 	slli	r7,r7,8
1010031c:	1004943a 	slli	r2,r2,16
10100320:	31bfffcc 	andi	r6,r6,65535
10100324:	31ccb03a 	or	r6,r6,r7
10100328:	308cb03a 	or	r6,r6,r2
	IOWR_32DIRECT(BASE, VGA_DISPLAY_SYNC_H_REG, concatenated);
1010032c:	21800335 	stwio	r6,12(r4)
	IOWR_32DIRECT(BASE, VGA_DISPLAY_VISIBLE_AREA_H_REG, visible_area);
10100330:	297fffcc 	andi	r5,r5,65535
10100334:	21400535 	stwio	r5,20(r4)
10100338:	f800283a 	ret

1010033c <VGA_Display_changeScreenColor>:

}

void VGA_Display_changeScreenColor(alt_u32 BASE, alt_u32 color) {
	IOWR_32DIRECT(BASE, VGA_DISPLAY_COLOR_REG, color);
1010033c:	21400035 	stwio	r5,0(r4)
10100340:	f800283a 	ret

10100344 <VGA_Display_set_irq>:
}

void VGA_Display_set_irq(void (*irq_handler)(void*, alt_u32)) {
10100344:	defffd04 	addi	sp,sp,-12
10100348:	dfc00215 	stw	ra,8(sp)
1010034c:	d9000115 	stw	r4,4(sp)

	if (irq_handler != NULL) {
10100350:	20000926 	beq	r4,zero,10100378 <VGA_Display_set_irq+0x34>
		// Register the ISR for sync
		alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100354:	0009883a 	mov	r4,zero
10100358:	000b883a 	mov	r5,zero
1010035c:	d8000015 	stw	zero,0(sp)
10100360:	d9800104 	addi	r6,sp,4
10100364:	000f883a 	mov	r7,zero
10100368:	01008600 	call	10100860 <alt_ic_isr_register>
				VGA_MODULE_0_IRQ, (void*) &irq_handler, 0, 0);

		// Enable the interrupts
		alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
1010036c:	0009883a 	mov	r4,zero
10100370:	000b883a 	mov	r5,zero
10100374:	01008640 	call	10100864 <alt_ic_irq_enable>
				VGA_MODULE_0_IRQ);
	}

}
10100378:	dfc00217 	ldw	ra,8(sp)
1010037c:	dec00304 	addi	sp,sp,12
10100380:	f800283a 	ret

10100384 <msgdma_transfer>:
#include "msgDMA.h"
#include <stdint-gcc.h>
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {
10100384:	defffa04 	addi	sp,sp,-24
10100388:	dd000415 	stw	r20,16(sp)
1010038c:	dcc00315 	stw	r19,12(sp)
10100390:	dc800215 	stw	r18,8(sp)
10100394:	dc400115 	stw	r17,4(sp)
10100398:	dc000015 	stw	r16,0(sp)
1010039c:	dfc00515 	stw	ra,20(sp)
101003a0:	2027883a 	mov	r19,r4
101003a4:	2829883a 	mov	r20,r5
101003a8:	3025883a 	mov	r18,r6

	unsigned int i = 0;
	unsigned int error_dma = 0;
101003ac:	0021883a 	mov	r16,zero
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {

	unsigned int i = 0;
101003b0:	0023883a 	mov	r17,zero
	unsigned int error_dma = 0;

	while (i < descriptor_number) {
101003b4:	8c80282e 	bgeu	r17,r18,10100458 <msgdma_transfer+0xd4>

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);
101003b8:	8804913a 	slli	r2,r17,4

	while (i < descriptor_number) {

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
101003bc:	9809883a 	mov	r4,r19
101003c0:	a08b883a 	add	r5,r20,r2
101003c4:	0101b000 	call	10101b00 <alt_msgdma_standard_descriptor_async_transfer>
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
101003c8:	00fff904 	movi	r3,-28
101003cc:	10c0041e 	bne	r2,r3,101003e0 <msgdma_transfer+0x5c>
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003d0:	01040434 	movhi	r4,4112

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
			error_dma++;
101003d4:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101003d8:	21077d04 	addi	r4,r4,7668
101003dc:	00000506 	br	101003f4 <msgdma_transfer+0x70>
		} else if (result == -ETIME) {
101003e0:	00fff084 	movi	r3,-62
101003e4:	10c0051e 	bne	r2,r3,101003fc <msgdma_transfer+0x78>
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003e8:	01040434 	movhi	r4,4112

		if ((result == -ENOSPC)) {
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
101003ec:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101003f0:	21078804 	addi	r4,r4,7712
101003f4:	0100a880 	call	10100a88 <alt_printf>
101003f8:	00000b06 	br	10100428 <msgdma_transfer+0xa4>
		} else if (result == -EPERM) {
101003fc:	00ffffc4 	movi	r3,-1
10100400:	10c0041e 	bne	r2,r3,10100414 <msgdma_transfer+0x90>
			error_dma++;
			alt_printf(
10100404:	01040434 	movhi	r4,4112
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
		} else if (result == -EPERM) {
			error_dma++;
10100408:	84000044 	addi	r16,r16,1
			alt_printf(
1010040c:	21079404 	addi	r4,r4,7760
10100410:	003ff806 	br	101003f4 <msgdma_transfer+0x70>
					"msgdma_transfer dma_mm_interface_read: operation not permitted due to descriptor type conflict\n");
		} else {
			i++;
10100414:	8c400044 	addi	r17,r17,1
			alt_printf(
10100418:	01040434 	movhi	r4,4112
1010041c:	2107ac04 	addi	r4,r4,7856
10100420:	880b883a 	mov	r5,r17
10100424:	0100a880 	call	10100a88 <alt_printf>
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
10100428:	00801904 	movi	r2,100
1010042c:	80bfe11e 	bne	r16,r2,101003b4 <msgdma_transfer+0x30>
			alt_printf("Error DMA exceeded\n");
10100430:	01040434 	movhi	r4,4112
10100434:	2107bf04 	addi	r4,r4,7932
		}

	}

	//alt_printf("Transfer successful\n");
}
10100438:	dfc00517 	ldw	ra,20(sp)
1010043c:	dd000417 	ldw	r20,16(sp)
10100440:	dcc00317 	ldw	r19,12(sp)
10100444:	dc800217 	ldw	r18,8(sp)
10100448:	dc400117 	ldw	r17,4(sp)
1010044c:	dc000017 	ldw	r16,0(sp)
10100450:	dec00604 	addi	sp,sp,24
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
			alt_printf("Error DMA exceeded\n");
10100454:	0100a881 	jmpi	10100a88 <alt_printf>
		}

	}

	//alt_printf("Transfer successful\n");
}
10100458:	dfc00517 	ldw	ra,20(sp)
1010045c:	dd000417 	ldw	r20,16(sp)
10100460:	dcc00317 	ldw	r19,12(sp)
10100464:	dc800217 	ldw	r18,8(sp)
10100468:	dc400117 	ldw	r17,4(sp)
1010046c:	dc000017 	ldw	r16,0(sp)
10100470:	dec00604 	addi	sp,sp,24
10100474:	f800283a 	ret

10100478 <msgdma_create_mm_to_mm_descriptor_list>:

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100478:	defff204 	addi	sp,sp,-56
1010047c:	dc000415 	stw	r16,16(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100480:	d8800e17 	ldw	r2,56(sp)
uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
10100484:	24001217 	ldw	r16,72(r4)
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
10100488:	dd800a15 	stw	r22,40(sp)
1010048c:	dd400915 	stw	r21,36(sp)
10100490:	202d883a 	mov	r22,r4
10100494:	282b883a 	mov	r21,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100498:	113fffc4 	addi	r4,r2,-1
1010049c:	800b883a 	mov	r5,r16
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
101004a0:	df000c15 	stw	fp,48(sp)
101004a4:	dcc00715 	stw	r19,28(sp)
101004a8:	dfc00d15 	stw	ra,52(sp)
101004ac:	ddc00b15 	stw	r23,44(sp)
101004b0:	dd000815 	stw	r20,32(sp)
101004b4:	dc800615 	stw	r18,24(sp)
101004b8:	dc400515 	stw	r17,20(sp)
101004bc:	3027883a 	mov	r19,r6
101004c0:	d9c00315 	stw	r7,12(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101004c4:	01008280 	call	10100828 <__udivsi3>
101004c8:	1039883a 	mov	fp,r2
101004cc:	10800044 	addi	r2,r2,1
101004d0:	d8800215 	stw	r2,8(sp)

	if (msgdma_desc == NULL) {
101004d4:	a800051e 	bne	r21,zero,101004ec <msgdma_create_mm_to_mm_descriptor_list+0x74>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
101004d8:	01040434 	movhi	r4,4112
101004dc:	2107c404 	addi	r4,r4,7952
101004e0:	0100a880 	call	10100a88 <alt_printf>
		return 0;
101004e4:	0005883a 	mov	r2,zero
101004e8:	00002f06 	br	101005a8 <msgdma_create_mm_to_mm_descriptor_list+0x130>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
101004ec:	d9800217 	ldw	r6,8(sp)
101004f0:	01040434 	movhi	r4,4112
101004f4:	2107d104 	addi	r4,r4,8004
101004f8:	800b883a 	mov	r5,r16
101004fc:	0100a880 	call	10100a88 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;
10100500:	dc800317 	ldw	r18,12(sp)
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100504:	9823883a 	mov	r17,r19
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100508:	0029883a 	mov	r20,zero
1010050c:	a02e913a 	slli	r23,r20,4
10100510:	a7001126 	beq	r20,fp,10100558 <msgdma_create_mm_to_mm_descriptor_list+0xe0>
		alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100514:	01040434 	movhi	r4,4112
10100518:	a00b883a 	mov	r5,r20
1010051c:	880d883a 	mov	r6,r17
10100520:	900f883a 	mov	r7,r18
10100524:	2107de04 	addi	r4,r4,8056
10100528:	0100a880 	call	10100a88 <alt_printf>
				_address_dst_descriptor);

		alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma,
1010052c:	880d883a 	mov	r6,r17
10100530:	900f883a 	mov	r7,r18
10100534:	dc000015 	stw	r16,0(sp)
10100538:	d8000115 	stw	zero,4(sp)
1010053c:	b009883a 	mov	r4,r22
10100540:	adcb883a 	add	r5,r21,r23
10100544:	01012400 	call	10101240 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor,
				(uint32_t *) _address_dst_descriptor, max_descriptor_size, 0);
		_address_dst_descriptor += max_descriptor_size;
10100548:	9425883a 	add	r18,r18,r16
		_address_src_descriptor += max_descriptor_size;
1010054c:	8c23883a 	add	r17,r17,r16

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100550:	a5000044 	addi	r20,r20,1
10100554:	003fed06 	br	1010050c <msgdma_create_mm_to_mm_descriptor_list+0x94>
10100558:	a421383a 	mul	r16,r20,r16
1010055c:	d8800317 	ldw	r2,12(sp)
		_address_dst_descriptor += max_descriptor_size;
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100560:	01040434 	movhi	r4,4112
10100564:	9c27883a 	add	r19,r19,r16
10100568:	1425883a 	add	r18,r2,r16
1010056c:	2107de04 	addi	r4,r4,8056
10100570:	a00b883a 	mov	r5,r20
10100574:	980d883a 	mov	r6,r19
10100578:	900f883a 	mov	r7,r18
1010057c:	0100a880 	call	10100a88 <alt_printf>
			_address_dst_descriptor);
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma, msgdma_desc + i,
10100580:	d8800e17 	ldw	r2,56(sp)
10100584:	d8000115 	stw	zero,4(sp)
10100588:	b009883a 	mov	r4,r22
1010058c:	1421c83a 	sub	r16,r2,r16
10100590:	dc000015 	stw	r16,0(sp)
10100594:	adcb883a 	add	r5,r21,r23
10100598:	980d883a 	mov	r6,r19
1010059c:	900f883a 	mov	r7,r18
101005a0:	01012400 	call	10101240 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
			(uint32_t *) _address_src_descriptor,
			(uint32_t *) _address_dst_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101005a4:	d8800217 	ldw	r2,8(sp)
}
101005a8:	dfc00d17 	ldw	ra,52(sp)
101005ac:	df000c17 	ldw	fp,48(sp)
101005b0:	ddc00b17 	ldw	r23,44(sp)
101005b4:	dd800a17 	ldw	r22,40(sp)
101005b8:	dd400917 	ldw	r21,36(sp)
101005bc:	dd000817 	ldw	r20,32(sp)
101005c0:	dcc00717 	ldw	r19,28(sp)
101005c4:	dc800617 	ldw	r18,24(sp)
101005c8:	dc400517 	ldw	r17,20(sp)
101005cc:	dc000417 	ldw	r16,16(sp)
101005d0:	dec00e04 	addi	sp,sp,56
101005d4:	f800283a 	ret

101005d8 <msgdma_create_mm_to_st_descriptor_list>:



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005d8:	defff404 	addi	sp,sp,-48
101005dc:	dc000215 	stw	r16,8(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
101005e0:	24001217 	ldw	r16,72(r4)



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005e4:	dd400715 	stw	r21,28(sp)
101005e8:	dd000615 	stw	r20,24(sp)
101005ec:	202b883a 	mov	r21,r4
101005f0:	2829883a 	mov	r20,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101005f4:	393fffc4 	addi	r4,r7,-1
101005f8:	800b883a 	mov	r5,r16



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101005fc:	df000a15 	stw	fp,40(sp)
10100600:	dd800815 	stw	r22,32(sp)
10100604:	dcc00515 	stw	r19,20(sp)
10100608:	dfc00b15 	stw	ra,44(sp)
1010060c:	ddc00915 	stw	r23,36(sp)
10100610:	dc800415 	stw	r18,16(sp)
10100614:	dc400315 	stw	r17,12(sp)
10100618:	3027883a 	mov	r19,r6
1010061c:	382d883a 	mov	r22,r7

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100620:	01008280 	call	10100828 <__udivsi3>
10100624:	1039883a 	mov	fp,r2
10100628:	10800044 	addi	r2,r2,1
1010062c:	d8800115 	stw	r2,4(sp)

	if (msgdma_desc == NULL) {
10100630:	a000051e 	bne	r20,zero,10100648 <msgdma_create_mm_to_st_descriptor_list+0x70>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
10100634:	01040434 	movhi	r4,4112
10100638:	2107c404 	addi	r4,r4,7952
1010063c:	0100a880 	call	10100a88 <alt_printf>
		return 0;
10100640:	0005883a 	mov	r2,zero
10100644:	00002506 	br	101006dc <msgdma_create_mm_to_st_descriptor_list+0x104>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
10100648:	d9800117 	ldw	r6,4(sp)
1010064c:	01040434 	movhi	r4,4112
10100650:	2107d104 	addi	r4,r4,8004
10100654:	800b883a 	mov	r5,r16
10100658:	0100a880 	call	10100a88 <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
1010065c:	9825883a 	mov	r18,r19

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100660:	0023883a 	mov	r17,zero
10100664:	882e913a 	slli	r23,r17,4
10100668:	8f000e26 	beq	r17,fp,101006a4 <msgdma_create_mm_to_st_descriptor_list+0xcc>
		alt_printf("i=%d, src=0x%x\n", i, _address_src_descriptor);
1010066c:	01040434 	movhi	r4,4112
10100670:	880b883a 	mov	r5,r17
10100674:	900d883a 	mov	r6,r18
10100678:	2107e504 	addi	r4,r4,8084
1010067c:	0100a880 	call	10100a88 <alt_printf>

		alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma,
10100680:	900d883a 	mov	r6,r18
10100684:	d8000015 	stw	zero,0(sp)
10100688:	a809883a 	mov	r4,r21
1010068c:	a5cb883a 	add	r5,r20,r23
10100690:	800f883a 	mov	r7,r16
10100694:	01012080 	call	10101208 <alt_msgdma_construct_standard_mm_to_st_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;
10100698:	9425883a 	add	r18,r18,r16
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010069c:	8c400044 	addi	r17,r17,1
101006a0:	003ff006 	br	10100664 <msgdma_create_mm_to_st_descriptor_list+0x8c>
101006a4:	8c21383a 	mul	r16,r17,r16
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor);
101006a8:	01040434 	movhi	r4,4112
101006ac:	2107de04 	addi	r4,r4,8056
101006b0:	9c27883a 	add	r19,r19,r16
101006b4:	880b883a 	mov	r5,r17
101006b8:	980d883a 	mov	r6,r19
101006bc:	0100a880 	call	10100a88 <alt_printf>
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma, msgdma_desc + i,
101006c0:	a809883a 	mov	r4,r21
101006c4:	d8000015 	stw	zero,0(sp)
101006c8:	a5cb883a 	add	r5,r20,r23
101006cc:	980d883a 	mov	r6,r19
101006d0:	b40fc83a 	sub	r7,r22,r16
101006d4:	01012080 	call	10101208 <alt_msgdma_construct_standard_mm_to_st_descriptor>
			(uint32_t *) _address_src_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101006d8:	d8800117 	ldw	r2,4(sp)
}
101006dc:	dfc00b17 	ldw	ra,44(sp)
101006e0:	df000a17 	ldw	fp,40(sp)
101006e4:	ddc00917 	ldw	r23,36(sp)
101006e8:	dd800817 	ldw	r22,32(sp)
101006ec:	dd400717 	ldw	r21,28(sp)
101006f0:	dd000617 	ldw	r20,24(sp)
101006f4:	dcc00517 	ldw	r19,20(sp)
101006f8:	dc800417 	ldw	r18,16(sp)
101006fc:	dc400317 	ldw	r17,12(sp)
10100700:	dc000217 	ldw	r16,8(sp)
10100704:	dec00c04 	addi	sp,sp,48
10100708:	f800283a 	ret

1010070c <udivmodsi4>:
1010070c:	2900182e 	bgeu	r5,r4,10100770 <udivmodsi4+0x64>
10100710:	28001716 	blt	r5,zero,10100770 <udivmodsi4+0x64>
10100714:	00800804 	movi	r2,32
10100718:	00c00044 	movi	r3,1
1010071c:	00000206 	br	10100728 <udivmodsi4+0x1c>
10100720:	10001126 	beq	r2,zero,10100768 <udivmodsi4+0x5c>
10100724:	28000516 	blt	r5,zero,1010073c <udivmodsi4+0x30>
10100728:	294b883a 	add	r5,r5,r5
1010072c:	10bfffc4 	addi	r2,r2,-1
10100730:	18c7883a 	add	r3,r3,r3
10100734:	293ffa36 	bltu	r5,r4,10100720 <udivmodsi4+0x14>
10100738:	18000b26 	beq	r3,zero,10100768 <udivmodsi4+0x5c>
1010073c:	0005883a 	mov	r2,zero
10100740:	21400236 	bltu	r4,r5,1010074c <udivmodsi4+0x40>
10100744:	2149c83a 	sub	r4,r4,r5
10100748:	10c4b03a 	or	r2,r2,r3
1010074c:	1806d07a 	srli	r3,r3,1
10100750:	280ad07a 	srli	r5,r5,1
10100754:	183ffa1e 	bne	r3,zero,10100740 <udivmodsi4+0x34>
10100758:	3000011e 	bne	r6,zero,10100760 <udivmodsi4+0x54>
1010075c:	f800283a 	ret
10100760:	2005883a 	mov	r2,r4
10100764:	f800283a 	ret
10100768:	0005883a 	mov	r2,zero
1010076c:	003ffa06 	br	10100758 <udivmodsi4+0x4c>
10100770:	00c00044 	movi	r3,1
10100774:	003ff106 	br	1010073c <udivmodsi4+0x30>

10100778 <__divsi3>:
10100778:	defffe04 	addi	sp,sp,-8
1010077c:	dfc00115 	stw	ra,4(sp)
10100780:	dc000015 	stw	r16,0(sp)
10100784:	20000b16 	blt	r4,zero,101007b4 <__divsi3+0x3c>
10100788:	0021883a 	mov	r16,zero
1010078c:	28000c16 	blt	r5,zero,101007c0 <__divsi3+0x48>
10100790:	000d883a 	mov	r6,zero
10100794:	010070c0 	call	1010070c <udivmodsi4>
10100798:	0407c83a 	sub	r3,zero,r16
1010079c:	1884f03a 	xor	r2,r3,r2
101007a0:	1405883a 	add	r2,r2,r16
101007a4:	dfc00117 	ldw	ra,4(sp)
101007a8:	dc000017 	ldw	r16,0(sp)
101007ac:	dec00204 	addi	sp,sp,8
101007b0:	f800283a 	ret
101007b4:	0109c83a 	sub	r4,zero,r4
101007b8:	04000044 	movi	r16,1
101007bc:	283ff40e 	bge	r5,zero,10100790 <__divsi3+0x18>
101007c0:	014bc83a 	sub	r5,zero,r5
101007c4:	8400005c 	xori	r16,r16,1
101007c8:	003ff106 	br	10100790 <__divsi3+0x18>

101007cc <__modsi3>:
101007cc:	defffd04 	addi	sp,sp,-12
101007d0:	dfc00215 	stw	ra,8(sp)
101007d4:	dc400115 	stw	r17,4(sp)
101007d8:	dc000015 	stw	r16,0(sp)
101007dc:	20000c16 	blt	r4,zero,10100810 <__modsi3+0x44>
101007e0:	0023883a 	mov	r17,zero
101007e4:	0021883a 	mov	r16,zero
101007e8:	28000d16 	blt	r5,zero,10100820 <__modsi3+0x54>
101007ec:	01800044 	movi	r6,1
101007f0:	010070c0 	call	1010070c <udivmodsi4>
101007f4:	1404f03a 	xor	r2,r2,r16
101007f8:	8885883a 	add	r2,r17,r2
101007fc:	dfc00217 	ldw	ra,8(sp)
10100800:	dc400117 	ldw	r17,4(sp)
10100804:	dc000017 	ldw	r16,0(sp)
10100808:	dec00304 	addi	sp,sp,12
1010080c:	f800283a 	ret
10100810:	0109c83a 	sub	r4,zero,r4
10100814:	04400044 	movi	r17,1
10100818:	043fffc4 	movi	r16,-1
1010081c:	283ff30e 	bge	r5,zero,101007ec <__modsi3+0x20>
10100820:	014bc83a 	sub	r5,zero,r5
10100824:	003ff106 	br	101007ec <__modsi3+0x20>

10100828 <__udivsi3>:
10100828:	000d883a 	mov	r6,zero
1010082c:	010070c1 	jmpi	1010070c <udivmodsi4>

10100830 <__umodsi3>:
10100830:	01800044 	movi	r6,1
10100834:	010070c1 	jmpi	1010070c <udivmodsi4>

10100838 <memcpy>:
10100838:	2005883a 	mov	r2,r4
1010083c:	0007883a 	mov	r3,zero
10100840:	19800626 	beq	r3,r6,1010085c <memcpy+0x24>
10100844:	28c9883a 	add	r4,r5,r3
10100848:	21c00003 	ldbu	r7,0(r4)
1010084c:	10c9883a 	add	r4,r2,r3
10100850:	18c00044 	addi	r3,r3,1
10100854:	21c00005 	stb	r7,0(r4)
10100858:	003ff906 	br	10100840 <memcpy+0x8>
1010085c:	f800283a 	ret

10100860 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
10100860:	01008fc1 	jmpi	101008fc <alt_iic_isr_register>

10100864 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100864:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100868:	00bfff84 	movi	r2,-2
1010086c:	3084703a 	and	r2,r6,r2
10100870:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
10100874:	00840434 	movhi	r2,4112
10100878:	10889a04 	addi	r2,r2,8808
1010087c:	01000044 	movi	r4,1
10100880:	10c00017 	ldw	r3,0(r2)
10100884:	214a983a 	sll	r5,r4,r5
10100888:	28cab03a 	or	r5,r5,r3
1010088c:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
10100890:	10800017 	ldw	r2,0(r2)
10100894:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100898:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
1010089c:	0005883a 	mov	r2,zero
101008a0:	f800283a 	ret

101008a4 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101008a4:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101008a8:	00bfff84 	movi	r2,-2
101008ac:	3084703a 	and	r2,r6,r2
101008b0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
101008b4:	00840434 	movhi	r2,4112
101008b8:	10889a04 	addi	r2,r2,8808
101008bc:	013fff84 	movi	r4,-2
101008c0:	10c00017 	ldw	r3,0(r2)
101008c4:	214a183a 	rol	r5,r4,r5
101008c8:	28ca703a 	and	r5,r5,r3
101008cc:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
101008d0:	10800017 	ldw	r2,0(r2)
101008d4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101008d8:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
101008dc:	0005883a 	mov	r2,zero
101008e0:	f800283a 	ret

101008e4 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
101008e4:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
101008e8:	00c00044 	movi	r3,1
101008ec:	194a983a 	sll	r5,r3,r5
101008f0:	1144703a 	and	r2,r2,r5
}
101008f4:	1004c03a 	cmpne	r2,r2,zero
101008f8:	f800283a 	ret

101008fc <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
101008fc:	00c007c4 	movi	r3,31
10100900:	19401616 	blt	r3,r5,1010095c <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
10100904:	defffe04 	addi	sp,sp,-8
10100908:	dfc00115 	stw	ra,4(sp)
1010090c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100910:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100914:	00ffff84 	movi	r3,-2
10100918:	80c6703a 	and	r3,r16,r3
1010091c:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
10100920:	280490fa 	slli	r2,r5,3
10100924:	00c40434 	movhi	r3,4112
10100928:	18c8bc04 	addi	r3,r3,8944
1010092c:	1891883a 	add	r8,r3,r2
10100930:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
10100934:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
10100938:	30000226 	beq	r6,zero,10100944 <alt_iic_isr_register+0x48>
1010093c:	01008640 	call	10100864 <alt_ic_irq_enable>
10100940:	00000106 	br	10100948 <alt_iic_isr_register+0x4c>
10100944:	01008a40 	call	101008a4 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100948:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
1010094c:	dfc00117 	ldw	ra,4(sp)
10100950:	dc000017 	ldw	r16,0(sp)
10100954:	dec00204 	addi	sp,sp,8
10100958:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
1010095c:	00bffa84 	movi	r2,-22
10100960:	f800283a 	ret

10100964 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
10100964:	deffff04 	addi	sp,sp,-4
10100968:	01040434 	movhi	r4,4112
1010096c:	01440434 	movhi	r5,4112
10100970:	dfc00015 	stw	ra,0(sp)
10100974:	21085d04 	addi	r4,r4,8564
10100978:	29487a04 	addi	r5,r5,8680

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
1010097c:	2140061e 	bne	r4,r5,10100998 <alt_load+0x34>
10100980:	01040434 	movhi	r4,4112
10100984:	01440434 	movhi	r5,4112
10100988:	21000804 	addi	r4,r4,32
1010098c:	29400804 	addi	r5,r5,32
10100990:	2140141e 	bne	r4,r5,101009e4 <alt_load+0x80>
10100994:	00000d06 	br	101009cc <alt_load+0x68>
10100998:	00c40434 	movhi	r3,4112
1010099c:	18c87a04 	addi	r3,r3,8680
101009a0:	00bfff04 	movi	r2,-4
101009a4:	1907c83a 	sub	r3,r3,r4
101009a8:	1886703a 	and	r3,r3,r2
101009ac:	0005883a 	mov	r2,zero
  {
    while( to != end )
101009b0:	10fff326 	beq	r2,r3,10100980 <alt_load+0x1c>
101009b4:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
101009b8:	39c00017 	ldw	r7,0(r7)
101009bc:	110d883a 	add	r6,r2,r4
101009c0:	10800104 	addi	r2,r2,4
101009c4:	31c00015 	stw	r7,0(r6)
101009c8:	003ff906 	br	101009b0 <alt_load+0x4c>
101009cc:	01040434 	movhi	r4,4112
101009d0:	01440434 	movhi	r5,4112
101009d4:	21074f04 	addi	r4,r4,7484
101009d8:	29474f04 	addi	r5,r5,7484

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
101009dc:	2140121e 	bne	r4,r5,10100a28 <alt_load+0xc4>
101009e0:	00000d06 	br	10100a18 <alt_load+0xb4>
101009e4:	00c40434 	movhi	r3,4112
101009e8:	18c05404 	addi	r3,r3,336
101009ec:	00bfff04 	movi	r2,-4
101009f0:	1907c83a 	sub	r3,r3,r4
101009f4:	1886703a 	and	r3,r3,r2
101009f8:	0005883a 	mov	r2,zero
  {
    while( to != end )
101009fc:	10fff326 	beq	r2,r3,101009cc <alt_load+0x68>
10100a00:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100a04:	39c00017 	ldw	r7,0(r7)
10100a08:	110d883a 	add	r6,r2,r4
10100a0c:	10800104 	addi	r2,r2,4
10100a10:	31c00015 	stw	r7,0(r6)
10100a14:	003ff906 	br	101009fc <alt_load+0x98>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10100a18:	0101ba00 	call	10101ba0 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10100a1c:	dfc00017 	ldw	ra,0(sp)
10100a20:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
10100a24:	0101ca41 	jmpi	10101ca4 <alt_icache_flush_all>
10100a28:	00c40434 	movhi	r3,4112
10100a2c:	18c85d04 	addi	r3,r3,8564
10100a30:	00bfff04 	movi	r2,-4
10100a34:	1907c83a 	sub	r3,r3,r4
10100a38:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100a3c:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100a40:	10fff526 	beq	r2,r3,10100a18 <alt_load+0xb4>
10100a44:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100a48:	39c00017 	ldw	r7,0(r7)
10100a4c:	110d883a 	add	r6,r2,r4
10100a50:	10800104 	addi	r2,r2,4
10100a54:	31c00015 	stw	r7,0(r6)
10100a58:	003ff906 	br	10100a40 <alt_load+0xdc>

10100a5c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a5c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a60:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100a64:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100a68:	0100c740 	call	10100c74 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10100a6c:	0100c940 	call	10100c94 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a70:	d1202817 	ldw	r4,-32608(gp)
10100a74:	d1602717 	ldw	r5,-32612(gp)
10100a78:	d1a02617 	ldw	r6,-32616(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
10100a7c:	dfc00017 	ldw	ra,0(sp)
10100a80:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100a84:	01002081 	jmpi	10100208 <main>

10100a88 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100a88:	defff204 	addi	sp,sp,-56
10100a8c:	dfc00a15 	stw	ra,40(sp)
10100a90:	df000915 	stw	fp,36(sp)
10100a94:	ddc00815 	stw	r23,32(sp)
10100a98:	dd800715 	stw	r22,28(sp)
10100a9c:	dd400615 	stw	r21,24(sp)
10100aa0:	dd000515 	stw	r20,20(sp)
10100aa4:	dcc00415 	stw	r19,16(sp)
10100aa8:	dc800315 	stw	r18,12(sp)
10100aac:	dc400215 	stw	r17,8(sp)
10100ab0:	dc000115 	stw	r16,4(sp)
10100ab4:	d9400b15 	stw	r5,44(sp)
10100ab8:	d9800c15 	stw	r6,48(sp)
10100abc:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100ac0:	04000944 	movi	r16,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100ac4:	2005883a 	mov	r2,r4
	va_list args;
	va_start(args, fmt);
10100ac8:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
10100acc:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
10100ad0:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100ad4:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100ad8:	11000007 	ldb	r4,0(r2)
10100adc:	20003926 	beq	r4,zero,10100bc4 <alt_printf+0x13c>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100ae0:	24000226 	beq	r4,r16,10100aec <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100ae4:	14400044 	addi	r17,r2,1
10100ae8:	00001106 	br	10100b30 <alt_printf+0xa8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
10100aec:	14400084 	addi	r17,r2,2
10100af0:	10800047 	ldb	r2,1(r2)
10100af4:	10003326 	beq	r2,zero,10100bc4 <alt_printf+0x13c>
            {
                if (c == '%')
10100af8:	1400021e 	bne	r2,r16,10100b04 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
10100afc:	8009883a 	mov	r4,r16
10100b00:	00000b06 	br	10100b30 <alt_printf+0xa8>
                } 
                else if (c == 'c')
10100b04:	1480051e 	bne	r2,r18,10100b1c <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
10100b08:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100b0c:	ad800104 	addi	r22,r21,4
10100b10:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
10100b14:	0100bf40 	call	10100bf4 <alt_putchar>
10100b18:	00002806 	br	10100bbc <alt_printf+0x134>
                }
                else if (c == 'x')
10100b1c:	14c01f1e 	bne	r2,r19,10100b9c <alt_printf+0x114>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
10100b20:	adc00017 	ldw	r23,0(r21)
10100b24:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
10100b28:	b800031e 	bne	r23,zero,10100b38 <alt_printf+0xb0>
                    {
                        alt_putchar('0');
10100b2c:	01000c04 	movi	r4,48
10100b30:	0100bf40 	call	10100bf4 <alt_putchar>
                        continue;
10100b34:	00002106 	br	10100bbc <alt_printf+0x134>
10100b38:	05800704 	movi	r22,28
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
10100b3c:	00c003c4 	movi	r3,15
10100b40:	1d84983a 	sll	r2,r3,r22
10100b44:	15c4703a 	and	r2,r2,r23
10100b48:	1000021e 	bne	r2,zero,10100b54 <alt_printf+0xcc>
                        digit_shift -= 4;
10100b4c:	b5bfff04 	addi	r22,r22,-4
10100b50:	003ffb06 	br	10100b40 <alt_printf+0xb8>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b54:	070003c4 	movi	fp,15
                        if (digit <= 9)
10100b58:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b5c:	b0001716 	blt	r22,zero,10100bbc <alt_printf+0x134>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100b60:	e584983a 	sll	r2,fp,r22
10100b64:	15c4703a 	and	r2,r2,r23
10100b68:	1584d83a 	srl	r2,r2,r22
                        if (digit <= 9)
10100b6c:	18800236 	bltu	r3,r2,10100b78 <alt_printf+0xf0>
                            c = '0' + digit;
10100b70:	11000c04 	addi	r4,r2,48
10100b74:	00000106 	br	10100b7c <alt_printf+0xf4>
                        else
                            c = 'a' + digit - 10;
10100b78:	110015c4 	addi	r4,r2,87
                        alt_putchar(c);
10100b7c:	21003fcc 	andi	r4,r4,255
10100b80:	2100201c 	xori	r4,r4,128
10100b84:	213fe004 	addi	r4,r4,-128
10100b88:	d8c00015 	stw	r3,0(sp)
10100b8c:	0100bf40 	call	10100bf4 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100b90:	b5bfff04 	addi	r22,r22,-4
10100b94:	d8c00017 	ldw	r3,0(sp)
10100b98:	003ff006 	br	10100b5c <alt_printf+0xd4>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100b9c:	1500071e 	bne	r2,r20,10100bbc <alt_printf+0x134>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
10100ba0:	ad800017 	ldw	r22,0(r21)
10100ba4:	ad400104 	addi	r21,r21,4

                    while(*s)
10100ba8:	b1000007 	ldb	r4,0(r22)
10100bac:	20000326 	beq	r4,zero,10100bbc <alt_printf+0x134>
                      alt_putchar(*s++);
10100bb0:	b5800044 	addi	r22,r22,1
10100bb4:	0100bf40 	call	10100bf4 <alt_putchar>
10100bb8:	003ffb06 	br	10100ba8 <alt_printf+0x120>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100bbc:	8805883a 	mov	r2,r17
10100bc0:	003fc506 	br	10100ad8 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
10100bc4:	dfc00a17 	ldw	ra,40(sp)
10100bc8:	df000917 	ldw	fp,36(sp)
10100bcc:	ddc00817 	ldw	r23,32(sp)
10100bd0:	dd800717 	ldw	r22,28(sp)
10100bd4:	dd400617 	ldw	r21,24(sp)
10100bd8:	dd000517 	ldw	r20,20(sp)
10100bdc:	dcc00417 	ldw	r19,16(sp)
10100be0:	dc800317 	ldw	r18,12(sp)
10100be4:	dc400217 	ldw	r17,8(sp)
10100be8:	dc000117 	ldw	r16,4(sp)
10100bec:	dec00e04 	addi	sp,sp,56
10100bf0:	f800283a 	ret

10100bf4 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100bf4:	defffd04 	addi	sp,sp,-12
10100bf8:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
10100bfc:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c00:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100c04:	01040434 	movhi	r4,4112
10100c08:	21087604 	addi	r4,r4,8664
10100c0c:	d80b883a 	mov	r5,sp
10100c10:	01800044 	movi	r6,1
10100c14:	000f883a 	mov	r7,zero
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100c18:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100c1c:	0100ca80 	call	10100ca8 <altera_avalon_jtag_uart_write>
10100c20:	00ffffc4 	movi	r3,-1
10100c24:	10c00126 	beq	r2,r3,10100c2c <alt_putchar+0x38>
        return -1;
    }
    return c;
10100c28:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
10100c2c:	dfc00217 	ldw	ra,8(sp)
10100c30:	dc000117 	ldw	r16,4(sp)
10100c34:	dec00304 	addi	sp,sp,12
10100c38:	f800283a 	ret

10100c3c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
10100c3c:	defffe04 	addi	sp,sp,-8
10100c40:	dc000015 	stw	r16,0(sp)
10100c44:	dfc00115 	stw	ra,4(sp)
10100c48:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c4c:	0101d200 	call	10101d20 <strlen>
10100c50:	01040434 	movhi	r4,4112
10100c54:	21087604 	addi	r4,r4,8664
10100c58:	800b883a 	mov	r5,r16
10100c5c:	100d883a 	mov	r6,r2
10100c60:	000f883a 	mov	r7,zero
#else
    return fputs(str, stdout);
#endif
#endif
}
10100c64:	dfc00117 	ldw	ra,4(sp)
10100c68:	dc000017 	ldw	r16,0(sp)
10100c6c:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100c70:	0100ca81 	jmpi	10100ca8 <altera_avalon_jtag_uart_write>

10100c74 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10100c74:	deffff04 	addi	sp,sp,-4
10100c78:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
10100c7c:	0101cb00 	call	10101cb0 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10100c80:	00800044 	movi	r2,1
10100c84:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10100c88:	dfc00017 	ldw	ra,0(sp)
10100c8c:	dec00104 	addi	sp,sp,4
10100c90:	f800283a 	ret

10100c94 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_MSGDMA_INIT ( MSGDMA_0, msgdma_0);
10100c94:	01040434 	movhi	r4,4112
10100c98:	21085d04 	addi	r4,r4,8564
10100c9c:	21400717 	ldw	r5,28(r4)
10100ca0:	21800817 	ldw	r6,32(r4)
10100ca4:	0101a0c1 	jmpi	10101a0c <alt_msgdma_init>

10100ca8 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10100ca8:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10100cac:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
10100cb0:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100cb4:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10100cb8:	2980072e 	bgeu	r5,r6,10100cd8 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100cbc:	38c00037 	ldwio	r3,0(r7)
10100cc0:	18ffffec 	andhi	r3,r3,65535
10100cc4:	183ffc26 	beq	r3,zero,10100cb8 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10100cc8:	28c00007 	ldb	r3,0(r5)
10100ccc:	20c00035 	stwio	r3,0(r4)
10100cd0:	29400044 	addi	r5,r5,1
10100cd4:	003ff806 	br	10100cb8 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
10100cd8:	f800283a 	ret

10100cdc <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100cdc:	defffd04 	addi	sp,sp,-12
10100ce0:	dc000015 	stw	r16,0(sp)
10100ce4:	dfc00215 	stw	ra,8(sp)
10100ce8:	dc400115 	stw	r17,4(sp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100cec:	20801783 	ldbu	r2,94(r4)
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100cf0:	2021883a 	mov	r16,r4
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100cf4:	10000926 	beq	r2,zero,10100d1c <alt_msgdma_irq+0x40>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100cf8:	20c00617 	ldw	r3,24(r4)
10100cfc:	19000037 	ldwio	r4,0(r3)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
10100d00:	00bffdc4 	movi	r2,-9
10100d04:	2084703a 	and	r2,r4,r2
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100d08:	18800035 	stwio	r2,0(r3)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
10100d0c:	80800617 	ldw	r2,24(r16)
10100d10:	00c00044 	movi	r3,1
10100d14:	10c00435 	stwio	r3,16(r2)
10100d18:	00000906 	br	10100d40 <alt_msgdma_irq+0x64>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10100d1c:	20800317 	ldw	r2,12(r4)
10100d20:	10800104 	addi	r2,r2,4
10100d24:	11000037 	ldwio	r4,0(r2)
10100d28:	00fffbc4 	movi	r3,-17
10100d2c:	20c6703a 	and	r3,r4,r3
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d30:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
10100d34:	80800317 	ldw	r2,12(r16)
10100d38:	00c08004 	movi	r3,512
10100d3c:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
10100d40:	80c00b17 	ldw	r3,44(r16)
10100d44:	18000726 	beq	r3,zero,10100d64 <alt_msgdma_irq+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100d48:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100d4c:	00bfff84 	movi	r2,-2
10100d50:	8884703a 	and	r2,r17,r2
10100d54:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        dev->callback (dev->callback_context);
10100d58:	81000c17 	ldw	r4,48(r16)
10100d5c:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100d60:	8801703a 	wrctl	status,r17
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
10100d64:	80801783 	ldbu	r2,94(r16)
10100d68:	10000526 	beq	r2,zero,10100d80 <alt_msgdma_irq+0xa4>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100d6c:	80c00617 	ldw	r3,24(r16)
10100d70:	18800037 	ldwio	r2,0(r3)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10100d74:	10800214 	ori	r2,r2,8
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100d78:	18800035 	stwio	r2,0(r3)
10100d7c:	00000506 	br	10100d94 <alt_msgdma_irq+0xb8>
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
10100d80:	80800317 	ldw	r2,12(r16)
10100d84:	10800104 	addi	r2,r2,4
10100d88:	10c00037 	ldwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
10100d8c:	18c00414 	ori	r3,r3,16
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100d90:	10c00035 	stwio	r3,0(r2)
    }

    return;
}
10100d94:	dfc00217 	ldw	ra,8(sp)
10100d98:	dc400117 	ldw	r17,4(sp)
10100d9c:	dc000017 	ldw	r16,0(sp)
10100da0:	dec00304 	addi	sp,sp,12
10100da4:	f800283a 	ret

10100da8 <alt_msgdma_write_extended_descriptor>:
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100da8:	20800037 	ldwio	r2,0(r4)
10100dac:	1080010c 	andi	r2,r2,4
10100db0:	1000151e 	bne	r2,zero,10100e08 <alt_msgdma_write_extended_descriptor+0x60>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
10100db4:	30c00017 	ldw	r3,0(r6)
10100db8:	28c00035 	stwio	r3,0(r5)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
10100dbc:	30c00117 	ldw	r3,4(r6)
10100dc0:	28c00135 	stwio	r3,4(r5)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
10100dc4:	30c00217 	ldw	r3,8(r6)
10100dc8:	28c00235 	stwio	r3,8(r5)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
10100dcc:	30c0030b 	ldhu	r3,12(r6)
10100dd0:	28c0032d 	sthio	r3,12(r5)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
10100dd4:	30c00383 	ldbu	r3,14(r6)
10100dd8:	28c003a5 	stbio	r3,14(r5)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
10100ddc:	30c003c3 	ldbu	r3,15(r6)
10100de0:	28c003e5 	stbio	r3,15(r5)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
10100de4:	30c0040b 	ldhu	r3,16(r6)
10100de8:	28c0042d 	sthio	r3,16(r5)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
10100dec:	30c0048b 	ldhu	r3,18(r6)
10100df0:	28c004ad 	sthio	r3,18(r5)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
10100df4:	28000535 	stwio	zero,20(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
10100df8:	28000635 	stwio	zero,24(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
10100dfc:	30c00717 	ldw	r3,28(r6)
10100e00:	28c00735 	stwio	r3,28(r5)
		descriptor_base, 
    	descriptor->control);
    return 0;
10100e04:	f800283a 	ret
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
10100e08:	00bff904 	movi	r2,-28
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
		descriptor_base, 
    	descriptor->control);
    return 0;
}
10100e0c:	f800283a 	ret

10100e10 <alt_msgdma_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e10:	20c00317 	ldw	r3,12(r4)
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e14:	defffb04 	addi	sp,sp,-20
10100e18:	dc800215 	stw	r18,8(sp)
10100e1c:	dc400115 	stw	r17,4(sp)
10100e20:	dc000015 	stw	r16,0(sp)
10100e24:	2823883a 	mov	r17,r5
10100e28:	2021883a 	mov	r16,r4
10100e2c:	3025883a 	mov	r18,r6
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e30:	18c00204 	addi	r3,r3,8
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100e34:	dfc00415 	stw	ra,16(sp)
10100e38:	dcc00315 	stw	r19,12(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e3c:	18800037 	ldwio	r2,0(r3)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10100e40:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e44:	18c00037 	ldwio	r3,0(r3)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e48:	04c4e244 	movi	r19,5001
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10100e4c:	1806d43a 	srli	r3,r3,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e50:	81000917 	ldw	r4,36(r16)
10100e54:	19001036 	bltu	r3,r4,10100e98 <alt_msgdma_descriptor_sync_transfer+0x88>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
10100e58:	01000044 	movi	r4,1
10100e5c:	0101b280 	call	10101b28 <alt_busy_sleep>
10100e60:	98bfffc4 	addi	r2,r19,-1
10100e64:	1027883a 	mov	r19,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100e68:	10bfffcc 	andi	r2,r2,65535
10100e6c:	1000031e 	bne	r2,zero,10100e7c <alt_msgdma_descriptor_sync_transfer+0x6c>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
10100e70:	01040434 	movhi	r4,4112
10100e74:	2107e904 	addi	r4,r4,8100
10100e78:	00004806 	br	10100f9c <alt_msgdma_descriptor_sync_transfer+0x18c>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e7c:	80c00317 	ldw	r3,12(r16)
10100e80:	18c00204 	addi	r3,r3,8
10100e84:	18800037 	ldwio	r2,0(r3)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
10100e88:	10bfffcc 	andi	r2,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100e8c:	18c00037 	ldwio	r3,0(r3)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
10100e90:	1806d43a 	srli	r3,r3,16
10100e94:	003fee06 	br	10100e50 <alt_msgdma_descriptor_sync_transfer+0x40>
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100e98:	113fef2e 	bgeu	r2,r4,10100e58 <alt_msgdma_descriptor_sync_transfer+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100e9c:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100ea0:	00bfff84 	movi	r2,-2
10100ea4:	9884703a 	and	r2,r19,r2
10100ea8:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100eac:	80800317 	ldw	r2,12(r16)
10100eb0:	00c00804 	movi	r3,32
10100eb4:	10c00135 	stwio	r3,4(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10100eb8:	80800317 	ldw	r2,12(r16)
10100ebc:	10c00037 	ldwio	r3,0(r2)
10100ec0:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
10100ec4:	88001026 	beq	r17,zero,10100f08 <alt_msgdma_descriptor_sync_transfer+0xf8>
10100ec8:	9000101e 	bne	r18,zero,10100f0c <alt_msgdma_descriptor_sync_transfer+0xfc>
10100ecc:	0484e244 	movi	r18,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
10100ed0:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100ed4:	80c00317 	ldw	r3,12(r16)
10100ed8:	18c00037 	ldwio	r3,0(r3)
10100edc:	18c0010c 	andi	r3,r3,4
10100ee0:	1800261e 	bne	r3,zero,10100f7c <alt_msgdma_descriptor_sync_transfer+0x16c>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
10100ee4:	88c00017 	ldw	r3,0(r17)
10100ee8:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
10100eec:	88c00117 	ldw	r3,4(r17)
10100ef0:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
10100ef4:	88c00217 	ldw	r3,8(r17)
10100ef8:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
10100efc:	88c00317 	ldw	r3,12(r17)
10100f00:	10c00335 	stwio	r3,12(r2)
10100f04:	00001206 	br	10100f50 <alt_msgdma_descriptor_sync_transfer+0x140>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
10100f08:	9000021e 	bne	r18,zero,10100f14 <alt_msgdma_descriptor_sync_transfer+0x104>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10100f0c:	00bfffc4 	movi	r2,-1
10100f10:	00004406 	br	10101024 <alt_msgdma_descriptor_sync_transfer+0x214>
10100f14:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
10100f18:	81000317 	ldw	r4,12(r16)
10100f1c:	81400417 	ldw	r5,16(r16)
10100f20:	900d883a 	mov	r6,r18
10100f24:	0100da80 	call	10100da8 <alt_msgdma_write_extended_descriptor>
10100f28:	10000926 	beq	r2,zero,10100f50 <alt_msgdma_descriptor_sync_transfer+0x140>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10100f2c:	01000044 	movi	r4,1
10100f30:	0101b280 	call	10101b28 <alt_busy_sleep>
10100f34:	88bfffc4 	addi	r2,r17,-1
10100f38:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f3c:	10bfffcc 	andi	r2,r2,65535
10100f40:	103ff51e 	bne	r2,zero,10100f18 <alt_msgdma_descriptor_sync_transfer+0x108>
            {
                alt_printf("time out after 5 msec while writing extended" 
10100f44:	01040434 	movhi	r4,4112
10100f48:	21080e04 	addi	r4,r4,8248
10100f4c:	00001306 	br	10100f9c <alt_msgdma_descriptor_sync_transfer+0x18c>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100f50:	81000d17 	ldw	r4,52(r16)
10100f54:	80c00317 	ldw	r3,12(r16)
10100f58:	00bff2c4 	movi	r2,-53
10100f5c:	2084703a 	and	r2,r4,r2
10100f60:	10800114 	ori	r2,r2,4
10100f64:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100f68:	9801703a 	wrctl	status,r19
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100f6c:	80800317 	ldw	r2,12(r16)
10100f70:	10800037 	ldwio	r2,0(r2)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100f74:	0444e244 	movi	r17,5001
10100f78:	00000d06 	br	10100fb0 <alt_msgdma_descriptor_sync_transfer+0x1a0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
10100f7c:	01000044 	movi	r4,1
10100f80:	0101b280 	call	10101b28 <alt_busy_sleep>
10100f84:	90bfffc4 	addi	r2,r18,-1
10100f88:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f8c:	10bfffcc 	andi	r2,r2,65535
10100f90:	103fcf1e 	bne	r2,zero,10100ed0 <alt_msgdma_descriptor_sync_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while writing standard" 
10100f94:	01040434 	movhi	r4,4112
10100f98:	2107fd04 	addi	r4,r4,8180
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100f9c:	0100a880 	call	10100a88 <alt_printf>
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
10100fa0:	00bff084 	movi	r2,-62
10100fa4:	00001f06 	br	10101024 <alt_msgdma_descriptor_sync_transfer+0x214>
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10100fa8:	80800317 	ldw	r2,12(r16)
10100fac:	10800037 	ldwio	r2,0(r2)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10100fb0:	10c0780c 	andi	r3,r2,480
10100fb4:	18000b1e 	bne	r3,zero,10100fe4 <alt_msgdma_descriptor_sync_transfer+0x1d4>
10100fb8:	1080004c 	andi	r2,r2,1
10100fbc:	10000b26 	beq	r2,zero,10100fec <alt_msgdma_descriptor_sync_transfer+0x1dc>
    {
        alt_busy_sleep(1); /* delay 1us */
10100fc0:	01000044 	movi	r4,1
10100fc4:	0101b280 	call	10101b28 <alt_busy_sleep>
10100fc8:	88bfffc4 	addi	r2,r17,-1
10100fcc:	1023883a 	mov	r17,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100fd0:	10bfffcc 	andi	r2,r2,65535
10100fd4:	103ff41e 	bne	r2,zero,10100fa8 <alt_msgdma_descriptor_sync_transfer+0x198>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
10100fd8:	01040434 	movhi	r4,4112
10100fdc:	21081f04 	addi	r4,r4,8316
10100fe0:	003fee06 	br	10100f9c <alt_msgdma_descriptor_sync_transfer+0x18c>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
10100fe4:	00807804 	movi	r2,480
10100fe8:	00000e06 	br	10101024 <alt_msgdma_descriptor_sync_transfer+0x214>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
10100fec:	80800317 	ldw	r2,12(r16)
10100ff0:	10800104 	addi	r2,r2,4
10100ff4:	10c00037 	ldwio	r3,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100ff8:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100ffc:	013fff84 	movi	r4,-2
10101000:	2908703a 	and	r4,r5,r4
10101004:	2001703a 	wrctl	status,r4
10101008:	18c00814 	ori	r3,r3,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
1010100c:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10101010:	80800317 	ldw	r2,12(r16)
10101014:	10c00037 	ldwio	r3,0(r2)
10101018:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1010101c:	2801703a 	wrctl	status,r5
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101020:	0005883a 	mov	r2,zero

}
10101024:	dfc00417 	ldw	ra,16(sp)
10101028:	dcc00317 	ldw	r19,12(sp)
1010102c:	dc800217 	ldw	r18,8(sp)
10101030:	dc400117 	ldw	r17,4(sp)
10101034:	dc000017 	ldw	r16,0(sp)
10101038:	dec00504 	addi	sp,sp,20
1010103c:	f800283a 	ret

10101040 <alt_msgdma_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10101040:	21c00317 	ldw	r7,12(r4)
10101044:	38c00204 	addi	r3,r7,8
10101048:	18800037 	ldwio	r2,0(r3)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
1010104c:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10101050:	18c00037 	ldwio	r3,0(r3)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101054:	22000917 	ldw	r8,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10101058:	1806d43a 	srli	r3,r3,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
1010105c:	1a004b2e 	bgeu	r3,r8,1010118c <alt_msgdma_descriptor_async_transfer+0x14c>
10101060:	12004a2e 	bgeu	r2,r8,1010118c <alt_msgdma_descriptor_async_transfer+0x14c>
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10101064:	defffc04 	addi	sp,sp,-16
10101068:	dc800215 	stw	r18,8(sp)
1010106c:	dc400115 	stw	r17,4(sp)
10101070:	dc000015 	stw	r16,0(sp)
10101074:	3025883a 	mov	r18,r6
10101078:	2823883a 	mov	r17,r5
1010107c:	2021883a 	mov	r16,r4
10101080:	dfc00315 	stw	ra,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101084:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101088:	00bfff84 	movi	r2,-2
1010108c:	1884703a 	and	r2,r3,r2
10101090:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101094:	00800804 	movi	r2,32
10101098:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
1010109c:	20800317 	ldw	r2,12(r4)
101010a0:	11000037 	ldwio	r4,0(r2)
101010a4:	11000035 	stwio	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101010a8:	1801703a 	wrctl	status,r3
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
101010ac:	28001026 	beq	r5,zero,101010f0 <alt_msgdma_descriptor_async_transfer+0xb0>
101010b0:	3000101e 	bne	r6,zero,101010f4 <alt_msgdma_descriptor_async_transfer+0xb4>
101010b4:	0484e244 	movi	r18,5001
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
101010b8:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
101010bc:	80c00317 	ldw	r3,12(r16)
101010c0:	18c00037 	ldwio	r3,0(r3)
101010c4:	18c0010c 	andi	r3,r3,4
101010c8:	1800321e 	bne	r3,zero,10101194 <alt_msgdma_descriptor_async_transfer+0x154>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
101010cc:	88c00017 	ldw	r3,0(r17)
101010d0:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
101010d4:	88c00117 	ldw	r3,4(r17)
101010d8:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
101010dc:	88c00217 	ldw	r3,8(r17)
101010e0:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
101010e4:	88c00317 	ldw	r3,12(r17)
101010e8:	10c00335 	stwio	r3,12(r2)
101010ec:	00001406 	br	10101140 <alt_msgdma_descriptor_async_transfer+0x100>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
101010f0:	3000021e 	bne	r6,zero,101010fc <alt_msgdma_descriptor_async_transfer+0xbc>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
101010f4:	00bfffc4 	movi	r2,-1
101010f8:	00002f06 	br	101011b8 <alt_msgdma_descriptor_async_transfer+0x178>
101010fc:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
10101100:	81000317 	ldw	r4,12(r16)
10101104:	81400417 	ldw	r5,16(r16)
10101108:	900d883a 	mov	r6,r18
1010110c:	0100da80 	call	10100da8 <alt_msgdma_write_extended_descriptor>
10101110:	10000b26 	beq	r2,zero,10101140 <alt_msgdma_descriptor_async_transfer+0x100>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101114:	01000044 	movi	r4,1
10101118:	0101b280 	call	10101b28 <alt_busy_sleep>
1010111c:	88bfffc4 	addi	r2,r17,-1
10101120:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101124:	10bfffcc 	andi	r2,r2,65535
10101128:	103ff51e 	bne	r2,zero,10101100 <alt_msgdma_descriptor_async_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
1010112c:	01040434 	movhi	r4,4112
10101130:	21084704 	addi	r4,r4,8476
10101134:	0100a880 	call	10100a88 <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
10101138:	00bff084 	movi	r2,-62
1010113c:	00001e06 	br	101011b8 <alt_msgdma_descriptor_async_transfer+0x178>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
10101140:	81000b17 	ldw	r4,44(r16)
10101144:	81400317 	ldw	r5,12(r16)
10101148:	00bfff84 	movi	r2,-2
1010114c:	80c00d17 	ldw	r3,52(r16)
10101150:	20000426 	beq	r4,zero,10101164 <alt_msgdma_descriptor_async_transfer+0x124>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101154:	013ff7c4 	movi	r4,-33
10101158:	1906703a 	and	r3,r3,r4
1010115c:	18c00514 	ori	r3,r3,20
10101160:	00000306 	br	10101170 <alt_msgdma_descriptor_async_transfer+0x130>
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
10101164:	013ff3c4 	movi	r4,-49
10101168:	1906703a 	and	r3,r3,r4
1010116c:	18c00114 	ori	r3,r3,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101170:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101174:	2084703a 	and	r2,r4,r2
10101178:	1001703a 	wrctl	status,r2
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
1010117c:	28c00135 	stwio	r3,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101180:	2001703a 	wrctl	status,r4
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101184:	0005883a 	mov	r2,zero
10101188:	00000b06 	br	101011b8 <alt_msgdma_descriptor_async_transfer+0x178>
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
1010118c:	00bff904 	movi	r2,-28
10101190:	f800283a 	ret
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101194:	01000044 	movi	r4,1
10101198:	0101b280 	call	10101b28 <alt_busy_sleep>
1010119c:	90bfffc4 	addi	r2,r18,-1
101011a0:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
101011a4:	10bfffcc 	andi	r2,r2,65535
101011a8:	103fc31e 	bne	r2,zero,101010b8 <alt_msgdma_descriptor_async_transfer+0x78>
            {
                alt_printf("time out after 5 msec while waiting" 
101011ac:	01040434 	movhi	r4,4112
101011b0:	21083104 	addi	r4,r4,8388
101011b4:	003fdf06 	br	10101134 <alt_msgdma_descriptor_async_transfer+0xf4>
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
}
101011b8:	dfc00317 	ldw	ra,12(sp)
101011bc:	dc800217 	ldw	r18,8(sp)
101011c0:	dc400117 	ldw	r17,4(sp)
101011c4:	dc000017 	ldw	r16,0(sp)
101011c8:	dec00404 	addi	sp,sp,16
101011cc:	f800283a 	ret

101011d0 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101011d0:	20801217 	ldw	r2,72(r4)
101011d4:	11c00a36 	bltu	r2,r7,10101200 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
101011d8:	20801703 	ldbu	r2,92(r4)
101011dc:	1000081e 	bne	r2,zero,10101200 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011e0:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101011e4:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
101011e8:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101011ec:	10a00034 	orhi	r2,r2,32768
101011f0:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
101011f4:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101011f8:	0005883a 	mov	r2,zero
101011fc:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101200:	00bffa84 	movi	r2,-22
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
            write_address, length, control);
}
10101204:	f800283a 	ret

10101208 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101208:	20801217 	ldw	r2,72(r4)
1010120c:	11c00a36 	bltu	r2,r7,10101238 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
10101210:	20801703 	ldbu	r2,92(r4)
10101214:	1000081e 	bne	r2,zero,10101238 <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101218:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
1010121c:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101220:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101224:	10a00034 	orhi	r2,r2,32768
10101228:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
1010122c:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101230:	0005883a 	mov	r2,zero
10101234:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101238:	00bffa84 	movi	r2,-22
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            NULL, length, control);

}
1010123c:	f800283a 	ret

10101240 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
10101240:	d8800017 	ldw	r2,0(sp)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101244:	20c01217 	ldw	r3,72(r4)
10101248:	18800a36 	bltu	r3,r2,10101274 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
1010124c:	20c01703 	ldbu	r3,92(r4)
10101250:	1800081e 	bne	r3,zero,10101274 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101254:	28800215 	stw	r2,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101258:	d8800117 	ldw	r2,4(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
1010125c:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101260:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101264:	10a00034 	orhi	r2,r2,32768
10101268:	28800315 	stw	r2,12(r5)
    
    return 0;
1010126c:	0005883a 	mov	r2,zero
10101270:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101274:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            write_address, length, control);
}
10101278:	f800283a 	ret

1010127c <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010127c:	22401217 	ldw	r9,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
10101280:	da000117 	ldw	r8,4(sp)
10101284:	d8c00217 	ldw	r3,8(sp)
10101288:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010128c:	49c01736 	bltu	r9,r7,101012ec <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < read_stride ||
10101290:	22801417 	ldw	r10,80(r4)
       dev->max_stride < write_stride ||
10101294:	127fffcc 	andi	r9,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101298:	5000021e 	bne	r10,zero,101012a4 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x28>
1010129c:	22801317 	ldw	r10,76(r4)
101012a0:	52401236 	bltu	r10,r9,101012ec <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < write_stride ||
101012a4:	22401703 	ldbu	r9,92(r4)
101012a8:	01000044 	movi	r4,1
101012ac:	49000f1e 	bne	r9,r4,101012ec <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101012b0:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012b4:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101012b8:	28000015 	stw	zero,0(r5)
    descriptor->write_address_low = write_address;
101012bc:	29800115 	stw	r6,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012c0:	10a00034 	orhi	r2,r2,32768
101012c4:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101012c8:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
101012cc:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
101012d0:	28000385 	stb	zero,14(r5)
    descriptor->write_burst_count = write_burst_count;
101012d4:	28c003c5 	stb	r3,15(r5)
    descriptor->read_stride = read_stride;
101012d8:	2800040d 	sth	zero,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101012dc:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101012e0:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101012e4:	0005883a 	mov	r2,zero
101012e8:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101012ec:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
101012f0:	f800283a 	ret

101012f4 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101012f4:	22401217 	ldw	r9,72(r4)
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
101012f8:	da000117 	ldw	r8,4(sp)
101012fc:	d8c00217 	ldw	r3,8(sp)
10101300:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101304:	49c01736 	bltu	r9,r7,10101364 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
10101308:	22801417 	ldw	r10,80(r4)
       dev->max_stride < read_stride ||
1010130c:	127fffcc 	andi	r9,r2,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101310:	5000021e 	bne	r10,zero,1010131c <alt_msgdma_construct_extended_mm_to_st_descriptor+0x28>
10101314:	22801317 	ldw	r10,76(r4)
10101318:	52401236 	bltu	r10,r9,10101364 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
1010131c:	22401703 	ldbu	r9,92(r4)
10101320:	01000044 	movi	r4,1
10101324:	49000f1e 	bne	r9,r4,10101364 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101328:	2880040d 	sth	r2,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010132c:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
10101330:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
10101334:	28000115 	stw	zero,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101338:	10a00034 	orhi	r2,r2,32768
1010133c:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
10101340:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
10101344:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
10101348:	28c00385 	stb	r3,14(r5)
    descriptor->write_burst_count = write_burst_count;
1010134c:	280003c5 	stb	zero,15(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101350:	2800048d 	sth	zero,18(r5)
    descriptor->read_address_high = NULL;
10101354:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
10101358:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
1010135c:	0005883a 	mov	r2,zero
10101360:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101364:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
10101368:	f800283a 	ret

1010136c <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
1010136c:	da000017 	ldw	r8,0(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101370:	22401217 	ldw	r9,72(r4)
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101374:	db400217 	ldw	r13,8(sp)
10101378:	db000317 	ldw	r12,12(sp)
1010137c:	dac00417 	ldw	r11,16(sp)
10101380:	d8c00517 	ldw	r3,20(sp)
10101384:	d8800617 	ldw	r2,24(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101388:	4a001a36 	bltu	r9,r8,101013f4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
1010138c:	22801417 	ldw	r10,80(r4)
10101390:	22401317 	ldw	r9,76(r4)
10101394:	1bbfffcc 	andi	r14,r3,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101398:	5000011e 	bne	r10,zero,101013a0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x34>
1010139c:	4b801536 	bltu	r9,r14,101013f4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
101013a0:	13bfffcc 	andi	r14,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101013a4:	5000011e 	bne	r10,zero,101013ac <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x40>
101013a8:	4b801236 	bltu	r9,r14,101013f4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
101013ac:	22401703 	ldbu	r9,92(r4)
101013b0:	01000044 	movi	r4,1
101013b4:	49000f1e 	bne	r9,r4,101013f4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101013b8:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013bc:	d8800117 	ldw	r2,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101013c0:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
101013c4:	29c00115 	stw	r7,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013c8:	10a00034 	orhi	r2,r2,32768
101013cc:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101013d0:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
101013d4:	2b40030d 	sth	r13,12(r5)
    descriptor->read_burst_count = read_burst_count;
101013d8:	2b000385 	stb	r12,14(r5)
    descriptor->write_burst_count = write_burst_count;
101013dc:	2ac003c5 	stb	r11,15(r5)
    descriptor->read_stride = read_stride;
101013e0:	28c0040d 	sth	r3,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101013e4:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101013e8:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101013ec:	0005883a 	mov	r2,zero
101013f0:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101013f4:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
101013f8:	f800283a 	ret

101013fc <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
101013fc:	d8800017 	ldw	r2,0(sp)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101400:	20c01217 	ldw	r3,72(r4)
10101404:	18800e36 	bltu	r3,r2,10101440 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
10101408:	20c01703 	ldbu	r3,92(r4)
1010140c:	18000c1e 	bne	r3,zero,10101440 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101410:	d8c00117 	ldw	r3,4(sp)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101414:	28800215 	stw	r2,8(r5)
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101418:	00900034 	movhi	r2,16384
1010141c:	10bfffc4 	addi	r2,r2,-1
10101420:	1884703a 	and	r2,r3,r2
10101424:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101428:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
1010142c:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101430:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101434:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101438:	0005883a 	mov	r2,zero
1010143c:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101440:	00bffa84 	movi	r2,-22
	alt_u32 length,
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, write_address, length, control);
}
10101444:	f800283a 	ret

10101448 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101448:	20801217 	ldw	r2,72(r4)
1010144c:	11c00e36 	bltu	r2,r7,10101488 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
10101450:	20801703 	ldbu	r2,92(r4)
10101454:	10000c1e 	bne	r2,zero,10101488 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101458:	d8c00017 	ldw	r3,0(sp)
1010145c:	00900034 	movhi	r2,16384
10101460:	10bfffc4 	addi	r2,r2,-1
10101464:	1884703a 	and	r2,r3,r2
10101468:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
1010146c:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101470:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
10101474:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
10101478:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
1010147c:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101480:	0005883a 	mov	r2,zero
10101484:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101488:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		0, write_address, length, control);
}
1010148c:	f800283a 	ret

10101490 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101490:	20801217 	ldw	r2,72(r4)
10101494:	11c00e36 	bltu	r2,r7,101014d0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
10101498:	20801703 	ldbu	r2,92(r4)
1010149c:	10000c1e 	bne	r2,zero,101014d0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101014a0:	d8c00017 	ldw	r3,0(sp)
101014a4:	00900034 	movhi	r2,16384
101014a8:	10bfffc4 	addi	r2,r2,-1
101014ac:	1884703a 	and	r2,r3,r2
101014b0:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
101014b4:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101014b8:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
101014bc:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
101014c0:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
101014c4:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101014c8:	0005883a 	mov	r2,zero
101014cc:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
101014d0:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, 0, length, control);
}
101014d4:	f800283a 	ret

101014d8 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014d8:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014dc:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101014e0:	da400217 	ldw	r9,8(sp)
101014e4:	da000317 	ldw	r8,12(sp)
101014e8:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101014ec:	50c01c36 	bltu	r10,r3,10101560 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
101014f0:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < write_stride ||
101014f4:	12bfffcc 	andi	r10,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101014f8:	5800021e 	bne	r11,zero,10101504 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x2c>
101014fc:	22c01317 	ldw	r11,76(r4)
10101500:	5a801736 	bltu	r11,r10,10101560 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
10101504:	22801703 	ldbu	r10,92(r4)
10101508:	01000044 	movi	r4,1
1010150c:	5100141e 	bne	r10,r4,10101560 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
10101510:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101514:	d8c00117 	ldw	r3,4(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101518:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010151c:	00900034 	movhi	r2,16384
10101520:	10bfffc4 	addi	r2,r2,-1
10101524:	1884703a 	and	r2,r3,r2
10101528:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
1010152c:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
10101530:	28000915 	stw	zero,36(r5)
    descriptor->read_address_low = read_address_low;
10101534:	28000015 	stw	zero,0(r5)
    descriptor->write_address_high = write_address_high;
10101538:	29800a15 	stw	r6,40(r5)
    descriptor->write_address_low = write_address_low;
1010153c:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
10101540:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101544:	28000785 	stb	zero,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101548:	2a0007c5 	stb	r8,31(r5)
    descriptor->read_stride = read_stride;
1010154c:	2800080d 	sth	zero,32(r5)
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
10101550:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
10101554:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101558:	0005883a 	mov	r2,zero
1010155c:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101560:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
10101564:	f800283a 	ret

10101568 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101568:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
1010156c:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101570:	da400217 	ldw	r9,8(sp)
10101574:	da000317 	ldw	r8,12(sp)
10101578:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
1010157c:	50c01c36 	bltu	r10,r3,101015f0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
10101580:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < read_stride ||
10101584:	12bfffcc 	andi	r10,r2,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101588:	5800021e 	bne	r11,zero,10101594 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x2c>
1010158c:	22c01317 	ldw	r11,76(r4)
10101590:	5a801736 	bltu	r11,r10,101015f0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101594:	22801703 	ldbu	r10,92(r4)
10101598:	01000044 	movi	r4,1
1010159c:	5100141e 	bne	r10,r4,101015f0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
101015a0:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101015a4:	d8c00117 	ldw	r3,4(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
101015a8:	2880080d 	sth	r2,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101015ac:	00900034 	movhi	r2,16384
101015b0:	10bfffc4 	addi	r2,r2,-1
101015b4:	1884703a 	and	r2,r3,r2
101015b8:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
101015bc:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
101015c0:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
101015c4:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
101015c8:	28000a15 	stw	zero,40(r5)
    descriptor->write_address_low = write_address_low;
101015cc:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
101015d0:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
101015d4:	2a000785 	stb	r8,30(r5)
    descriptor->write_burst_count = write_burst_count;
101015d8:	280007c5 	stb	zero,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101015dc:	2800088d 	sth	zero,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
101015e0:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
101015e4:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101015e8:	0005883a 	mov	r2,zero
101015ec:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101015f0:	00bffa84 	movi	r2,-22
	alt_u16 read_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
101015f4:	f800283a 	ret

101015f8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
101015f8:	da000217 	ldw	r8,8(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101015fc:	22401217 	ldw	r9,72(r4)
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
10101600:	db400417 	ldw	r13,16(sp)
10101604:	db000517 	ldw	r12,20(sp)
10101608:	dac00617 	ldw	r11,24(sp)
1010160c:	d8c00717 	ldw	r3,28(sp)
10101610:	d8800817 	ldw	r2,32(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101614:	4a002136 	bltu	r9,r8,1010169c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
10101618:	22801417 	ldw	r10,80(r4)
1010161c:	22401317 	ldw	r9,76(r4)
10101620:	1bbfffcc 	andi	r14,r3,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101624:	5000011e 	bne	r10,zero,1010162c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x34>
10101628:	4b801c36 	bltu	r9,r14,1010169c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
1010162c:	13bfffcc 	andi	r14,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101630:	5000011e 	bne	r10,zero,10101638 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x40>
10101634:	4b801936 	bltu	r9,r14,1010169c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < write_stride ||
10101638:	22401703 	ldbu	r9,92(r4)
1010163c:	01000044 	movi	r4,1
10101640:	4900161e 	bne	r9,r4,1010169c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101644:	d9000017 	ldw	r4,0(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
10101648:	28c0080d 	sth	r3,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010164c:	d8c00317 	ldw	r3,12(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101650:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101654:	00900034 	movhi	r2,16384
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101658:	29000a15 	stw	r4,40(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010165c:	10bfffc4 	addi	r2,r2,-1
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
10101660:	d9000117 	ldw	r4,4(sp)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101664:	1884703a 	and	r2,r3,r2
10101668:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
1010166c:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
10101670:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
10101674:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
10101678:	29000115 	stw	r4,4(r5)
    descriptor->transfer_length = length;
1010167c:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
10101680:	2b40070d 	sth	r13,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101684:	2b000785 	stb	r12,30(r5)
    descriptor->write_burst_count = write_burst_count;
10101688:	2ac007c5 	stb	r11,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
1010168c:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
10101690:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101694:	0005883a 	mov	r2,zero
10101698:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
1010169c:	00bffa84 	movi	r2,-22
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
101016a0:	f800283a 	ret

101016a4 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
101016a4:	28001126 	beq	r5,zero,101016ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
101016a8:	29800317 	ldw	r6,12(r5)
101016ac:	29800f1e 	bne	r5,r6,101016ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
101016b0:	20800017 	ldw	r2,0(r4)
101016b4:	1000021e 	bne	r2,zero,101016c0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x1c>
	{
		*list = descriptor;  /* make this root-node if list is empty */
101016b8:	21400015 	stw	r5,0(r4)
		return 0;  /* successfully added */
101016bc:	f800283a 	ret
	}
	if (*list == descriptor)
101016c0:	11400a26 	beq	r2,r5,101016ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
101016c4:	1007883a 	mov	r3,r2
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
101016c8:	19000317 	ldw	r4,12(r3)
101016cc:	20800326 	beq	r4,r2,101016dc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x38>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
101016d0:	21800626 	beq	r4,r6,101016ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
101016d4:	2007883a 	mov	r3,r4
101016d8:	003ffb06 	br	101016c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x24>
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
101016dc:	19800315 	stw	r6,12(r3)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
101016e0:	28800315 	stw	r2,12(r5)
	return 0; /* successfully added */
101016e4:	0005883a 	mov	r2,zero
101016e8:	f800283a 	ret
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
101016ec:	00bffa84 	movi	r2,-22
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
	return 0; /* successfully added */
}
101016f0:	f800283a 	ret

101016f4 <alt_msgdma_prefetcher_add_extended_desc_to_list>:
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
101016f4:	2800021e 	bne	r5,zero,10101700 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
101016f8:	00bffa84 	movi	r2,-22
101016fc:	f800283a 	ret
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
10101700:	28800317 	ldw	r2,12(r5)
10101704:	11400226 	beq	r2,r5,10101710 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x1c>
10101708:	28800b17 	ldw	r2,44(r5)
1010170c:	103ffa1e 	bne	r2,zero,101016f8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
10101710:	20800017 	ldw	r2,0(r4)
10101714:	1000021e 	bne	r2,zero,10101720 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
10101718:	21400015 	stw	r5,0(r4)
		return 0;
1010171c:	f800283a 	ret
	}
	if (*list == descriptor)
10101720:	117ff526 	beq	r2,r5,101016f8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
10101724:	1007883a 	mov	r3,r2
10101728:	11000317 	ldw	r4,12(r2)
1010172c:	20c0061e 	bne	r4,r3,10101748 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x54>
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
10101730:	11400315 	stw	r5,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
10101734:	10000b15 	stw	zero,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
10101738:	28c00315 	stw	r3,12(r5)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
1010173c:	28000b15 	stw	zero,44(r5)
	return 0;
10101740:	0005883a 	mov	r2,zero
10101744:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
10101748:	11800b17 	ldw	r6,44(r2)
1010174c:	303ff826 	beq	r6,zero,10101730 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x3c>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
10101750:	2005883a 	mov	r2,r4
10101754:	003ff406 	br	10101728 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x34>

10101758 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
10101758:	20000a26 	beq	r4,zero,10101784 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
1010175c:	2005883a 	mov	r2,r4
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101760:	10c00717 	ldw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101764:	11400317 	ldw	r5,12(r2)
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101768:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
1010176c:	10c00715 	stw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101770:	21400226 	beq	r4,r5,1010177c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x24>
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
10101774:	2805883a 	mov	r2,r5
10101778:	003ff906 	br	10101760 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x8>
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
1010177c:	0005883a 	mov	r2,zero
10101780:	f800283a 	ret
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
10101784:	00bffa84 	movi	r2,-22
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
}
10101788:	f800283a 	ret

1010178c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
1010178c:	20000f26 	beq	r4,zero,101017cc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
10101790:	200b883a 	mov	r5,r4
10101794:	20c00317 	ldw	r3,12(r4)
10101798:	1940051e 	bne	r3,r5,101017b0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x24>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
1010179c:	20800f17 	ldw	r2,60(r4)
101017a0:	10900034 	orhi	r2,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
101017a4:	20800f15 	stw	r2,60(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
101017a8:	0005883a 	mov	r2,zero
101017ac:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
101017b0:	20800b17 	ldw	r2,44(r4)
101017b4:	103ff926 	beq	r2,zero,1010179c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x10>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101017b8:	20800f17 	ldw	r2,60(r4)
101017bc:	10900034 	orhi	r2,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
101017c0:	20800f15 	stw	r2,60(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
101017c4:	1809883a 	mov	r4,r3
101017c8:	003ff206 	br	10101794 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8>
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
101017cc:	00bffa84 	movi	r2,-22
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
}
101017d0:	f800283a 	ret

101017d4 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
101017d4:	da800017 	ldw	r10,0(sp)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
101017d8:	20800617 	ldw	r2,24(r4)
101017dc:	10800037 	ldwio	r2,0(r2)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
101017e0:	10c0004c 	andi	r3,r2,1
101017e4:	18003b1e 	bne	r3,zero,101018d4 <alt_msgdma_start_prefetcher_with_list_addr+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101017e8:	0011303a 	rdctl	r8,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101017ec:	00ffff84 	movi	r3,-2
101017f0:	40d2703a 	and	r9,r8,r3
101017f4:	4801703a 	wrctl	status,r9
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
101017f8:	22400317 	ldw	r9,12(r4)
101017fc:	02c00804 	movi	r11,32
10101800:	4ac00135 	stwio	r11,4(r9)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
10101804:	22400317 	ldw	r9,12(r4)
10101808:	4ac00037 	ldwio	r11,0(r9)
1010180c:	4ac00035 	stwio	r11,0(r9)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101810:	4001703a 	wrctl	status,r8
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
10101814:	22400b17 	ldw	r9,44(r4)
10101818:	22c00317 	ldw	r11,12(r4)
1010181c:	22000d17 	ldw	r8,52(r4)
10101820:	48000526 	beq	r9,zero,10101838 <alt_msgdma_start_prefetcher_with_list_addr+0x64>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101824:	027ff7c4 	movi	r9,-33
10101828:	4250703a 	and	r8,r8,r9
1010182c:	42000514 	ori	r8,r8,20
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10101830:	10800214 	ori	r2,r2,8
10101834:	00000506 	br	1010184c <alt_msgdma_start_prefetcher_with_list_addr+0x78>
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101838:	027ff3c4 	movi	r9,-49
1010183c:	4250703a 	and	r8,r8,r9
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
10101840:	027ffdc4 	movi	r9,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101844:	42000114 	ori	r8,r8,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
10101848:	1244703a 	and	r2,r2,r9
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
1010184c:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101850:	48c6703a 	and	r3,r9,r3
10101854:	1801703a 	wrctl	status,r3
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
10101858:	5a000135 	stwio	r8,4(r11)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
1010185c:	20c00617 	ldw	r3,24(r4)
10101860:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101864:	4801703a 	wrctl	status,r9
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
10101868:	20c00617 	ldw	r3,24(r4)
1010186c:	19400135 	stwio	r5,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
10101870:	20c00617 	ldw	r3,24(r4)
10101874:	19800235 	stwio	r6,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
10101878:	39c03fcc 	andi	r7,r7,255
1010187c:	38000226 	beq	r7,zero,10101888 <alt_msgdma_start_prefetcher_with_list_addr+0xb4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
10101880:	10800414 	ori	r2,r2,16
10101884:	00000206 	br	10101890 <alt_msgdma_start_prefetcher_with_list_addr+0xbc>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
10101888:	00fffbc4 	movi	r3,-17
1010188c:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
10101890:	50c03fcc 	andi	r3,r10,255
10101894:	18000826 	beq	r3,zero,101018b8 <alt_msgdma_start_prefetcher_with_list_addr+0xe4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
10101898:	20c00617 	ldw	r3,24(r4)
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
1010189c:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101018a0:	18c00304 	addi	r3,r3,12
101018a4:	19400037 	ldwio	r5,0(r3)
101018a8:	2800051e 	bne	r5,zero,101018c0 <alt_msgdma_start_prefetcher_with_list_addr+0xec>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101018ac:	01403fc4 	movi	r5,255
101018b0:	19400035 	stwio	r5,0(r3)
101018b4:	00000206 	br	101018c0 <alt_msgdma_start_prefetcher_with_list_addr+0xec>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
101018b8:	00ffff44 	movi	r3,-3
101018bc:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018c0:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
101018c4:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101018c8:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
101018cc:	0005883a 	mov	r2,zero
101018d0:	f800283a 	ret
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
101018d4:	00bffc04 	movi	r2,-16
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
}
101018d8:	f800283a 	ret

101018dc <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018dc:	defffa04 	addi	sp,sp,-24
101018e0:	dc800415 	stw	r18,16(sp)
101018e4:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018e8:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018ec:	dc400315 	stw	r17,12(sp)
101018f0:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101018f4:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101018f8:	dfc00515 	stw	ra,20(sp)
101018fc:	3023883a 	mov	r17,r6
10101900:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
10101904:	01017580 	call	10101758 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
10101908:	d9400117 	ldw	r5,4(sp)
1010190c:	1000071e 	bne	r2,zero,1010192c <alt_msgdma_start_prefetcher_with_std_desc_list+0x50>
		return -EINVAL;
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
10101910:	84003fcc 	andi	r16,r16,255
10101914:	dc000015 	stw	r16,0(sp)
10101918:	9009883a 	mov	r4,r18
1010191c:	000d883a 	mov	r6,zero
10101920:	89c03fcc 	andi	r7,r17,255
10101924:	01017d40 	call	101017d4 <alt_msgdma_start_prefetcher_with_list_addr>
10101928:	00000106 	br	10101930 <alt_msgdma_start_prefetcher_with_std_desc_list+0x54>
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
1010192c:	00bffa84 	movi	r2,-22
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
			park_mode_en, poll_en);
}
10101930:	dfc00517 	ldw	ra,20(sp)
10101934:	dc800417 	ldw	r18,16(sp)
10101938:	dc400317 	ldw	r17,12(sp)
1010193c:	dc000217 	ldw	r16,8(sp)
10101940:	dec00604 	addi	sp,sp,24
10101944:	f800283a 	ret

10101948 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101948:	defffa04 	addi	sp,sp,-24
1010194c:	dc800415 	stw	r18,16(sp)
10101950:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101954:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101958:	dc400315 	stw	r17,12(sp)
1010195c:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101960:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101964:	dfc00515 	stw	ra,20(sp)
10101968:	3023883a 	mov	r17,r6
1010196c:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101970:	010178c0 	call	1010178c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
10101974:	d9400117 	ldw	r5,4(sp)
10101978:	1000071e 	bne	r2,zero,10101998 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
1010197c:	84003fcc 	andi	r16,r16,255
10101980:	dc000015 	stw	r16,0(sp)
10101984:	9009883a 	mov	r4,r18
10101988:	000d883a 	mov	r6,zero
1010198c:	89c03fcc 	andi	r7,r17,255
10101990:	01017d40 	call	101017d4 <alt_msgdma_start_prefetcher_with_list_addr>
10101994:	00000106 	br	1010199c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x54>
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101998:	00bffa84 	movi	r2,-22
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
			park_mode_en, poll_en);
}
1010199c:	dfc00517 	ldw	ra,20(sp)
101019a0:	dc800417 	ldw	r18,16(sp)
101019a4:	dc400317 	ldw	r17,12(sp)
101019a8:	dc000217 	ldw	r16,8(sp)
101019ac:	dec00604 	addi	sp,sp,24
101019b0:	f800283a 	ret

101019b4 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019b4:	defffe04 	addi	sp,sp,-8
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019b8:	d1600204 	addi	r5,gp,-32760
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
101019bc:	dc000015 	stw	r16,0(sp)
101019c0:	dfc00115 	stw	ra,4(sp)
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
101019c4:	0101c300 	call	10101c30 <alt_find_dev>
101019c8:	1021883a 	mov	r16,r2

    if (NULL == dev)
101019cc:	10000a1e 	bne	r2,zero,101019f8 <alt_msgdma_open+0x44>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
101019d0:	00840434 	movhi	r2,4112
101019d4:	10887904 	addi	r2,r2,8676
101019d8:	10800017 	ldw	r2,0(r2)
101019dc:	10000226 	beq	r2,zero,101019e8 <alt_msgdma_open+0x34>
101019e0:	103ee83a 	callr	r2
101019e4:	00000206 	br	101019f0 <alt_msgdma_open+0x3c>
101019e8:	00840434 	movhi	r2,4112
101019ec:	10889e04 	addi	r2,r2,8824
    {
        ALT_ERRNO = ENODEV;
101019f0:	00c004c4 	movi	r3,19
101019f4:	10c00015 	stw	r3,0(r2)
    }

    return dev;
}
101019f8:	8005883a 	mov	r2,r16
101019fc:	dfc00117 	ldw	ra,4(sp)
10101a00:	dc000017 	ldw	r16,0(sp)
10101a04:	dec00204 	addi	sp,sp,8
10101a08:	f800283a 	ret

10101a0c <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101a0c:	defffb04 	addi	sp,sp,-20
10101a10:	dc800315 	stw	r18,12(sp)
10101a14:	dc400215 	stw	r17,8(sp)
10101a18:	dc000115 	stw	r16,4(sp)
10101a1c:	dfc00415 	stw	ra,16(sp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a20:	20801783 	ldbu	r2,94(r4)
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101a24:	2021883a 	mov	r16,r4
10101a28:	2825883a 	mov	r18,r5
10101a2c:	3023883a 	mov	r17,r6
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101a30:	1000041e 	bne	r2,zero,10101a44 <alt_msgdma_init+0x38>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
10101a34:	80800317 	ldw	r2,12(r16)
10101a38:	00c00084 	movi	r3,2
10101a3c:	10c00135 	stwio	r3,4(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a40:	00000806 	br	10101a64 <alt_msgdma_init+0x58>
    int error;

    if (dev->prefetcher_enable)
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
10101a44:	20800617 	ldw	r2,24(r4)
10101a48:	00c00104 	movi	r3,4
10101a4c:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
10101a50:	80800617 	ldw	r2,24(r16)
10101a54:	10800037 	ldwio	r2,0(r2)
10101a58:	1080010c 	andi	r2,r2,4
10101a5c:	103ffc1e 	bne	r2,zero,10101a50 <alt_msgdma_init+0x44>
10101a60:	003ff406 	br	10101a34 <alt_msgdma_init+0x28>
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a64:	80800317 	ldw	r2,12(r16)
10101a68:	10c00037 	ldwio	r3,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
10101a6c:	18c0100c 	andi	r3,r3,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101a70:	183ffc1e 	bne	r3,zero,10101a64 <alt_msgdma_init+0x58>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10101a74:	10800104 	addi	r2,r2,4
10101a78:	11000037 	ldwio	r4,0(r2)
10101a7c:	00fffbc4 	movi	r3,-17
10101a80:	20c6703a 	and	r3,r4,r3
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
10101a84:	18c00814 	ori	r3,r3,32
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10101a88:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
10101a8c:	80800317 	ldw	r2,12(r16)
10101a90:	10c00037 	ldwio	r3,0(r2)
10101a94:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
10101a98:	80801783 	ldbu	r2,94(r16)
10101a9c:	10000426 	beq	r2,zero,10101ab0 <alt_msgdma_init+0xa4>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
10101aa0:	80800617 	ldw	r2,24(r16)
10101aa4:	10800404 	addi	r2,r2,16
10101aa8:	10c00037 	ldwio	r3,0(r2)
10101aac:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
10101ab0:	8009883a 	mov	r4,r16
10101ab4:	d1600204 	addi	r5,gp,-32760
10101ab8:	0101bb80 	call	10101bb8 <alt_dev_llist_insert>
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
            
    if (!error)
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
10101abc:	01840434 	movhi	r6,4112
10101ac0:	d8000015 	stw	zero,0(sp)
10101ac4:	9009883a 	mov	r4,r18
10101ac8:	880b883a 	mov	r5,r17
10101acc:	31833704 	addi	r6,r6,3292
10101ad0:	800f883a 	mov	r7,r16
10101ad4:	01008600 	call	10100860 <alt_ic_isr_register>
        alt_printf("failed to create semaphores\n");
    }
    
    return;

}
10101ad8:	dfc00417 	ldw	ra,16(sp)
10101adc:	dc800317 	ldw	r18,12(sp)
10101ae0:	dc400217 	ldw	r17,8(sp)
10101ae4:	dc000117 	ldw	r16,4(sp)
10101ae8:	dec00504 	addi	sp,sp,20
10101aec:	f800283a 	ret

10101af0 <alt_msgdma_register_callback>:
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
    dev->callback         = callback;
10101af0:	21400b15 	stw	r5,44(r4)
    dev->callback_context = context;
10101af4:	21c00c15 	stw	r7,48(r4)
    dev->control          = control;
10101af8:	21800d15 	stw	r6,52(r4)
10101afc:	f800283a 	ret

10101b00 <alt_msgdma_standard_descriptor_async_transfer>:
{
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
10101b00:	000d883a 	mov	r6,zero
10101b04:	01010401 	jmpi	10101040 <alt_msgdma_descriptor_async_transfer>

10101b08 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101b08:	280d883a 	mov	r6,r5
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
10101b0c:	000b883a 	mov	r5,zero
10101b10:	01010401 	jmpi	10101040 <alt_msgdma_descriptor_async_transfer>

10101b14 <alt_msgdma_standard_descriptor_sync_transfer>:
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
10101b14:	000d883a 	mov	r6,zero
10101b18:	0100e101 	jmpi	10100e10 <alt_msgdma_descriptor_sync_transfer>

10101b1c <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101b1c:	280d883a 	mov	r6,r5
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
10101b20:	000b883a 	mov	r5,zero
10101b24:	0100e101 	jmpi	10100e10 <alt_msgdma_descriptor_sync_transfer>

10101b28 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b28:	01420034 	movhi	r5,2048
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b2c:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b30:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101b34:	dc000015 	stw	r16,0(sp)
10101b38:	dfc00115 	stw	ra,4(sp)
10101b3c:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101b40:	01008280 	call	10100828 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b44:	10000e26 	beq	r2,zero,10101b80 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b48:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b4c:	013e0034 	movhi	r4,63488
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101b50:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b54:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b58:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101b5c:	297fffc4 	addi	r5,r5,-1
10101b60:	283ffe1e 	bne	r5,zero,10101b5c <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b64:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101b68:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101b6c:	18bffb16 	blt	r3,r2,10101b5c <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b70:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b74:	843fffc4 	addi	r16,r16,-1
10101b78:	803ffe1e 	bne	r16,zero,10101b74 <alt_busy_sleep+0x4c>
10101b7c:	00000306 	br	10101b8c <alt_busy_sleep+0x64>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101b80:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101b84:	843fffc4 	addi	r16,r16,-1
10101b88:	043ffe16 	blt	zero,r16,10101b84 <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
10101b8c:	0005883a 	mov	r2,zero
10101b90:	dfc00117 	ldw	ra,4(sp)
10101b94:	dc000017 	ldw	r16,0(sp)
10101b98:	dec00204 	addi	sp,sp,8
10101b9c:	f800283a 	ret

10101ba0 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101ba0:	0005883a 	mov	r2,zero
10101ba4:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10101ba8:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101bac:	10800804 	addi	r2,r2,32
10101bb0:	10fffd1e 	bne	r2,r3,10101ba8 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10101bb4:	f800283a 	ret

10101bb8 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10101bb8:	20000226 	beq	r4,zero,10101bc4 <alt_dev_llist_insert+0xc>
10101bbc:	20800217 	ldw	r2,8(r4)
10101bc0:	1000131e 	bne	r2,zero,10101c10 <alt_dev_llist_insert+0x58>
10101bc4:	00840434 	movhi	r2,4112
10101bc8:	10887904 	addi	r2,r2,8676
10101bcc:	10800017 	ldw	r2,0(r2)
10101bd0:	10000926 	beq	r2,zero,10101bf8 <alt_dev_llist_insert+0x40>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10101bd4:	deffff04 	addi	sp,sp,-4
10101bd8:	dfc00015 	stw	ra,0(sp)
10101bdc:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101be0:	00c00584 	movi	r3,22
10101be4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101be8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101bec:	dfc00017 	ldw	ra,0(sp)
10101bf0:	dec00104 	addi	sp,sp,4
10101bf4:	f800283a 	ret
10101bf8:	00840434 	movhi	r2,4112
10101bfc:	10889e04 	addi	r2,r2,8824
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101c00:	00c00584 	movi	r3,22
10101c04:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101c08:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101c0c:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
10101c10:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10101c14:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
10101c18:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
10101c1c:	28800017 	ldw	r2,0(r5)
10101c20:	11000115 	stw	r4,4(r2)
  list->next           = entry;
10101c24:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
10101c28:	0005883a 	mov	r2,zero
10101c2c:	f800283a 	ret

10101c30 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10101c30:	defffb04 	addi	sp,sp,-20
10101c34:	dcc00315 	stw	r19,12(sp)
10101c38:	dc800215 	stw	r18,8(sp)
10101c3c:	dc400115 	stw	r17,4(sp)
10101c40:	dc000015 	stw	r16,0(sp)
10101c44:	dfc00415 	stw	ra,16(sp)
10101c48:	2027883a 	mov	r19,r4
10101c4c:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
10101c50:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
10101c54:	0101d200 	call	10101d20 <strlen>
10101c58:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10101c5c:	84400726 	beq	r16,r17,10101c7c <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10101c60:	81000217 	ldw	r4,8(r16)
10101c64:	980b883a 	mov	r5,r19
10101c68:	900d883a 	mov	r6,r18
10101c6c:	0101cf00 	call	10101cf0 <memcmp>
10101c70:	10000426 	beq	r2,zero,10101c84 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
10101c74:	84000017 	ldw	r16,0(r16)
10101c78:	003ff806 	br	10101c5c <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
10101c7c:	0005883a 	mov	r2,zero
10101c80:	00000106 	br	10101c88 <alt_find_dev+0x58>
10101c84:	8005883a 	mov	r2,r16
}
10101c88:	dfc00417 	ldw	ra,16(sp)
10101c8c:	dcc00317 	ldw	r19,12(sp)
10101c90:	dc800217 	ldw	r18,8(sp)
10101c94:	dc400117 	ldw	r17,4(sp)
10101c98:	dc000017 	ldw	r16,0(sp)
10101c9c:	dec00504 	addi	sp,sp,20
10101ca0:	f800283a 	ret

10101ca4 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
10101ca4:	0009883a 	mov	r4,zero
10101ca8:	01440004 	movi	r5,4096
10101cac:	0101cb81 	jmpi	10101cb8 <alt_icache_flush>

10101cb0 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10101cb0:	000170fa 	wrctl	ienable,zero
10101cb4:	f800283a 	ret

10101cb8 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
10101cb8:	00840004 	movi	r2,4096
10101cbc:	1140012e 	bgeu	r2,r5,10101cc4 <alt_icache_flush+0xc>
10101cc0:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
10101cc4:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101cc8:	2005883a 	mov	r2,r4
10101ccc:	1140032e 	bgeu	r2,r5,10101cdc <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
10101cd0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101cd4:	10800804 	addi	r2,r2,32
10101cd8:	003ffc06 	br	10101ccc <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10101cdc:	210007cc 	andi	r4,r4,31
10101ce0:	20000126 	beq	r4,zero,10101ce8 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
10101ce4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
10101ce8:	0000203a 	flushp
10101cec:	f800283a 	ret

10101cf0 <memcmp>:
10101cf0:	218d883a 	add	r6,r4,r6
10101cf4:	21800826 	beq	r4,r6,10101d18 <memcmp+0x28>
10101cf8:	20800003 	ldbu	r2,0(r4)
10101cfc:	28c00003 	ldbu	r3,0(r5)
10101d00:	10c00226 	beq	r2,r3,10101d0c <memcmp+0x1c>
10101d04:	10c5c83a 	sub	r2,r2,r3
10101d08:	f800283a 	ret
10101d0c:	21000044 	addi	r4,r4,1
10101d10:	29400044 	addi	r5,r5,1
10101d14:	003ff706 	br	10101cf4 <memcmp+0x4>
10101d18:	0005883a 	mov	r2,zero
10101d1c:	f800283a 	ret

10101d20 <strlen>:
10101d20:	2005883a 	mov	r2,r4
10101d24:	10c00007 	ldb	r3,0(r2)
10101d28:	18000226 	beq	r3,zero,10101d34 <strlen+0x14>
10101d2c:	10800044 	addi	r2,r2,1
10101d30:	003ffc06 	br	10101d24 <strlen+0x4>
10101d34:	1105c83a 	sub	r2,r2,r4
10101d38:	f800283a 	ret
