
VGA_Display_Gen1.elf:     file format elf32-littlenios2
VGA_Display_Gen1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10100150

Program Header:
    LOAD off    0x00001000 vaddr 0x10100000 paddr 0x10100000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10100020 paddr 0x10100020 align 2**12
         filesz 0x00002398 memsz 0x00002398 flags r-x
    LOAD off    0x000033b8 vaddr 0x101023b8 paddr 0x1010242c align 2**12
         filesz 0x00000074 memsz 0x00000074 flags rw-
    LOAD off    0x000034a0 vaddr 0x101024a0 paddr 0x101024a0 align 2**12
         filesz 0x00000000 memsz 0x00000190 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10100000  10100000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000130  10100020  10100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001d00  10100150  10100150  00001150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000568  10101e50  10101e50  00002e50  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000074  101023b8  1010242c  000033b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000190  101024a0  101024a0  000034a0  2**4
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  10102630  10102630  0000342c  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  0000342c  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000420  00000000  00000000  00003450  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000055c3  00000000  00000000  00003870  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001c2e  00000000  00000000  00008e33  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000021ac  00000000  00000000  0000aa61  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000898  00000000  00000000  0000cc10  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000018bb  00000000  00000000  0000d4a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00002264  00000000  00000000  0000ed63  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  00010fc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000208  00000000  00000000  00011028  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00012f7c  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00012f7f  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00012f8b  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00012f8c  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  00012f8d  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  00012f98  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  00012fa3  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000006  00000000  00000000  00012fae  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002c  00000000  00000000  00012fb4  2**0
                  CONTENTS, READONLY
 26 .jdi          00004157  00000000  00000000  00012fe0  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     002a8fbb  00000000  00000000  00017137  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10100000 l    d  .entry	00000000 .entry
10100020 l    d  .exceptions	00000000 .exceptions
10100150 l    d  .text	00000000 .text
10101e50 l    d  .rodata	00000000 .rodata
101023b8 l    d  .rwdata	00000000 .rwdata
101024a0 l    d  .bss	00000000 .bss
10102630 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 /home/pokitoz/Dropbox/DE0_SoC_VGA/sw/nios/application/VGA_Display_Gen1_bsp//obj/HAL/src/crt0.o
10100198 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
10100094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 DMA_Read.c
00000000 l    df *ABS*	00000000 VGA_DMA_display.c
10101fd8 l     O .rodata	00000060 msgdma.2783
00000000 l    df *ABS*	00000000 VGA_Display.c
00000000 l    df *ABS*	00000000 msgDMA.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
10100820 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
101023b8 l     O .rwdata	00000060 msgdma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_msgdma.c
10100df0 l     F .text	000000cc alt_msgdma_irq
10100ebc l     F .text	00000068 alt_msgdma_write_extended_descriptor
10100f24 l     F .text	00000230 alt_msgdma_descriptor_sync_transfer
10101154 l     F .text	00000190 alt_msgdma_descriptor_async_transfer
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
10101c14 g     F .text	00000008 alt_msgdma_standard_descriptor_async_transfer
10100b70 g     F .text	0000002c alt_main
10102530 g     O .bss	00000100 alt_irq
1010242c g       *ABS*	00000000 __flash_rwdata_start
10100428 g     F .text	00000014 VGA_Display_changeVerticalPorch
10101354 g     F .text	0000003c alt_msgdma_construct_standard_mm_to_mm_descriptor
101006ec g     F .text	00000134 msgdma_create_mm_to_st_descriptor_list
101024a8 g     O .bss	00000004 descriptor_number
101012e4 g     F .text	00000038 alt_msgdma_construct_standard_st_to_mm_descriptor
10100d50 g     F .text	00000038 alt_putstr
00000000  w      *UND*	00000000 __errno
10100000 g     F .entry	0000001c __reset
1010019c g     F .text	00000010 DMA_Read_configureDMA
10100020 g       *ABS*	00000000 __flash_exceptions_start
101024bc g     O .bss	00000004 errno
101024b4 g     O .bss	00000004 alt_argv
1010a418 g       *ABS*	00000000 _gp
101018a0 g     F .text	00000048 alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
10101d44 g     F .text	00000074 alt_find_dev
1010094c g     F .text	00000028 memcpy
10101a5c g     F .text	0000006c alt_msgdma_start_prefetcher_with_extd_desc_list
10101c1c g     F .text	0000000c alt_msgdma_extended_descriptor_async_transfer
10101c04 g     F .text	00000010 alt_msgdma_register_callback
101001ac g     F .text	00000008 DMA_Read_setFlags
101017b8 g     F .text	00000050 alt_msgdma_prefetcher_add_standard_desc_to_list
10100000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
1010093c g     F .text	00000008 .hidden __udivsi3
101024a0 g     O .bss	00000004 next_desc
10101dcc g     F .text	00000038 alt_icache_flush
1010155c g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
10102630 g       *ABS*	00000000 __bss_end
10100a10 g     F .text	00000068 alt_iic_isr_register
10101b20 g     F .text	000000e4 alt_msgdma_init
10101c30 g     F .text	0000000c alt_msgdma_extended_descriptor_sync_transfer
101009f8 g     F .text	00000018 alt_ic_irq_enabled
101024ac g     O .bss	00000004 alt_irq_active
101000ec g     F .exceptions	00000064 alt_irq_handler
10101408 g     F .text	00000078 alt_msgdma_construct_extended_mm_to_st_descriptor
101019f0 g     F .text	0000006c alt_msgdma_start_prefetcher_with_std_desc_list
10101cb4 g     F .text	00000018 alt_dcache_flush_all
1010242c g       *ABS*	00000000 __ram_rwdata_end
101023b8 g       *ABS*	00000000 __ram_rodata_end
1010241c g     O .rwdata	00000004 jtag_uart_0
10100944 g     F .text	00000008 .hidden __umodsi3
101015a4 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
10102630 g       *ABS*	00000000 end
10120000 g       *ABS*	00000000 __alt_stack_pointer
10100dbc g     F .text	00000034 altera_avalon_jtag_uart_write
10100b9c g     F .text	0000016c alt_printf
10100150 g     F .text	0000004c _start
1010131c g     F .text	00000038 alt_msgdma_construct_standard_mm_to_st_descriptor
10100da8 g     F .text	00000014 alt_sys_init
10100458 g     F .text	00000040 VGA_Display_set_irq
101023b8 g       *ABS*	00000000 __ram_rwdata_start
10101e50 g       *ABS*	00000000 __ram_rodata_start
101024c0 g     O .bss	00000060 msgdma_dev
10102520 g     O .bss	00000010 msgdma_desc
10101c3c g     F .text	00000078 alt_busy_sleep
10101510 g     F .text	0000004c alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
10101e04 g     F .text	00000030 memcmp
10102630 g       *ABS*	00000000 __alt_stack_base
101015ec g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
10101ccc g     F .text	00000078 alt_dev_llist_insert
101024a0 g       *ABS*	00000000 __bss_start
10101ac8 g     F .text	00000058 alt_msgdma_open
10100300 g     F .text	00000128 main
101024b0 g     O .bss	00000004 alt_envp
10101808 g     F .text	00000064 alt_msgdma_prefetcher_add_extended_desc_to_list
101018e8 g     F .text	00000108 alt_msgdma_start_prefetcher_with_list_addr
10102428 g     O .rwdata	00000004 alt_errno
1010170c g     F .text	000000ac alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
1010088c g     F .text	00000054 .hidden __divsi3
10101e50 g       *ABS*	00000000 __flash_rodata_start
10100d88 g     F .text	00000020 alt_irq_init
10101c28 g     F .text	00000008 alt_msgdma_standard_descriptor_sync_transfer
1010167c g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
101024b8 g     O .bss	00000004 alt_argc
101002e0 g     F .text	00000020 irq_vsync
10100020 g       .exceptions	00000000 alt_irq_entry
10100020 g       *ABS*	00000000 __ram_exceptions_start
10100974 g     F .text	00000004 alt_ic_isr_register
101001b4 g     F .text	0000012c DMA_Read_status
1010242c g       *ABS*	00000000 _edata
10102630 g       *ABS*	00000000 _end
10100150 g       *ABS*	00000000 __ram_exceptions_end
1010043c g     F .text	00000014 VGA_Display_changeHorizontalPorch
101009b8 g     F .text	00000040 alt_ic_irq_disable
10100450 g     F .text	00000008 VGA_Display_changeScreenColor
10101dc4 g     F .text	00000008 altera_nios2_qsys_irq_init
1010186c g     F .text	00000034 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
101008e0 g     F .text	0000005c .hidden __modsi3
10120000 g       *ABS*	00000000 __alt_data_end
10100020 g     F .exceptions	00000000 alt_exception
10100498 g     F .text	000000f4 msgdma_transfer
10101480 g     F .text	00000090 alt_msgdma_construct_extended_mm_to_mm_descriptor
10101390 g     F .text	00000078 alt_msgdma_construct_extended_st_to_mm_descriptor
1010001c g       .entry	00000000 _exit
10102420 g     O .rwdata	00000008 alt_msgdma_list
10101e34 g     F .text	0000001c strlen
10100d08 g     F .text	00000048 alt_putchar
101024a4 g     O .bss	00000004 vsync
10101db8 g     F .text	0000000c alt_icache_flush_all
10102418 g     O .rwdata	00000004 alt_priority_mask
10100978 g     F .text	00000040 alt_ic_irq_enable
1010058c g     F .text	00000160 msgdma_create_mm_to_mm_descriptor_list
10100a78 g     F .text	000000f8 alt_load



Disassembly of section .entry:

10100000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10100000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10100004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10100008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1010000c:	00bffd16 	blt	zero,r2,10100004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10100010:	00440434 	movhi	at,4112
    ori r1, r1, %lo(_start)
10100014:	08405414 	ori	at,at,336
    jmp r1
10100018:	0800683a 	jmp	at

1010001c <_exit>:
1010001c:	00000000 	call	10000000 <__alt_mem_onchip_memory2_0-0x100000>

Disassembly of section .exceptions:

10100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
10100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
10100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
10100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1010002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1010003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
10100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
10100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1010004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1010005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1010006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1010007c:	10000326 	beq	r2,zero,1010008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10100080:	20000226 	beq	r4,zero,1010008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10100084:	01000ec0 	call	101000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10100088:	00000306 	br	10100098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1010008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10100090:	e8bfff17 	ldw	r2,-4(ea)

10100094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10100094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10100098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1010009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
101000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
101000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
101000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
101000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
101000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
101000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
101000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
101000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
101000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
101000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
101000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
101000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
101000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
101000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
101000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
101000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
101000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
101000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
101000e8:	ef80083a 	eret

101000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
101000ec:	defffe04 	addi	sp,sp,-8
101000f0:	dfc00115 	stw	ra,4(sp)
101000f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
101000f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
101000fc:	04040434 	movhi	r16,4112
10100100:	84094c04 	addi	r16,r16,9520

  active = alt_irq_pending ();

  do
  {
    i = 0;
10100104:	0005883a 	mov	r2,zero
    mask = 1;
10100108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
1010010c:	190a703a 	and	r5,r3,r4
10100110:	28000c26 	beq	r5,zero,10100144 <alt_irq_handler+0x58>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10100114:	100490fa 	slli	r2,r2,3
10100118:	8087883a 	add	r3,r16,r2
1010011c:	1805883a 	mov	r2,r3
10100120:	11000117 	ldw	r4,4(r2)
10100124:	18c00017 	ldw	r3,0(r3)
10100128:	183ee83a 	callr	r3
1010012c:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10100130:	203ff41e 	bne	r4,zero,10100104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
10100134:	dfc00117 	ldw	ra,4(sp)
10100138:	dc000017 	ldw	r16,0(sp)
1010013c:	dec00204 	addi	sp,sp,8
10100140:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10100144:	18c7883a 	add	r3,r3,r3
      i++;
10100148:	10800044 	addi	r2,r2,1

    } while (1);
1010014c:	003fef06 	br	1010010c <alt_irq_handler+0x20>

Disassembly of section .text:

10100150 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10100150:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
10100154:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
10100158:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
1010015c:	00bffd16 	blt	zero,r2,10100154 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10100160:	06c404b4 	movhi	sp,4114
    ori sp, sp, %lo(__alt_stack_pointer)
10100164:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
10100168:	06840434 	movhi	gp,4112
    ori gp, gp, %lo(_gp)
1010016c:	d6a90614 	ori	gp,gp,42008
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
10100170:	00840434 	movhi	r2,4112
    ori r2, r2, %lo(__bss_start)
10100174:	10892814 	ori	r2,r2,9376

    movhi r3, %hi(__bss_end)
10100178:	00c40434 	movhi	r3,4112
    ori r3, r3, %lo(__bss_end)
1010017c:	18c98c14 	ori	r3,r3,9776

    beq r2, r3, 1f
10100180:	10c00326 	beq	r2,r3,10100190 <_start+0x40>

0:
    stw zero, (r2)
10100184:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
10100188:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
1010018c:	10fffd36 	bltu	r2,r3,10100184 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
10100190:	0100a780 	call	10100a78 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
10100194:	0100b700 	call	10100b70 <alt_main>

10100198 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
10100198:	003fff06 	br	10100198 <alt_after_alt_main>

1010019c <DMA_Read_configureDMA>:

void DMA_Read_configureDMA(alt_u32 base, alt_u32 buffer1_addr,
							alt_u32 buffer2_addr,
							alt_u32 transfer_size){

	IOWR_32DIRECT(base, DMA_READ_BUFFER_1_ADDR_REG, buffer1_addr);
1010019c:	21400035 	stwio	r5,0(r4)
	IOWR_32DIRECT(base, DMA_READ_BUFFER_2_ADDR_REG, buffer2_addr);
101001a0:	21800135 	stwio	r6,4(r4)
	IOWR_32DIRECT(base, DMA_READ_TRANSFER_LENGTH_REG, transfer_size);
101001a4:	21c00235 	stwio	r7,8(r4)
101001a8:	f800283a 	ret

101001ac <DMA_Read_setFlags>:
}


void DMA_Read_setFlags(alt_u32 base, alt_u32 flags) {
	IOWR_32DIRECT(base, DMA_READ_CONFIGURATION_REG, flags);
101001ac:	21400435 	stwio	r5,16(r4)
101001b0:	f800283a 	ret

101001b4 <DMA_Read_status>:
}

void DMA_Read_status(alt_u32 base){
101001b4:	defffc04 	addi	sp,sp,-16
101001b8:	dc400115 	stw	r17,4(sp)
101001bc:	2023883a 	mov	r17,r4
101001c0:	dfc00315 	stw	ra,12(sp)
101001c4:	dc800215 	stw	r18,8(sp)
101001c8:	dc000015 	stw	r16,0(sp)
	alt_u32 value = IORD_32DIRECT(base, DMA_READ_CURRENT_CONFIG_REG);
101001cc:	24000337 	ldwio	r16,12(r4)
	alt_printf("Value config: 0x%x\n", value);
101001d0:	01040434 	movhi	r4,4112
101001d4:	21079404 	addi	r4,r4,7760
101001d8:	800b883a 	mov	r5,r16
101001dc:	0100b9c0 	call	10100b9c <alt_printf>
	if(value & DMA_READ_BIT_IDLE){
101001e0:	8080004c 	andi	r2,r16,1
101001e4:	10000326 	beq	r2,zero,101001f4 <DMA_Read_status+0x40>
		alt_printf("DMA_IDLE\n");
101001e8:	01040434 	movhi	r4,4112
101001ec:	21079904 	addi	r4,r4,7780
101001f0:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_BUFFER){
101001f4:	8080008c 	andi	r2,r16,2
101001f8:	10000326 	beq	r2,zero,10100208 <DMA_Read_status+0x54>
		alt_printf("DMA_IDLE\n");
101001fc:	01040434 	movhi	r4,4112
10100200:	21079904 	addi	r4,r4,7780
10100204:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_START){
10100208:	8080010c 	andi	r2,r16,4
1010020c:	10000326 	beq	r2,zero,1010021c <DMA_Read_status+0x68>
		alt_printf("DMA_READ_BIT_START\n");
10100210:	01040434 	movhi	r4,4112
10100214:	21079c04 	addi	r4,r4,7792
10100218:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_CONTINUE){
1010021c:	8080040c 	andi	r2,r16,16
10100220:	10000326 	beq	r2,zero,10100230 <DMA_Read_status+0x7c>
		alt_printf("DMA_READ_BIT_CONTINUE\n");
10100224:	01040434 	movhi	r4,4112
10100228:	2107a104 	addi	r4,r4,7812
1010022c:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_AUTO_FLIP){
10100230:	8080020c 	andi	r2,r16,8
10100234:	10000326 	beq	r2,zero,10100244 <DMA_Read_status+0x90>
		alt_printf("DMA_READ_BIT_AUTO_FLIP\n");
10100238:	01040434 	movhi	r4,4112
1010023c:	2107a704 	addi	r4,r4,7836
10100240:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_CONSTANT){
10100244:	8080080c 	andi	r2,r16,32
10100248:	10000326 	beq	r2,zero,10100258 <DMA_Read_status+0xa4>
		alt_printf("DMA_READ_BIT_CONSTANT\n");
1010024c:	01040434 	movhi	r4,4112
10100250:	2107ad04 	addi	r4,r4,7860
10100254:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_DMA_CONSTANT){
10100258:	8080100c 	andi	r2,r16,64
1010025c:	10000326 	beq	r2,zero,1010026c <DMA_Read_status+0xb8>
		alt_printf("DMA_READ_BIT_DMA_CONSTANT\n");
10100260:	01040434 	movhi	r4,4112
10100264:	2107b304 	addi	r4,r4,7884
10100268:	0100b9c0 	call	10100b9c <alt_printf>
	}
	if(value & DMA_READ_BIT_STATE){
1010026c:	8140600c 	andi	r5,r16,384
10100270:	28000426 	beq	r5,zero,10100284 <DMA_Read_status+0xd0>
		alt_printf("DMA_READ_BIT_STATE: %x\n", (value & DMA_READ_BIT_STATE) >> 7 );
10100274:	280ad1fa 	srli	r5,r5,7
10100278:	01040434 	movhi	r4,4112
1010027c:	2107ba04 	addi	r4,r4,7912
10100280:	0100b9c0 	call	10100b9c <alt_printf>
	}

	alt_u32 buff1 = IORD_32DIRECT(base, DMA_READ_BUFFER_1_ADDR_REG);
10100284:	89400037 	ldwio	r5,0(r17)
	alt_u32 buff2 = IORD_32DIRECT(base, DMA_READ_BUFFER_2_ADDR_REG);
10100288:	8c800137 	ldwio	r18,4(r17)
	alt_u32 size = IORD_32DIRECT(base, DMA_READ_TRANSFER_LENGTH_REG);
1010028c:	8c400237 	ldwio	r17,8(r17)
	alt_printf("DMA_READ_BUFFER_1_ADDR_REG: %x\n", buff1 );
10100290:	01040434 	movhi	r4,4112
10100294:	2107c004 	addi	r4,r4,7936
10100298:	0100b9c0 	call	10100b9c <alt_printf>
	alt_printf("DMA_READ_BUFFER_2_ADDR_REG: %x\n", buff2 );
1010029c:	01040434 	movhi	r4,4112
101002a0:	900b883a 	mov	r5,r18
101002a4:	2107c804 	addi	r4,r4,7968
101002a8:	0100b9c0 	call	10100b9c <alt_printf>
	alt_printf("DMA_READ_TRANSFER_LENGTH_REG: %x\n", size );
101002ac:	01040434 	movhi	r4,4112
101002b0:	880b883a 	mov	r5,r17
101002b4:	2107d004 	addi	r4,r4,8000
101002b8:	0100b9c0 	call	10100b9c <alt_printf>
	alt_printf("DMA_READ_COUNTER_READ: %x\n\n", (value & DMA_READ_COUNTER_READ) >> 16 );
101002bc:	800ad43a 	srli	r5,r16,16
101002c0:	01040434 	movhi	r4,4112
101002c4:	2107d904 	addi	r4,r4,8036


}
101002c8:	dfc00317 	ldw	ra,12(sp)
101002cc:	dc800217 	ldw	r18,8(sp)
101002d0:	dc400117 	ldw	r17,4(sp)
101002d4:	dc000017 	ldw	r16,0(sp)
101002d8:	dec00404 	addi	sp,sp,16
	alt_u32 buff2 = IORD_32DIRECT(base, DMA_READ_BUFFER_2_ADDR_REG);
	alt_u32 size = IORD_32DIRECT(base, DMA_READ_TRANSFER_LENGTH_REG);
	alt_printf("DMA_READ_BUFFER_1_ADDR_REG: %x\n", buff1 );
	alt_printf("DMA_READ_BUFFER_2_ADDR_REG: %x\n", buff2 );
	alt_printf("DMA_READ_TRANSFER_LENGTH_REG: %x\n", size );
	alt_printf("DMA_READ_COUNTER_READ: %x\n\n", (value & DMA_READ_COUNTER_READ) >> 16 );
101002dc:	0100b9c1 	jmpi	10100b9c <alt_printf>

101002e0 <irq_vsync>:

	//alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
	//		&msgdma_desc, VGA_DISPLAY_ADDRESS_DST_IMAGE, 640, 0);

	//	next_desc++;
	vsync += 1;
101002e0:	d0a02317 	ldw	r2,-32628(gp)
	//	}

	//alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);

	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);
101002e4:	00c00044 	movi	r3,1

	//alt_msgdma_construct_standard_mm_to_st_descriptor(&msgdma_dev,
	//		&msgdma_desc, VGA_DISPLAY_ADDRESS_DST_IMAGE, 640, 0);

	//	next_desc++;
	vsync += 1;
101002e8:	10800044 	addi	r2,r2,1
101002ec:	d0a02315 	stw	r2,-32628(gp)
	//	}

	//alt_msgdma_standard_descriptor_async_transfer(&msgdma_dev, &msgdma_desc);

	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);
101002f0:	00840034 	movhi	r2,4096
101002f4:	10821704 	addi	r2,r2,2140
101002f8:	10c00035 	stwio	r3,0(r2)
101002fc:	f800283a 	ret

10100300 <main>:

}

int main(void) {

	alt_putstr("Hello from VGA_DMA project!\n");
10100300:	01040434 	movhi	r4,4112
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
10100304:	defffc04 	addi	sp,sp,-16

	alt_putstr("Hello from VGA_DMA project!\n");
10100308:	2107e004 	addi	r4,r4,8064
	// Clean the IRQ
	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CLEAN_IRQ_REG, 0x1);

}

int main(void) {
1010030c:	dfc00315 	stw	ra,12(sp)
10100310:	dc000215 	stw	r16,8(sp)

	alt_putstr("Hello from VGA_DMA project!\n");
10100314:	0100d500 	call	10100d50 <alt_putstr>

	VGA_Display_changeScreenColor(VGA_MODULE_0_BASE, 0x00FF00FF);
10100318:	01040034 	movhi	r4,4096
1010031c:	01403ff4 	movhi	r5,255
10100320:	21021004 	addi	r4,r4,2112
10100324:	29403fc4 	addi	r5,r5,255
10100328:	01004500 	call	10100450 <VGA_Display_changeScreenColor>

	IOWR_32DIRECT(VGA_MODULE_0_BASE, VGA_DISPLAY_CONFIGURATION, 0x1);
1010032c:	00840034 	movhi	r2,4096
10100330:	04000044 	movi	r16,1
10100334:	10821104 	addi	r2,r2,2116
10100338:	14000035 	stwio	r16,0(r2)

	ALTERA_MSGDMA_CSR_DESCRIPTOR_SLAVE_INSTANCE(MSGDMA_0, MSGDMA_0_CSR,
			MSGDMA_0_DESCRIPTOR_SLAVE, msgdma);

	msgdma_dev = msgdma;
1010033c:	01040434 	movhi	r4,4112
10100340:	01440434 	movhi	r5,4112
10100344:	21093004 	addi	r4,r4,9408
10100348:	2947f604 	addi	r5,r5,8152
1010034c:	01801804 	movi	r6,96
10100350:	010094c0 	call	1010094c <memcpy>
	alt_msgdma_init(&msgdma_dev, MSGDMA_0_CSR_IRQ_INTERRUPT_CONTROLLER_ID,
10100354:	01040434 	movhi	r4,4112
10100358:	800d883a 	mov	r6,r16
1010035c:	21093004 	addi	r4,r4,9408
10100360:	000b883a 	mov	r5,zero
10100364:	0101b200 	call	10101b20 <alt_msgdma_init>
	MSGDMA_0_CSR_IRQ);

	alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100368:	01840434 	movhi	r6,4112
1010036c:	3180b804 	addi	r6,r6,736
10100370:	000f883a 	mov	r7,zero
10100374:	d8000015 	stw	zero,0(sp)
10100378:	0009883a 	mov	r4,zero
1010037c:	000b883a 	mov	r5,zero
10100380:	01009740 	call	10100974 <alt_ic_isr_register>
	VGA_MODULE_0_IRQ, (void*) irq_vsync, 0, 0);

	// Enable the interrupts
	alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100384:	000b883a 	mov	r5,zero
10100388:	0009883a 	mov	r4,zero
1010038c:	01009780 	call	10100978 <alt_ic_irq_enable>

	int ki = 0;
//	for(ki = 0; ki < 640*480*3; ki++){
//		IOWR(HPS_0_BRIDGES_BASE, 4*ki, 0x00);
//	}
	DMA_Read_status(DMA_READ_0_BASE);
10100390:	01040034 	movhi	r4,4096
10100394:	21020804 	addi	r4,r4,2080
10100398:	01001b40 	call	101001b4 <DMA_Read_status>
	for (ki = 32; ki < 64; ki++) {
		test[ki] = 0;
	}

	// (640pixel*4byte)/4 get # of words to be transfered per line
	DMA_Read_configureDMA(DMA_READ_0_BASE, (alt_u32) HPS_0_BRIDGES_BASE, (alt_u32) HPS_0_BRIDGES_BASE, 640);
1010039c:	01040034 	movhi	r4,4096
101003a0:	21020804 	addi	r4,r4,2080
101003a4:	000b883a 	mov	r5,zero
101003a8:	000d883a 	mov	r6,zero
101003ac:	01c0a004 	movi	r7,640
101003b0:	010019c0 	call	1010019c <DMA_Read_configureDMA>

	IOWR_32DIRECT(DMA_READ_0_BASE, DMA_READ_CONSTANT_REG, 0xFF);
101003b4:	00840034 	movhi	r2,4096
101003b8:	10820d04 	addi	r2,r2,2100
101003bc:	00c03fc4 	movi	r3,255
101003c0:	10c00035 	stwio	r3,0(r2)

	//DMA_Read_setFlags(DMA_READ_0_BASE, 0b01000100);
	DMA_Read_setFlags(DMA_READ_0_BASE, DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);
101003c4:	01040034 	movhi	r4,4096
101003c8:	21020804 	addi	r4,r4,2080
101003cc:	01400504 	movi	r5,20
101003d0:	01001ac0 	call	101001ac <DMA_Read_setFlags>
	DMA_Read_status(DMA_READ_0_BASE);
101003d4:	01040034 	movhi	r4,4096
101003d8:	21020804 	addi	r4,r4,2080
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", vsync);
		//usleep(100000);
		for (kk = 0; kk < 10000000; kk++) {
101003dc:	04002674 	movhi	r16,153

	IOWR_32DIRECT(DMA_READ_0_BASE, DMA_READ_CONSTANT_REG, 0xFF);

	//DMA_Read_setFlags(DMA_READ_0_BASE, 0b01000100);
	DMA_Read_setFlags(DMA_READ_0_BASE, DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);
	DMA_Read_status(DMA_READ_0_BASE);
101003e0:	01001b40 	call	101001b4 <DMA_Read_status>
	volatile int kk = 0;
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", vsync);
		//usleep(100000);
		for (kk = 0; kk < 10000000; kk++) {
101003e4:	84259fc4 	addi	r16,r16,-27009

	//DMA_Read_setFlags(DMA_READ_0_BASE, 0b01000100);
	DMA_Read_setFlags(DMA_READ_0_BASE, DMA_READ_BIT_START | DMA_READ_BIT_CONTINUE);
	DMA_Read_status(DMA_READ_0_BASE);

	volatile int kk = 0;
101003e8:	d8000115 	stw	zero,4(sp)
	//msgdma_transfer(&msgdma_dev, msgdma_desc, descriptor_number);
	while (1) {
		alt_printf("Next: 0x%x,\n", vsync);
101003ec:	d1602317 	ldw	r5,-32628(gp)
101003f0:	01040434 	movhi	r4,4112
101003f4:	2107e804 	addi	r4,r4,8096
101003f8:	0100b9c0 	call	10100b9c <alt_printf>
		//usleep(100000);
		for (kk = 0; kk < 10000000; kk++) {
101003fc:	d8000115 	stw	zero,4(sp)
10100400:	d8800117 	ldw	r2,4(sp)
10100404:	80800416 	blt	r16,r2,10100418 <main+0x118>
10100408:	d8800117 	ldw	r2,4(sp)
1010040c:	10800044 	addi	r2,r2,1
10100410:	d8800115 	stw	r2,4(sp)
10100414:	003ffa06 	br	10100400 <main+0x100>
		}

		DMA_Read_status(DMA_READ_0_BASE);
10100418:	01040034 	movhi	r4,4096
1010041c:	21020804 	addi	r4,r4,2080
10100420:	01001b40 	call	101001b4 <DMA_Read_status>

	}
10100424:	003ff106 	br	101003ec <main+0xec>

10100428 <VGA_Display_changeVerticalPorch>:
#include "alt_types.h"
#include "system.h"
#include "sys/alt_irq.h"

void VGA_Display_changeVerticalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
10100428:	300c943a 	slli	r6,r6,16
1010042c:	297fffcc 	andi	r5,r5,65535
10100430:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_V_REG, concatenated);
10100434:	21400235 	stwio	r5,8(r4)
10100438:	f800283a 	ret

1010043c <VGA_Display_changeHorizontalPorch>:

}

void VGA_Display_changeHorizontalPorch(alt_u32 BASE, alt_u16 front_porch, alt_u16 back_porch) {
	alt_u32 concatenated = front_porch | (back_porch << 16);
1010043c:	300c943a 	slli	r6,r6,16
10100440:	297fffcc 	andi	r5,r5,65535
10100444:	314ab03a 	or	r5,r6,r5
	IOWR_32DIRECT(BASE, VGA_DISPLAY_PORCH_H_REG, concatenated);
10100448:	21400335 	stwio	r5,12(r4)
1010044c:	f800283a 	ret

10100450 <VGA_Display_changeScreenColor>:
}

void VGA_Display_changeScreenColor(alt_u32 BASE, alt_u32 color) {
	IOWR_32DIRECT(BASE, VGA_DISPLAY_COLOR_REG, color);
10100450:	21400035 	stwio	r5,0(r4)
10100454:	f800283a 	ret

10100458 <VGA_Display_set_irq>:
}

void VGA_Display_set_irq(void (*irq_handler)(void*, alt_u32)) {
10100458:	defffd04 	addi	sp,sp,-12
1010045c:	dfc00215 	stw	ra,8(sp)
10100460:	d9000115 	stw	r4,4(sp)

	if (irq_handler != NULL) {
10100464:	20000926 	beq	r4,zero,1010048c <VGA_Display_set_irq+0x34>
		// Register the ISR for sync
		alt_ic_isr_register(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100468:	0009883a 	mov	r4,zero
1010046c:	000b883a 	mov	r5,zero
10100470:	d8000015 	stw	zero,0(sp)
10100474:	d9800104 	addi	r6,sp,4
10100478:	000f883a 	mov	r7,zero
1010047c:	01009740 	call	10100974 <alt_ic_isr_register>
				VGA_MODULE_0_IRQ, (void*) &irq_handler, 0, 0);

		// Enable the interrupts
		alt_ic_irq_enable(VGA_MODULE_0_IRQ_INTERRUPT_CONTROLLER_ID,
10100480:	0009883a 	mov	r4,zero
10100484:	000b883a 	mov	r5,zero
10100488:	01009780 	call	10100978 <alt_ic_irq_enable>
				VGA_MODULE_0_IRQ);
	}

}
1010048c:	dfc00217 	ldw	ra,8(sp)
10100490:	dec00304 	addi	sp,sp,12
10100494:	f800283a 	ret

10100498 <msgdma_transfer>:
#include "msgDMA.h"
#include <stdint-gcc.h>
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {
10100498:	defffa04 	addi	sp,sp,-24
1010049c:	dd000415 	stw	r20,16(sp)
101004a0:	dcc00315 	stw	r19,12(sp)
101004a4:	dc800215 	stw	r18,8(sp)
101004a8:	dc400115 	stw	r17,4(sp)
101004ac:	dc000015 	stw	r16,0(sp)
101004b0:	dfc00515 	stw	ra,20(sp)
101004b4:	2027883a 	mov	r19,r4
101004b8:	2829883a 	mov	r20,r5
101004bc:	3025883a 	mov	r18,r6

	unsigned int i = 0;
	unsigned int error_dma = 0;
101004c0:	0021883a 	mov	r16,zero
#include "sys/alt_stdio.h"

void msgdma_transfer(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, uint32_t descriptor_number) {

	unsigned int i = 0;
101004c4:	0023883a 	mov	r17,zero
	unsigned int error_dma = 0;

	while (i < descriptor_number) {
101004c8:	8c80282e 	bgeu	r17,r18,1010056c <msgdma_transfer+0xd4>

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);
101004cc:	8804913a 	slli	r2,r17,4

	while (i < descriptor_number) {

		unsigned int result;

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
101004d0:	9809883a 	mov	r4,r19
101004d4:	a08b883a 	add	r5,r20,r2
101004d8:	0101c140 	call	10101c14 <alt_msgdma_standard_descriptor_async_transfer>
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
101004dc:	00fff904 	movi	r3,-28
101004e0:	10c0041e 	bne	r2,r3,101004f4 <msgdma_transfer+0x5c>
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101004e4:	01040434 	movhi	r4,4112

		result = alt_msgdma_standard_descriptor_async_transfer(msgdma,
				&msgdma_desc[i]);

		if ((result == -ENOSPC)) {
			error_dma++;
101004e8:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer descriptor buffer is full\n");
101004ec:	21080e04 	addi	r4,r4,8248
101004f0:	00000506 	br	10100508 <msgdma_transfer+0x70>
		} else if (result == -ETIME) {
101004f4:	00fff084 	movi	r3,-62
101004f8:	10c0051e 	bne	r2,r3,10100510 <msgdma_transfer+0x78>
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
101004fc:	01040434 	movhi	r4,4112

		if ((result == -ENOSPC)) {
			error_dma++;
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
10100500:	84000044 	addi	r16,r16,1
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
10100504:	21081904 	addi	r4,r4,8292
10100508:	0100b9c0 	call	10100b9c <alt_printf>
1010050c:	00000b06 	br	1010053c <msgdma_transfer+0xa4>
		} else if (result == -EPERM) {
10100510:	00ffffc4 	movi	r3,-1
10100514:	10c0041e 	bne	r2,r3,10100528 <msgdma_transfer+0x90>
			error_dma++;
			alt_printf(
10100518:	01040434 	movhi	r4,4112
			alt_printf("msgdma_transfer descriptor buffer is full\n");
		} else if (result == -ETIME) {
			error_dma++;
			alt_printf("msgdma_transfer dma_mm_interface_read: timeout\n");
		} else if (result == -EPERM) {
			error_dma++;
1010051c:	84000044 	addi	r16,r16,1
			alt_printf(
10100520:	21082504 	addi	r4,r4,8340
10100524:	003ff806 	br	10100508 <msgdma_transfer+0x70>
					"msgdma_transfer dma_mm_interface_read: operation not permitted due to descriptor type conflict\n");
		} else {
			i++;
10100528:	8c400044 	addi	r17,r17,1
			alt_printf(
1010052c:	01040434 	movhi	r4,4112
10100530:	21083d04 	addi	r4,r4,8436
10100534:	880b883a 	mov	r5,r17
10100538:	0100b9c0 	call	10100b9c <alt_printf>
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
1010053c:	00801904 	movi	r2,100
10100540:	80bfe11e 	bne	r16,r2,101004c8 <msgdma_transfer+0x30>
			alt_printf("Error DMA exceeded\n");
10100544:	01040434 	movhi	r4,4112
10100548:	21085004 	addi	r4,r4,8512
		}

	}

	//alt_printf("Transfer successful\n");
}
1010054c:	dfc00517 	ldw	ra,20(sp)
10100550:	dd000417 	ldw	r20,16(sp)
10100554:	dcc00317 	ldw	r19,12(sp)
10100558:	dc800217 	ldw	r18,8(sp)
1010055c:	dc400117 	ldw	r17,4(sp)
10100560:	dc000017 	ldw	r16,0(sp)
10100564:	dec00604 	addi	sp,sp,24
					"msgdma_transfer dma_mm_interface_read: sending msgdma descriptor mm_s=%d \n",
					i);
		}

		if (error_dma == 100) {
			alt_printf("Error DMA exceeded\n");
10100568:	0100b9c1 	jmpi	10100b9c <alt_printf>
		}

	}

	//alt_printf("Transfer successful\n");
}
1010056c:	dfc00517 	ldw	ra,20(sp)
10100570:	dd000417 	ldw	r20,16(sp)
10100574:	dcc00317 	ldw	r19,12(sp)
10100578:	dc800217 	ldw	r18,8(sp)
1010057c:	dc400117 	ldw	r17,4(sp)
10100580:	dc000017 	ldw	r16,0(sp)
10100584:	dec00604 	addi	sp,sp,24
10100588:	f800283a 	ret

1010058c <msgdma_create_mm_to_mm_descriptor_list>:

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
1010058c:	defff204 	addi	sp,sp,-56
10100590:	dc000415 	stw	r16,16(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100594:	d8800e17 	ldw	r2,56(sp)
uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
10100598:	24001217 	ldw	r16,72(r4)
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
1010059c:	dd800a15 	stw	r22,40(sp)
101005a0:	dd400915 	stw	r21,36(sp)
101005a4:	202d883a 	mov	r22,r4
101005a8:	282b883a 	mov	r21,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101005ac:	113fffc4 	addi	r4,r2,-1
101005b0:	800b883a 	mov	r5,r16
	//alt_printf("Transfer successful\n");
}

uint32_t msgdma_create_mm_to_mm_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		void* address_dest, uint32_t length) {
101005b4:	df000c15 	stw	fp,48(sp)
101005b8:	dcc00715 	stw	r19,28(sp)
101005bc:	dfc00d15 	stw	ra,52(sp)
101005c0:	ddc00b15 	stw	r23,44(sp)
101005c4:	dd000815 	stw	r20,32(sp)
101005c8:	dc800615 	stw	r18,24(sp)
101005cc:	dc400515 	stw	r17,20(sp)
101005d0:	3027883a 	mov	r19,r6
101005d4:	d9c00315 	stw	r7,12(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
101005d8:	010093c0 	call	1010093c <__udivsi3>
101005dc:	1039883a 	mov	fp,r2
101005e0:	10800044 	addi	r2,r2,1
101005e4:	d8800215 	stw	r2,8(sp)

	if (msgdma_desc == NULL) {
101005e8:	a800051e 	bne	r21,zero,10100600 <msgdma_create_mm_to_mm_descriptor_list+0x74>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
101005ec:	01040434 	movhi	r4,4112
101005f0:	21085504 	addi	r4,r4,8532
101005f4:	0100b9c0 	call	10100b9c <alt_printf>
		return 0;
101005f8:	0005883a 	mov	r2,zero
101005fc:	00002f06 	br	101006bc <msgdma_create_mm_to_mm_descriptor_list+0x130>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
10100600:	d9800217 	ldw	r6,8(sp)
10100604:	01040434 	movhi	r4,4112
10100608:	21086204 	addi	r4,r4,8584
1010060c:	800b883a 	mov	r5,r16
10100610:	0100b9c0 	call	10100b9c <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;
10100614:	dc800317 	ldw	r18,12(sp)
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100618:	9823883a 	mov	r17,r19
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
1010061c:	0029883a 	mov	r20,zero
10100620:	a02e913a 	slli	r23,r20,4
10100624:	a7001126 	beq	r20,fp,1010066c <msgdma_create_mm_to_mm_descriptor_list+0xe0>
		alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100628:	01040434 	movhi	r4,4112
1010062c:	a00b883a 	mov	r5,r20
10100630:	880d883a 	mov	r6,r17
10100634:	900f883a 	mov	r7,r18
10100638:	21086f04 	addi	r4,r4,8636
1010063c:	0100b9c0 	call	10100b9c <alt_printf>
				_address_dst_descriptor);

		alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma,
10100640:	880d883a 	mov	r6,r17
10100644:	900f883a 	mov	r7,r18
10100648:	dc000015 	stw	r16,0(sp)
1010064c:	d8000115 	stw	zero,4(sp)
10100650:	b009883a 	mov	r4,r22
10100654:	adcb883a 	add	r5,r21,r23
10100658:	01013540 	call	10101354 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor,
				(uint32_t *) _address_dst_descriptor, max_descriptor_size, 0);
		_address_dst_descriptor += max_descriptor_size;
1010065c:	9425883a 	add	r18,r18,r16
		_address_src_descriptor += max_descriptor_size;
10100660:	8c23883a 	add	r17,r17,r16

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
	uint8_t* _address_dst_descriptor = (uint8_t *) address_dest;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100664:	a5000044 	addi	r20,r20,1
10100668:	003fed06 	br	10100620 <msgdma_create_mm_to_mm_descriptor_list+0x94>
1010066c:	a421383a 	mul	r16,r20,r16
10100670:	d8800317 	ldw	r2,12(sp)
		_address_dst_descriptor += max_descriptor_size;
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor,
10100674:	01040434 	movhi	r4,4112
10100678:	9c27883a 	add	r19,r19,r16
1010067c:	1425883a 	add	r18,r2,r16
10100680:	21086f04 	addi	r4,r4,8636
10100684:	a00b883a 	mov	r5,r20
10100688:	980d883a 	mov	r6,r19
1010068c:	900f883a 	mov	r7,r18
10100690:	0100b9c0 	call	10100b9c <alt_printf>
			_address_dst_descriptor);
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_mm_descriptor(msgdma, msgdma_desc + i,
10100694:	d8800e17 	ldw	r2,56(sp)
10100698:	d8000115 	stw	zero,4(sp)
1010069c:	b009883a 	mov	r4,r22
101006a0:	1421c83a 	sub	r16,r2,r16
101006a4:	dc000015 	stw	r16,0(sp)
101006a8:	adcb883a 	add	r5,r21,r23
101006ac:	980d883a 	mov	r6,r19
101006b0:	900f883a 	mov	r7,r18
101006b4:	01013540 	call	10101354 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
			(uint32_t *) _address_src_descriptor,
			(uint32_t *) _address_dst_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101006b8:	d8800217 	ldw	r2,8(sp)
}
101006bc:	dfc00d17 	ldw	ra,52(sp)
101006c0:	df000c17 	ldw	fp,48(sp)
101006c4:	ddc00b17 	ldw	r23,44(sp)
101006c8:	dd800a17 	ldw	r22,40(sp)
101006cc:	dd400917 	ldw	r21,36(sp)
101006d0:	dd000817 	ldw	r20,32(sp)
101006d4:	dcc00717 	ldw	r19,28(sp)
101006d8:	dc800617 	ldw	r18,24(sp)
101006dc:	dc400517 	ldw	r17,20(sp)
101006e0:	dc000417 	ldw	r16,16(sp)
101006e4:	dec00e04 	addi	sp,sp,56
101006e8:	f800283a 	ret

101006ec <msgdma_create_mm_to_st_descriptor_list>:



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101006ec:	defff404 	addi	sp,sp,-48
101006f0:	dc000215 	stw	r16,8(sp)

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
101006f4:	24001217 	ldw	r16,72(r4)



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
101006f8:	dd400715 	stw	r21,28(sp)
101006fc:	dd000615 	stw	r20,24(sp)
10100700:	202b883a 	mov	r21,r4
10100704:	2829883a 	mov	r20,r5

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100708:	393fffc4 	addi	r4,r7,-1
1010070c:	800b883a 	mov	r5,r16



uint32_t msgdma_create_mm_to_st_descriptor_list(alt_msgdma_dev* msgdma,
		alt_msgdma_standard_descriptor* msgdma_desc, void* address_source,
		uint32_t length) {
10100710:	df000a15 	stw	fp,40(sp)
10100714:	dd800815 	stw	r22,32(sp)
10100718:	dcc00515 	stw	r19,20(sp)
1010071c:	dfc00b15 	stw	ra,44(sp)
10100720:	ddc00915 	stw	r23,36(sp)
10100724:	dc800415 	stw	r18,16(sp)
10100728:	dc400315 	stw	r17,12(sp)
1010072c:	3027883a 	mov	r19,r6
10100730:	382d883a 	mov	r22,r7

	// Get the maximal size of a descriptor
	uint32_t max_descriptor_size = msgdma->max_byte;
	// Find the number of descriptor needed
	uint32_t descriptor_number = 1 + ((length - 1) / max_descriptor_size);
10100734:	010093c0 	call	1010093c <__udivsi3>
10100738:	1039883a 	mov	fp,r2
1010073c:	10800044 	addi	r2,r2,1
10100740:	d8800115 	stw	r2,4(sp)

	if (msgdma_desc == NULL) {
10100744:	a000051e 	bne	r20,zero,1010075c <msgdma_create_mm_to_st_descriptor_list+0x70>
		alt_printf("msgdma_create_descriptor_list: msgdma_desc == NULL");
10100748:	01040434 	movhi	r4,4112
1010074c:	21085504 	addi	r4,r4,8532
10100750:	0100b9c0 	call	10100b9c <alt_printf>
		return 0;
10100754:	0005883a 	mov	r2,zero
10100758:	00002506 	br	101007f0 <msgdma_create_mm_to_st_descriptor_list+0x104>
	}

	alt_printf("max_descriptor_size=0x%x, descriptor_number=0x%x\n",
1010075c:	d9800117 	ldw	r6,4(sp)
10100760:	01040434 	movhi	r4,4112
10100764:	21086204 	addi	r4,r4,8584
10100768:	800b883a 	mov	r5,r16
1010076c:	0100b9c0 	call	10100b9c <alt_printf>
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;
10100770:	9825883a 	mov	r18,r19

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
10100774:	0023883a 	mov	r17,zero
10100778:	882e913a 	slli	r23,r17,4
1010077c:	8f000e26 	beq	r17,fp,101007b8 <msgdma_create_mm_to_st_descriptor_list+0xcc>
		alt_printf("i=%d, src=0x%x\n", i, _address_src_descriptor);
10100780:	01040434 	movhi	r4,4112
10100784:	880b883a 	mov	r5,r17
10100788:	900d883a 	mov	r6,r18
1010078c:	21087604 	addi	r4,r4,8664
10100790:	0100b9c0 	call	10100b9c <alt_printf>

		alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma,
10100794:	900d883a 	mov	r6,r18
10100798:	d8000015 	stw	zero,0(sp)
1010079c:	a809883a 	mov	r4,r21
101007a0:	a5cb883a 	add	r5,r20,r23
101007a4:	800f883a 	mov	r7,r16
101007a8:	010131c0 	call	1010131c <alt_msgdma_construct_standard_mm_to_st_descriptor>
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;
101007ac:	9425883a 	add	r18,r18,r16
			max_descriptor_size, descriptor_number);

	uint8_t* _address_src_descriptor = (uint8_t *) address_source;

	uint32_t i = 0;
	for (i = 0; i < descriptor_number - 1; i++) {
101007b0:	8c400044 	addi	r17,r17,1
101007b4:	003ff006 	br	10100778 <msgdma_create_mm_to_st_descriptor_list+0x8c>
101007b8:	8c21383a 	mul	r16,r17,r16
				msgdma_desc + i, (uint32_t *) _address_src_descriptor, max_descriptor_size, 0);
		_address_src_descriptor += max_descriptor_size;

	}

	alt_printf("i=%d, src=0x%x, dst=0x%x\n", i, _address_src_descriptor);
101007bc:	01040434 	movhi	r4,4112
101007c0:	21086f04 	addi	r4,r4,8636
101007c4:	9c27883a 	add	r19,r19,r16
101007c8:	880b883a 	mov	r5,r17
101007cc:	980d883a 	mov	r6,r19
101007d0:	0100b9c0 	call	10100b9c <alt_printf>
	// Adjust the last descriptor
	alt_msgdma_construct_standard_mm_to_st_descriptor(msgdma, msgdma_desc + i,
101007d4:	a809883a 	mov	r4,r21
101007d8:	d8000015 	stw	zero,0(sp)
101007dc:	a5cb883a 	add	r5,r20,r23
101007e0:	980d883a 	mov	r6,r19
101007e4:	b40fc83a 	sub	r7,r22,r16
101007e8:	010131c0 	call	1010131c <alt_msgdma_construct_standard_mm_to_st_descriptor>
			(uint32_t *) _address_src_descriptor,
			length - max_descriptor_size * i, 0);

	return descriptor_number;
101007ec:	d8800117 	ldw	r2,4(sp)
}
101007f0:	dfc00b17 	ldw	ra,44(sp)
101007f4:	df000a17 	ldw	fp,40(sp)
101007f8:	ddc00917 	ldw	r23,36(sp)
101007fc:	dd800817 	ldw	r22,32(sp)
10100800:	dd400717 	ldw	r21,28(sp)
10100804:	dd000617 	ldw	r20,24(sp)
10100808:	dcc00517 	ldw	r19,20(sp)
1010080c:	dc800417 	ldw	r18,16(sp)
10100810:	dc400317 	ldw	r17,12(sp)
10100814:	dc000217 	ldw	r16,8(sp)
10100818:	dec00c04 	addi	sp,sp,48
1010081c:	f800283a 	ret

10100820 <udivmodsi4>:
10100820:	2900182e 	bgeu	r5,r4,10100884 <udivmodsi4+0x64>
10100824:	28001716 	blt	r5,zero,10100884 <udivmodsi4+0x64>
10100828:	00800804 	movi	r2,32
1010082c:	00c00044 	movi	r3,1
10100830:	00000206 	br	1010083c <udivmodsi4+0x1c>
10100834:	10001126 	beq	r2,zero,1010087c <udivmodsi4+0x5c>
10100838:	28000516 	blt	r5,zero,10100850 <udivmodsi4+0x30>
1010083c:	294b883a 	add	r5,r5,r5
10100840:	10bfffc4 	addi	r2,r2,-1
10100844:	18c7883a 	add	r3,r3,r3
10100848:	293ffa36 	bltu	r5,r4,10100834 <udivmodsi4+0x14>
1010084c:	18000b26 	beq	r3,zero,1010087c <udivmodsi4+0x5c>
10100850:	0005883a 	mov	r2,zero
10100854:	21400236 	bltu	r4,r5,10100860 <udivmodsi4+0x40>
10100858:	2149c83a 	sub	r4,r4,r5
1010085c:	10c4b03a 	or	r2,r2,r3
10100860:	1806d07a 	srli	r3,r3,1
10100864:	280ad07a 	srli	r5,r5,1
10100868:	183ffa1e 	bne	r3,zero,10100854 <udivmodsi4+0x34>
1010086c:	3000011e 	bne	r6,zero,10100874 <udivmodsi4+0x54>
10100870:	f800283a 	ret
10100874:	2005883a 	mov	r2,r4
10100878:	f800283a 	ret
1010087c:	0005883a 	mov	r2,zero
10100880:	003ffa06 	br	1010086c <udivmodsi4+0x4c>
10100884:	00c00044 	movi	r3,1
10100888:	003ff106 	br	10100850 <udivmodsi4+0x30>

1010088c <__divsi3>:
1010088c:	defffe04 	addi	sp,sp,-8
10100890:	dfc00115 	stw	ra,4(sp)
10100894:	dc000015 	stw	r16,0(sp)
10100898:	20000b16 	blt	r4,zero,101008c8 <__divsi3+0x3c>
1010089c:	0021883a 	mov	r16,zero
101008a0:	28000c16 	blt	r5,zero,101008d4 <__divsi3+0x48>
101008a4:	000d883a 	mov	r6,zero
101008a8:	01008200 	call	10100820 <udivmodsi4>
101008ac:	0407c83a 	sub	r3,zero,r16
101008b0:	1884f03a 	xor	r2,r3,r2
101008b4:	1405883a 	add	r2,r2,r16
101008b8:	dfc00117 	ldw	ra,4(sp)
101008bc:	dc000017 	ldw	r16,0(sp)
101008c0:	dec00204 	addi	sp,sp,8
101008c4:	f800283a 	ret
101008c8:	0109c83a 	sub	r4,zero,r4
101008cc:	04000044 	movi	r16,1
101008d0:	283ff40e 	bge	r5,zero,101008a4 <__divsi3+0x18>
101008d4:	014bc83a 	sub	r5,zero,r5
101008d8:	8400005c 	xori	r16,r16,1
101008dc:	003ff106 	br	101008a4 <__divsi3+0x18>

101008e0 <__modsi3>:
101008e0:	defffd04 	addi	sp,sp,-12
101008e4:	dfc00215 	stw	ra,8(sp)
101008e8:	dc400115 	stw	r17,4(sp)
101008ec:	dc000015 	stw	r16,0(sp)
101008f0:	20000c16 	blt	r4,zero,10100924 <__modsi3+0x44>
101008f4:	0023883a 	mov	r17,zero
101008f8:	0021883a 	mov	r16,zero
101008fc:	28000d16 	blt	r5,zero,10100934 <__modsi3+0x54>
10100900:	01800044 	movi	r6,1
10100904:	01008200 	call	10100820 <udivmodsi4>
10100908:	1404f03a 	xor	r2,r2,r16
1010090c:	8885883a 	add	r2,r17,r2
10100910:	dfc00217 	ldw	ra,8(sp)
10100914:	dc400117 	ldw	r17,4(sp)
10100918:	dc000017 	ldw	r16,0(sp)
1010091c:	dec00304 	addi	sp,sp,12
10100920:	f800283a 	ret
10100924:	0109c83a 	sub	r4,zero,r4
10100928:	04400044 	movi	r17,1
1010092c:	043fffc4 	movi	r16,-1
10100930:	283ff30e 	bge	r5,zero,10100900 <__modsi3+0x20>
10100934:	014bc83a 	sub	r5,zero,r5
10100938:	003ff106 	br	10100900 <__modsi3+0x20>

1010093c <__udivsi3>:
1010093c:	000d883a 	mov	r6,zero
10100940:	01008201 	jmpi	10100820 <udivmodsi4>

10100944 <__umodsi3>:
10100944:	01800044 	movi	r6,1
10100948:	01008201 	jmpi	10100820 <udivmodsi4>

1010094c <memcpy>:
1010094c:	2005883a 	mov	r2,r4
10100950:	0007883a 	mov	r3,zero
10100954:	19800626 	beq	r3,r6,10100970 <memcpy+0x24>
10100958:	28c9883a 	add	r4,r5,r3
1010095c:	21c00003 	ldbu	r7,0(r4)
10100960:	10c9883a 	add	r4,r2,r3
10100964:	18c00044 	addi	r3,r3,1
10100968:	21c00005 	stb	r7,0(r4)
1010096c:	003ff906 	br	10100954 <memcpy+0x8>
10100970:	f800283a 	ret

10100974 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
10100974:	0100a101 	jmpi	10100a10 <alt_iic_isr_register>

10100978 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100978:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
1010097c:	00bfff84 	movi	r2,-2
10100980:	3084703a 	and	r2,r6,r2
10100984:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
10100988:	00840434 	movhi	r2,4112
1010098c:	10892b04 	addi	r2,r2,9388
10100990:	01000044 	movi	r4,1
10100994:	10c00017 	ldw	r3,0(r2)
10100998:	214a983a 	sll	r5,r4,r5
1010099c:	28cab03a 	or	r5,r5,r3
101009a0:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
101009a4:	10800017 	ldw	r2,0(r2)
101009a8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101009ac:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
101009b0:	0005883a 	mov	r2,zero
101009b4:	f800283a 	ret

101009b8 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101009b8:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
101009bc:	00bfff84 	movi	r2,-2
101009c0:	3084703a 	and	r2,r6,r2
101009c4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
101009c8:	00840434 	movhi	r2,4112
101009cc:	10892b04 	addi	r2,r2,9388
101009d0:	013fff84 	movi	r4,-2
101009d4:	10c00017 	ldw	r3,0(r2)
101009d8:	214a183a 	rol	r5,r4,r5
101009dc:	28ca703a 	and	r5,r5,r3
101009e0:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
101009e4:	10800017 	ldw	r2,0(r2)
101009e8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101009ec:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
101009f0:	0005883a 	mov	r2,zero
101009f4:	f800283a 	ret

101009f8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
101009f8:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
101009fc:	00c00044 	movi	r3,1
10100a00:	194a983a 	sll	r5,r3,r5
10100a04:	1144703a 	and	r2,r2,r5
}
10100a08:	1004c03a 	cmpne	r2,r2,zero
10100a0c:	f800283a 	ret

10100a10 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
10100a10:	00c007c4 	movi	r3,31
10100a14:	19401616 	blt	r3,r5,10100a70 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
10100a18:	defffe04 	addi	sp,sp,-8
10100a1c:	dfc00115 	stw	ra,4(sp)
10100a20:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100a24:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100a28:	00ffff84 	movi	r3,-2
10100a2c:	80c6703a 	and	r3,r16,r3
10100a30:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
10100a34:	280490fa 	slli	r2,r5,3
10100a38:	00c40434 	movhi	r3,4112
10100a3c:	18c94c04 	addi	r3,r3,9520
10100a40:	1891883a 	add	r8,r3,r2
10100a44:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
10100a48:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
10100a4c:	30000226 	beq	r6,zero,10100a58 <alt_iic_isr_register+0x48>
10100a50:	01009780 	call	10100978 <alt_ic_irq_enable>
10100a54:	00000106 	br	10100a5c <alt_iic_isr_register+0x4c>
10100a58:	01009b80 	call	101009b8 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100a5c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
10100a60:	dfc00117 	ldw	ra,4(sp)
10100a64:	dc000017 	ldw	r16,0(sp)
10100a68:	dec00204 	addi	sp,sp,8
10100a6c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
10100a70:	00bffa84 	movi	r2,-22
10100a74:	f800283a 	ret

10100a78 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
10100a78:	deffff04 	addi	sp,sp,-4
10100a7c:	01040434 	movhi	r4,4112
10100a80:	01440434 	movhi	r5,4112
10100a84:	dfc00015 	stw	ra,0(sp)
10100a88:	2108ee04 	addi	r4,r4,9144
10100a8c:	29490b04 	addi	r5,r5,9260

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100a90:	2140061e 	bne	r4,r5,10100aac <alt_load+0x34>
10100a94:	01040434 	movhi	r4,4112
10100a98:	01440434 	movhi	r5,4112
10100a9c:	21000804 	addi	r4,r4,32
10100aa0:	29400804 	addi	r5,r5,32
10100aa4:	2140141e 	bne	r4,r5,10100af8 <alt_load+0x80>
10100aa8:	00000d06 	br	10100ae0 <alt_load+0x68>
10100aac:	00c40434 	movhi	r3,4112
10100ab0:	18c90b04 	addi	r3,r3,9260
10100ab4:	00bfff04 	movi	r2,-4
10100ab8:	1907c83a 	sub	r3,r3,r4
10100abc:	1886703a 	and	r3,r3,r2
10100ac0:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100ac4:	10fff326 	beq	r2,r3,10100a94 <alt_load+0x1c>
10100ac8:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100acc:	39c00017 	ldw	r7,0(r7)
10100ad0:	110d883a 	add	r6,r2,r4
10100ad4:	10800104 	addi	r2,r2,4
10100ad8:	31c00015 	stw	r7,0(r6)
10100adc:	003ff906 	br	10100ac4 <alt_load+0x4c>
10100ae0:	01040434 	movhi	r4,4112
10100ae4:	01440434 	movhi	r5,4112
10100ae8:	21079404 	addi	r4,r4,7760
10100aec:	29479404 	addi	r5,r5,7760

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100af0:	2140121e 	bne	r4,r5,10100b3c <alt_load+0xc4>
10100af4:	00000d06 	br	10100b2c <alt_load+0xb4>
10100af8:	00c40434 	movhi	r3,4112
10100afc:	18c05404 	addi	r3,r3,336
10100b00:	00bfff04 	movi	r2,-4
10100b04:	1907c83a 	sub	r3,r3,r4
10100b08:	1886703a 	and	r3,r3,r2
10100b0c:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100b10:	10fff326 	beq	r2,r3,10100ae0 <alt_load+0x68>
10100b14:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100b18:	39c00017 	ldw	r7,0(r7)
10100b1c:	110d883a 	add	r6,r2,r4
10100b20:	10800104 	addi	r2,r2,4
10100b24:	31c00015 	stw	r7,0(r6)
10100b28:	003ff906 	br	10100b10 <alt_load+0x98>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10100b2c:	0101cb40 	call	10101cb4 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10100b30:	dfc00017 	ldw	ra,0(sp)
10100b34:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
10100b38:	0101db81 	jmpi	10101db8 <alt_icache_flush_all>
10100b3c:	00c40434 	movhi	r3,4112
10100b40:	18c8ee04 	addi	r3,r3,9144
10100b44:	00bfff04 	movi	r2,-4
10100b48:	1907c83a 	sub	r3,r3,r4
10100b4c:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10100b50:	0005883a 	mov	r2,zero
  {
    while( to != end )
10100b54:	10fff526 	beq	r2,r3,10100b2c <alt_load+0xb4>
10100b58:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
10100b5c:	39c00017 	ldw	r7,0(r7)
10100b60:	110d883a 	add	r6,r2,r4
10100b64:	10800104 	addi	r2,r2,4
10100b68:	31c00015 	stw	r7,0(r6)
10100b6c:	003ff906 	br	10100b54 <alt_load+0xdc>

10100b70 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100b70:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100b74:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10100b78:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10100b7c:	0100d880 	call	10100d88 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10100b80:	0100da80 	call	10100da8 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100b84:	d1202817 	ldw	r4,-32608(gp)
10100b88:	d1602717 	ldw	r5,-32612(gp)
10100b8c:	d1a02617 	ldw	r6,-32616(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
10100b90:	dfc00017 	ldw	ra,0(sp)
10100b94:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10100b98:	01003001 	jmpi	10100300 <main>

10100b9c <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100b9c:	defff204 	addi	sp,sp,-56
10100ba0:	dfc00a15 	stw	ra,40(sp)
10100ba4:	df000915 	stw	fp,36(sp)
10100ba8:	ddc00815 	stw	r23,32(sp)
10100bac:	dd800715 	stw	r22,28(sp)
10100bb0:	dd400615 	stw	r21,24(sp)
10100bb4:	dd000515 	stw	r20,20(sp)
10100bb8:	dcc00415 	stw	r19,16(sp)
10100bbc:	dc800315 	stw	r18,12(sp)
10100bc0:	dc400215 	stw	r17,8(sp)
10100bc4:	dc000115 	stw	r16,4(sp)
10100bc8:	d9400b15 	stw	r5,44(sp)
10100bcc:	d9800c15 	stw	r6,48(sp)
10100bd0:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100bd4:	04000944 	movi	r16,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
10100bd8:	2005883a 	mov	r2,r4
	va_list args;
	va_start(args, fmt);
10100bdc:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
10100be0:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
10100be4:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100be8:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100bec:	11000007 	ldb	r4,0(r2)
10100bf0:	20003926 	beq	r4,zero,10100cd8 <alt_printf+0x13c>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
10100bf4:	24000226 	beq	r4,r16,10100c00 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
10100bf8:	14400044 	addi	r17,r2,1
10100bfc:	00001106 	br	10100c44 <alt_printf+0xa8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
10100c00:	14400084 	addi	r17,r2,2
10100c04:	10800047 	ldb	r2,1(r2)
10100c08:	10003326 	beq	r2,zero,10100cd8 <alt_printf+0x13c>
            {
                if (c == '%')
10100c0c:	1400021e 	bne	r2,r16,10100c18 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
10100c10:	8009883a 	mov	r4,r16
10100c14:	00000b06 	br	10100c44 <alt_printf+0xa8>
                } 
                else if (c == 'c')
10100c18:	1480051e 	bne	r2,r18,10100c30 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
10100c1c:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100c20:	ad800104 	addi	r22,r21,4
10100c24:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
10100c28:	0100d080 	call	10100d08 <alt_putchar>
10100c2c:	00002806 	br	10100cd0 <alt_printf+0x134>
                }
                else if (c == 'x')
10100c30:	14c01f1e 	bne	r2,r19,10100cb0 <alt_printf+0x114>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
10100c34:	adc00017 	ldw	r23,0(r21)
10100c38:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
10100c3c:	b800031e 	bne	r23,zero,10100c4c <alt_printf+0xb0>
                    {
                        alt_putchar('0');
10100c40:	01000c04 	movi	r4,48
10100c44:	0100d080 	call	10100d08 <alt_putchar>
                        continue;
10100c48:	00002106 	br	10100cd0 <alt_printf+0x134>
10100c4c:	05800704 	movi	r22,28
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
10100c50:	00c003c4 	movi	r3,15
10100c54:	1d84983a 	sll	r2,r3,r22
10100c58:	15c4703a 	and	r2,r2,r23
10100c5c:	1000021e 	bne	r2,zero,10100c68 <alt_printf+0xcc>
                        digit_shift -= 4;
10100c60:	b5bfff04 	addi	r22,r22,-4
10100c64:	003ffb06 	br	10100c54 <alt_printf+0xb8>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100c68:	070003c4 	movi	fp,15
                        if (digit <= 9)
10100c6c:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100c70:	b0001716 	blt	r22,zero,10100cd0 <alt_printf+0x134>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
10100c74:	e584983a 	sll	r2,fp,r22
10100c78:	15c4703a 	and	r2,r2,r23
10100c7c:	1584d83a 	srl	r2,r2,r22
                        if (digit <= 9)
10100c80:	18800236 	bltu	r3,r2,10100c8c <alt_printf+0xf0>
                            c = '0' + digit;
10100c84:	11000c04 	addi	r4,r2,48
10100c88:	00000106 	br	10100c90 <alt_printf+0xf4>
                        else
                            c = 'a' + digit - 10;
10100c8c:	110015c4 	addi	r4,r2,87
                        alt_putchar(c);
10100c90:	21003fcc 	andi	r4,r4,255
10100c94:	2100201c 	xori	r4,r4,128
10100c98:	213fe004 	addi	r4,r4,-128
10100c9c:	d8c00015 	stw	r3,0(sp)
10100ca0:	0100d080 	call	10100d08 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
10100ca4:	b5bfff04 	addi	r22,r22,-4
10100ca8:	d8c00017 	ldw	r3,0(sp)
10100cac:	003ff006 	br	10100c70 <alt_printf+0xd4>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
10100cb0:	1500071e 	bne	r2,r20,10100cd0 <alt_printf+0x134>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
10100cb4:	ad800017 	ldw	r22,0(r21)
10100cb8:	ad400104 	addi	r21,r21,4

                    while(*s)
10100cbc:	b1000007 	ldb	r4,0(r22)
10100cc0:	20000326 	beq	r4,zero,10100cd0 <alt_printf+0x134>
                      alt_putchar(*s++);
10100cc4:	b5800044 	addi	r22,r22,1
10100cc8:	0100d080 	call	10100d08 <alt_putchar>
10100ccc:	003ffb06 	br	10100cbc <alt_printf+0x120>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
10100cd0:	8805883a 	mov	r2,r17
10100cd4:	003fc506 	br	10100bec <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
10100cd8:	dfc00a17 	ldw	ra,40(sp)
10100cdc:	df000917 	ldw	fp,36(sp)
10100ce0:	ddc00817 	ldw	r23,32(sp)
10100ce4:	dd800717 	ldw	r22,28(sp)
10100ce8:	dd400617 	ldw	r21,24(sp)
10100cec:	dd000517 	ldw	r20,20(sp)
10100cf0:	dcc00417 	ldw	r19,16(sp)
10100cf4:	dc800317 	ldw	r18,12(sp)
10100cf8:	dc400217 	ldw	r17,8(sp)
10100cfc:	dc000117 	ldw	r16,4(sp)
10100d00:	dec00e04 	addi	sp,sp,56
10100d04:	f800283a 	ret

10100d08 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100d08:	defffd04 	addi	sp,sp,-12
10100d0c:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
10100d10:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100d14:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100d18:	01040434 	movhi	r4,4112
10100d1c:	21090704 	addi	r4,r4,9244
10100d20:	d80b883a 	mov	r5,sp
10100d24:	01800044 	movi	r6,1
10100d28:	000f883a 	mov	r7,zero
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
10100d2c:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
10100d30:	0100dbc0 	call	10100dbc <altera_avalon_jtag_uart_write>
10100d34:	00ffffc4 	movi	r3,-1
10100d38:	10c00126 	beq	r2,r3,10100d40 <alt_putchar+0x38>
        return -1;
    }
    return c;
10100d3c:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
10100d40:	dfc00217 	ldw	ra,8(sp)
10100d44:	dc000117 	ldw	r16,4(sp)
10100d48:	dec00304 	addi	sp,sp,12
10100d4c:	f800283a 	ret

10100d50 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
10100d50:	defffe04 	addi	sp,sp,-8
10100d54:	dc000015 	stw	r16,0(sp)
10100d58:	dfc00115 	stw	ra,4(sp)
10100d5c:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100d60:	0101e340 	call	10101e34 <strlen>
10100d64:	01040434 	movhi	r4,4112
10100d68:	21090704 	addi	r4,r4,9244
10100d6c:	800b883a 	mov	r5,r16
10100d70:	100d883a 	mov	r6,r2
10100d74:	000f883a 	mov	r7,zero
#else
    return fputs(str, stdout);
#endif
#endif
}
10100d78:	dfc00117 	ldw	ra,4(sp)
10100d7c:	dc000017 	ldw	r16,0(sp)
10100d80:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10100d84:	0100dbc1 	jmpi	10100dbc <altera_avalon_jtag_uart_write>

10100d88 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10100d88:	deffff04 	addi	sp,sp,-4
10100d8c:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
10100d90:	0101dc40 	call	10101dc4 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10100d94:	00800044 	movi	r2,1
10100d98:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10100d9c:	dfc00017 	ldw	ra,0(sp)
10100da0:	dec00104 	addi	sp,sp,4
10100da4:	f800283a 	ret

10100da8 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_MSGDMA_INIT ( MSGDMA_0, msgdma_0);
10100da8:	01040434 	movhi	r4,4112
10100dac:	2108ee04 	addi	r4,r4,9144
10100db0:	21400717 	ldw	r5,28(r4)
10100db4:	21800817 	ldw	r6,32(r4)
10100db8:	0101b201 	jmpi	10101b20 <alt_msgdma_init>

10100dbc <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10100dbc:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10100dc0:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
10100dc4:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100dc8:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10100dcc:	2980072e 	bgeu	r5,r6,10100dec <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10100dd0:	38c00037 	ldwio	r3,0(r7)
10100dd4:	18ffffec 	andhi	r3,r3,65535
10100dd8:	183ffc26 	beq	r3,zero,10100dcc <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10100ddc:	28c00007 	ldb	r3,0(r5)
10100de0:	20c00035 	stwio	r3,0(r4)
10100de4:	29400044 	addi	r5,r5,1
10100de8:	003ff806 	br	10100dcc <altera_avalon_jtag_uart_write+0x10>

  return count;
}
10100dec:	f800283a 	ret

10100df0 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100df0:	defffd04 	addi	sp,sp,-12
10100df4:	dc000015 	stw	r16,0(sp)
10100df8:	dfc00215 	stw	ra,8(sp)
10100dfc:	dc400115 	stw	r17,4(sp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100e00:	20801783 	ldbu	r2,94(r4)
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
10100e04:	2021883a 	mov	r16,r4
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
10100e08:	10000926 	beq	r2,zero,10100e30 <alt_msgdma_irq+0x40>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100e0c:	20c00617 	ldw	r3,24(r4)
10100e10:	19000037 	ldwio	r4,0(r3)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
10100e14:	00bffdc4 	movi	r2,-9
10100e18:	2084703a 	and	r2,r4,r2
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100e1c:	18800035 	stwio	r2,0(r3)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
10100e20:	80800617 	ldw	r2,24(r16)
10100e24:	00c00044 	movi	r3,1
10100e28:	10c00435 	stwio	r3,16(r2)
10100e2c:	00000906 	br	10100e54 <alt_msgdma_irq+0x64>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10100e30:	20800317 	ldw	r2,12(r4)
10100e34:	10800104 	addi	r2,r2,4
10100e38:	11000037 	ldwio	r4,0(r2)
10100e3c:	00fffbc4 	movi	r3,-17
10100e40:	20c6703a 	and	r3,r4,r3
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100e44:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
10100e48:	80800317 	ldw	r2,12(r16)
10100e4c:	00c08004 	movi	r3,512
10100e50:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
10100e54:	80c00b17 	ldw	r3,44(r16)
10100e58:	18000726 	beq	r3,zero,10100e78 <alt_msgdma_irq+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100e5c:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100e60:	00bfff84 	movi	r2,-2
10100e64:	8884703a 	and	r2,r17,r2
10100e68:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        dev->callback (dev->callback_context);
10100e6c:	81000c17 	ldw	r4,48(r16)
10100e70:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10100e74:	8801703a 	wrctl	status,r17
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
10100e78:	80801783 	ldbu	r2,94(r16)
10100e7c:	10000526 	beq	r2,zero,10100e94 <alt_msgdma_irq+0xa4>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
10100e80:	80c00617 	ldw	r3,24(r16)
10100e84:	18800037 	ldwio	r2,0(r3)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10100e88:	10800214 	ori	r2,r2,8
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
10100e8c:	18800035 	stwio	r2,0(r3)
10100e90:	00000506 	br	10100ea8 <alt_msgdma_irq+0xb8>
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
10100e94:	80800317 	ldw	r2,12(r16)
10100e98:	10800104 	addi	r2,r2,4
10100e9c:	10c00037 	ldwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
10100ea0:	18c00414 	ori	r3,r3,16
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10100ea4:	10c00035 	stwio	r3,0(r2)
    }

    return;
}
10100ea8:	dfc00217 	ldw	ra,8(sp)
10100eac:	dc400117 	ldw	r17,4(sp)
10100eb0:	dc000017 	ldw	r16,0(sp)
10100eb4:	dec00304 	addi	sp,sp,12
10100eb8:	f800283a 	ret

10100ebc <alt_msgdma_write_extended_descriptor>:
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100ebc:	20800037 	ldwio	r2,0(r4)
10100ec0:	1080010c 	andi	r2,r2,4
10100ec4:	1000151e 	bne	r2,zero,10100f1c <alt_msgdma_write_extended_descriptor+0x60>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
10100ec8:	30c00017 	ldw	r3,0(r6)
10100ecc:	28c00035 	stwio	r3,0(r5)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
10100ed0:	30c00117 	ldw	r3,4(r6)
10100ed4:	28c00135 	stwio	r3,4(r5)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
10100ed8:	30c00217 	ldw	r3,8(r6)
10100edc:	28c00235 	stwio	r3,8(r5)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
10100ee0:	30c0030b 	ldhu	r3,12(r6)
10100ee4:	28c0032d 	sthio	r3,12(r5)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
10100ee8:	30c00383 	ldbu	r3,14(r6)
10100eec:	28c003a5 	stbio	r3,14(r5)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
10100ef0:	30c003c3 	ldbu	r3,15(r6)
10100ef4:	28c003e5 	stbio	r3,15(r5)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
10100ef8:	30c0040b 	ldhu	r3,16(r6)
10100efc:	28c0042d 	sthio	r3,16(r5)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
10100f00:	30c0048b 	ldhu	r3,18(r6)
10100f04:	28c004ad 	sthio	r3,18(r5)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
10100f08:	28000535 	stwio	zero,20(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
10100f0c:	28000635 	stwio	zero,24(r5)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
10100f10:	30c00717 	ldw	r3,28(r6)
10100f14:	28c00735 	stwio	r3,28(r5)
		descriptor_base, 
    	descriptor->control);
    return 0;
10100f18:	f800283a 	ret
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
10100f1c:	00bff904 	movi	r2,-28
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
		descriptor_base, 
    	descriptor->control);
    return 0;
}
10100f20:	f800283a 	ret

10100f24 <alt_msgdma_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100f24:	20c00317 	ldw	r3,12(r4)
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100f28:	defffb04 	addi	sp,sp,-20
10100f2c:	dc800215 	stw	r18,8(sp)
10100f30:	dc400115 	stw	r17,4(sp)
10100f34:	dc000015 	stw	r16,0(sp)
10100f38:	2823883a 	mov	r17,r5
10100f3c:	2021883a 	mov	r16,r4
10100f40:	3025883a 	mov	r18,r6
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100f44:	18c00204 	addi	r3,r3,8
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10100f48:	dfc00415 	stw	ra,16(sp)
10100f4c:	dcc00315 	stw	r19,12(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100f50:	18800037 	ldwio	r2,0(r3)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10100f54:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100f58:	18c00037 	ldwio	r3,0(r3)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100f5c:	04c4e244 	movi	r19,5001
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
10100f60:	1806d43a 	srli	r3,r3,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100f64:	81000917 	ldw	r4,36(r16)
10100f68:	19001036 	bltu	r3,r4,10100fac <alt_msgdma_descriptor_sync_transfer+0x88>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
10100f6c:	01000044 	movi	r4,1
10100f70:	0101c3c0 	call	10101c3c <alt_busy_sleep>
10100f74:	98bfffc4 	addi	r2,r19,-1
10100f78:	1027883a 	mov	r19,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10100f7c:	10bfffcc 	andi	r2,r2,65535
10100f80:	1000031e 	bne	r2,zero,10100f90 <alt_msgdma_descriptor_sync_transfer+0x6c>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
10100f84:	01040434 	movhi	r4,4112
10100f88:	21087a04 	addi	r4,r4,8680
10100f8c:	00004806 	br	101010b0 <alt_msgdma_descriptor_sync_transfer+0x18c>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100f90:	80c00317 	ldw	r3,12(r16)
10100f94:	18c00204 	addi	r3,r3,8
10100f98:	18800037 	ldwio	r2,0(r3)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
10100f9c:	10bfffcc 	andi	r2,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10100fa0:	18c00037 	ldwio	r3,0(r3)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
10100fa4:	1806d43a 	srli	r3,r3,16
10100fa8:	003fee06 	br	10100f64 <alt_msgdma_descriptor_sync_transfer+0x40>
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10100fac:	113fef2e 	bgeu	r2,r4,10100f6c <alt_msgdma_descriptor_sync_transfer+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10100fb0:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10100fb4:	00bfff84 	movi	r2,-2
10100fb8:	9884703a 	and	r2,r19,r2
10100fbc:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10100fc0:	80800317 	ldw	r2,12(r16)
10100fc4:	00c00804 	movi	r3,32
10100fc8:	10c00135 	stwio	r3,4(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10100fcc:	80800317 	ldw	r2,12(r16)
10100fd0:	10c00037 	ldwio	r3,0(r2)
10100fd4:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
10100fd8:	88001026 	beq	r17,zero,1010101c <alt_msgdma_descriptor_sync_transfer+0xf8>
10100fdc:	9000101e 	bne	r18,zero,10101020 <alt_msgdma_descriptor_sync_transfer+0xfc>
10100fe0:	0484e244 	movi	r18,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
10100fe4:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
10100fe8:	80c00317 	ldw	r3,12(r16)
10100fec:	18c00037 	ldwio	r3,0(r3)
10100ff0:	18c0010c 	andi	r3,r3,4
10100ff4:	1800261e 	bne	r3,zero,10101090 <alt_msgdma_descriptor_sync_transfer+0x16c>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
10100ff8:	88c00017 	ldw	r3,0(r17)
10100ffc:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
10101000:	88c00117 	ldw	r3,4(r17)
10101004:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
10101008:	88c00217 	ldw	r3,8(r17)
1010100c:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
10101010:	88c00317 	ldw	r3,12(r17)
10101014:	10c00335 	stwio	r3,12(r2)
10101018:	00001206 	br	10101064 <alt_msgdma_descriptor_sync_transfer+0x140>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
1010101c:	9000021e 	bne	r18,zero,10101028 <alt_msgdma_descriptor_sync_transfer+0x104>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10101020:	00bfffc4 	movi	r2,-1
10101024:	00004406 	br	10101138 <alt_msgdma_descriptor_sync_transfer+0x214>
10101028:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
1010102c:	81000317 	ldw	r4,12(r16)
10101030:	81400417 	ldw	r5,16(r16)
10101034:	900d883a 	mov	r6,r18
10101038:	0100ebc0 	call	10100ebc <alt_msgdma_write_extended_descriptor>
1010103c:	10000926 	beq	r2,zero,10101064 <alt_msgdma_descriptor_sync_transfer+0x140>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101040:	01000044 	movi	r4,1
10101044:	0101c3c0 	call	10101c3c <alt_busy_sleep>
10101048:	88bfffc4 	addi	r2,r17,-1
1010104c:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101050:	10bfffcc 	andi	r2,r2,65535
10101054:	103ff51e 	bne	r2,zero,1010102c <alt_msgdma_descriptor_sync_transfer+0x108>
            {
                alt_printf("time out after 5 msec while writing extended" 
10101058:	01040434 	movhi	r4,4112
1010105c:	21089f04 	addi	r4,r4,8828
10101060:	00001306 	br	101010b0 <alt_msgdma_descriptor_sync_transfer+0x18c>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
10101064:	81000d17 	ldw	r4,52(r16)
10101068:	80c00317 	ldw	r3,12(r16)
1010106c:	00bff2c4 	movi	r2,-53
10101070:	2084703a 	and	r2,r4,r2
10101074:	10800114 	ori	r2,r2,4
10101078:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1010107c:	9801703a 	wrctl	status,r19
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
10101080:	80800317 	ldw	r2,12(r16)
10101084:	10800037 	ldwio	r2,0(r2)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
10101088:	0444e244 	movi	r17,5001
1010108c:	00000d06 	br	101010c4 <alt_msgdma_descriptor_sync_transfer+0x1a0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
10101090:	01000044 	movi	r4,1
10101094:	0101c3c0 	call	10101c3c <alt_busy_sleep>
10101098:	90bfffc4 	addi	r2,r18,-1
1010109c:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
101010a0:	10bfffcc 	andi	r2,r2,65535
101010a4:	103fcf1e 	bne	r2,zero,10100fe4 <alt_msgdma_descriptor_sync_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while writing standard" 
101010a8:	01040434 	movhi	r4,4112
101010ac:	21088e04 	addi	r4,r4,8760
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
101010b0:	0100b9c0 	call	10100b9c <alt_printf>
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
101010b4:	00bff084 	movi	r2,-62
101010b8:	00001f06 	br	10101138 <alt_msgdma_descriptor_sync_transfer+0x214>
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
101010bc:	80800317 	ldw	r2,12(r16)
101010c0:	10800037 	ldwio	r2,0(r2)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
101010c4:	10c0780c 	andi	r3,r2,480
101010c8:	18000b1e 	bne	r3,zero,101010f8 <alt_msgdma_descriptor_sync_transfer+0x1d4>
101010cc:	1080004c 	andi	r2,r2,1
101010d0:	10000b26 	beq	r2,zero,10101100 <alt_msgdma_descriptor_sync_transfer+0x1dc>
    {
        alt_busy_sleep(1); /* delay 1us */
101010d4:	01000044 	movi	r4,1
101010d8:	0101c3c0 	call	10101c3c <alt_busy_sleep>
101010dc:	88bfffc4 	addi	r2,r17,-1
101010e0:	1023883a 	mov	r17,r2
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
101010e4:	10bfffcc 	andi	r2,r2,65535
101010e8:	103ff41e 	bne	r2,zero,101010bc <alt_msgdma_descriptor_sync_transfer+0x198>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
101010ec:	01040434 	movhi	r4,4112
101010f0:	2108b004 	addi	r4,r4,8896
101010f4:	003fee06 	br	101010b0 <alt_msgdma_descriptor_sync_transfer+0x18c>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
101010f8:	00807804 	movi	r2,480
101010fc:	00000e06 	br	10101138 <alt_msgdma_descriptor_sync_transfer+0x214>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
10101100:	80800317 	ldw	r2,12(r16)
10101104:	10800104 	addi	r2,r2,4
10101108:	10c00037 	ldwio	r3,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
1010110c:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101110:	013fff84 	movi	r4,-2
10101114:	2908703a 	and	r4,r5,r4
10101118:	2001703a 	wrctl	status,r4
1010111c:	18c00814 	ori	r3,r3,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101120:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
10101124:	80800317 	ldw	r2,12(r16)
10101128:	10c00037 	ldwio	r3,0(r2)
1010112c:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101130:	2801703a 	wrctl	status,r5
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101134:	0005883a 	mov	r2,zero

}
10101138:	dfc00417 	ldw	ra,16(sp)
1010113c:	dcc00317 	ldw	r19,12(sp)
10101140:	dc800217 	ldw	r18,8(sp)
10101144:	dc400117 	ldw	r17,4(sp)
10101148:	dc000017 	ldw	r16,0(sp)
1010114c:	dec00504 	addi	sp,sp,20
10101150:	f800283a 	ret

10101154 <alt_msgdma_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10101154:	21c00317 	ldw	r7,12(r4)
10101158:	38c00204 	addi	r3,r7,8
1010115c:	18800037 	ldwio	r2,0(r3)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
10101160:	10bfffcc 	andi	r2,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
10101164:	18c00037 	ldwio	r3,0(r3)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101168:	22000917 	ldw	r8,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
1010116c:	1806d43a 	srli	r3,r3,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
10101170:	1a004b2e 	bgeu	r3,r8,101012a0 <alt_msgdma_descriptor_async_transfer+0x14c>
10101174:	12004a2e 	bgeu	r2,r8,101012a0 <alt_msgdma_descriptor_async_transfer+0x14c>
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
10101178:	defffc04 	addi	sp,sp,-16
1010117c:	dc800215 	stw	r18,8(sp)
10101180:	dc400115 	stw	r17,4(sp)
10101184:	dc000015 	stw	r16,0(sp)
10101188:	3025883a 	mov	r18,r6
1010118c:	2823883a 	mov	r17,r5
10101190:	2021883a 	mov	r16,r4
10101194:	dfc00315 	stw	ra,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101198:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
1010119c:	00bfff84 	movi	r2,-2
101011a0:	1884703a 	and	r2,r3,r2
101011a4:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
101011a8:	00800804 	movi	r2,32
101011ac:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
101011b0:	20800317 	ldw	r2,12(r4)
101011b4:	11000037 	ldwio	r4,0(r2)
101011b8:	11000035 	stwio	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
101011bc:	1801703a 	wrctl	status,r3
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
101011c0:	28001026 	beq	r5,zero,10101204 <alt_msgdma_descriptor_async_transfer+0xb0>
101011c4:	3000101e 	bne	r6,zero,10101208 <alt_msgdma_descriptor_async_transfer+0xb4>
101011c8:	0484e244 	movi	r18,5001
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
101011cc:	80800417 	ldw	r2,16(r16)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
101011d0:	80c00317 	ldw	r3,12(r16)
101011d4:	18c00037 	ldwio	r3,0(r3)
101011d8:	18c0010c 	andi	r3,r3,4
101011dc:	1800321e 	bne	r3,zero,101012a8 <alt_msgdma_descriptor_async_transfer+0x154>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
101011e0:	88c00017 	ldw	r3,0(r17)
101011e4:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
101011e8:	88c00117 	ldw	r3,4(r17)
101011ec:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
101011f0:	88c00217 	ldw	r3,8(r17)
101011f4:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
101011f8:	88c00317 	ldw	r3,12(r17)
101011fc:	10c00335 	stwio	r3,12(r2)
10101200:	00001406 	br	10101254 <alt_msgdma_descriptor_async_transfer+0x100>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
10101204:	3000021e 	bne	r6,zero,10101210 <alt_msgdma_descriptor_async_transfer+0xbc>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
10101208:	00bfffc4 	movi	r2,-1
1010120c:	00002f06 	br	101012cc <alt_msgdma_descriptor_async_transfer+0x178>
10101210:	0444e244 	movi	r17,5001
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
10101214:	81000317 	ldw	r4,12(r16)
10101218:	81400417 	ldw	r5,16(r16)
1010121c:	900d883a 	mov	r6,r18
10101220:	0100ebc0 	call	10100ebc <alt_msgdma_write_extended_descriptor>
10101224:	10000b26 	beq	r2,zero,10101254 <alt_msgdma_descriptor_async_transfer+0x100>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
10101228:	01000044 	movi	r4,1
1010122c:	0101c3c0 	call	10101c3c <alt_busy_sleep>
10101230:	88bfffc4 	addi	r2,r17,-1
10101234:	1023883a 	mov	r17,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
10101238:	10bfffcc 	andi	r2,r2,65535
1010123c:	103ff51e 	bne	r2,zero,10101214 <alt_msgdma_descriptor_async_transfer+0xc0>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
10101240:	01040434 	movhi	r4,4112
10101244:	2108d804 	addi	r4,r4,9056
10101248:	0100b9c0 	call	10100b9c <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
1010124c:	00bff084 	movi	r2,-62
10101250:	00001e06 	br	101012cc <alt_msgdma_descriptor_async_transfer+0x178>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
10101254:	81000b17 	ldw	r4,44(r16)
10101258:	81400317 	ldw	r5,12(r16)
1010125c:	00bfff84 	movi	r2,-2
10101260:	80c00d17 	ldw	r3,52(r16)
10101264:	20000426 	beq	r4,zero,10101278 <alt_msgdma_descriptor_async_transfer+0x124>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101268:	013ff7c4 	movi	r4,-33
1010126c:	1906703a 	and	r3,r3,r4
10101270:	18c00514 	ori	r3,r3,20
10101274:	00000306 	br	10101284 <alt_msgdma_descriptor_async_transfer+0x130>
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
10101278:	013ff3c4 	movi	r4,-49
1010127c:	1906703a 	and	r3,r3,r4
10101280:	18c00114 	ori	r3,r3,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101284:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101288:	2084703a 	and	r2,r4,r2
1010128c:	1001703a 	wrctl	status,r2
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
10101290:	28c00135 	stwio	r3,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101294:	2001703a 	wrctl	status,r4
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
10101298:	0005883a 	mov	r2,zero
1010129c:	00000b06 	br	101012cc <alt_msgdma_descriptor_async_transfer+0x178>
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
101012a0:	00bff904 	movi	r2,-28
101012a4:	f800283a 	ret
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
101012a8:	01000044 	movi	r4,1
101012ac:	0101c3c0 	call	10101c3c <alt_busy_sleep>
101012b0:	90bfffc4 	addi	r2,r18,-1
101012b4:	1025883a 	mov	r18,r2
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
101012b8:	10bfffcc 	andi	r2,r2,65535
101012bc:	103fc31e 	bne	r2,zero,101011cc <alt_msgdma_descriptor_async_transfer+0x78>
            {
                alt_printf("time out after 5 msec while waiting" 
101012c0:	01040434 	movhi	r4,4112
101012c4:	2108c204 	addi	r4,r4,8968
101012c8:	003fdf06 	br	10101248 <alt_msgdma_descriptor_async_transfer+0xf4>
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
    
    return 0;
}
101012cc:	dfc00317 	ldw	ra,12(sp)
101012d0:	dc800217 	ldw	r18,8(sp)
101012d4:	dc400117 	ldw	r17,4(sp)
101012d8:	dc000017 	ldw	r16,0(sp)
101012dc:	dec00404 	addi	sp,sp,16
101012e0:	f800283a 	ret

101012e4 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101012e4:	20801217 	ldw	r2,72(r4)
101012e8:	11c00a36 	bltu	r2,r7,10101314 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
101012ec:	20801703 	ldbu	r2,92(r4)
101012f0:	1000081e 	bne	r2,zero,10101314 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101012f4:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101012f8:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
101012fc:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101300:	10a00034 	orhi	r2,r2,32768
10101304:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101308:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010130c:	0005883a 	mov	r2,zero
10101310:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101314:	00bffa84 	movi	r2,-22
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
            write_address, length, control);
}
10101318:	f800283a 	ret

1010131c <alt_msgdma_construct_standard_mm_to_st_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
1010131c:	20801217 	ldw	r2,72(r4)
10101320:	11c00a36 	bltu	r2,r7,1010134c <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
10101324:	20801703 	ldbu	r2,92(r4)
10101328:	1000081e 	bne	r2,zero,1010134c <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010132c:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101330:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101334:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101338:	10a00034 	orhi	r2,r2,32768
1010133c:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101340:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101344:	0005883a 	mov	r2,zero
10101348:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
1010134c:	00bffa84 	movi	r2,-22
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            NULL, length, control);

}
10101350:	f800283a 	ret

10101354 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
10101354:	d8800017 	ldw	r2,0(sp)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101358:	20c01217 	ldw	r3,72(r4)
1010135c:	18800a36 	bltu	r3,r2,10101388 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
10101360:	20c01703 	ldbu	r3,92(r4)
10101364:	1800081e 	bne	r3,zero,10101388 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101368:	28800215 	stw	r2,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010136c:	d8800117 	ldw	r2,4(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101370:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101374:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101378:	10a00034 	orhi	r2,r2,32768
1010137c:	28800315 	stw	r2,12(r5)
    
    return 0;
10101380:	0005883a 	mov	r2,zero
10101384:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101388:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            write_address, length, control);
}
1010138c:	f800283a 	ret

10101390 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101390:	22401217 	ldw	r9,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
10101394:	da000117 	ldw	r8,4(sp)
10101398:	d8c00217 	ldw	r3,8(sp)
1010139c:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101013a0:	49c01736 	bltu	r9,r7,10101400 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < read_stride ||
101013a4:	22801417 	ldw	r10,80(r4)
       dev->max_stride < write_stride ||
101013a8:	127fffcc 	andi	r9,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101013ac:	5000021e 	bne	r10,zero,101013b8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x28>
101013b0:	22801317 	ldw	r10,76(r4)
101013b4:	52401236 	bltu	r10,r9,10101400 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < write_stride ||
101013b8:	22401703 	ldbu	r9,92(r4)
101013bc:	01000044 	movi	r4,1
101013c0:	49000f1e 	bne	r9,r4,10101400 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101013c4:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013c8:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101013cc:	28000015 	stw	zero,0(r5)
    descriptor->write_address_low = write_address;
101013d0:	29800115 	stw	r6,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101013d4:	10a00034 	orhi	r2,r2,32768
101013d8:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101013dc:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
101013e0:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
101013e4:	28000385 	stb	zero,14(r5)
    descriptor->write_burst_count = write_burst_count;
101013e8:	28c003c5 	stb	r3,15(r5)
    descriptor->read_stride = read_stride;
101013ec:	2800040d 	sth	zero,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101013f0:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101013f4:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101013f8:	0005883a 	mov	r2,zero
101013fc:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101400:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
10101404:	f800283a 	ret

10101408 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101408:	22401217 	ldw	r9,72(r4)
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
1010140c:	da000117 	ldw	r8,4(sp)
10101410:	d8c00217 	ldw	r3,8(sp)
10101414:	d8800317 	ldw	r2,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101418:	49c01736 	bltu	r9,r7,10101478 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
1010141c:	22801417 	ldw	r10,80(r4)
       dev->max_stride < read_stride ||
10101420:	127fffcc 	andi	r9,r2,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101424:	5000021e 	bne	r10,zero,10101430 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x28>
10101428:	22801317 	ldw	r10,76(r4)
1010142c:	52401236 	bltu	r10,r9,10101478 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101430:	22401703 	ldbu	r9,92(r4)
10101434:	01000044 	movi	r4,1
10101438:	49000f1e 	bne	r9,r4,10101478 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
1010143c:	2880040d 	sth	r2,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101440:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
10101444:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
10101448:	28000115 	stw	zero,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010144c:	10a00034 	orhi	r2,r2,32768
10101450:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
10101454:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
10101458:	2a00030d 	sth	r8,12(r5)
    descriptor->read_burst_count = read_burst_count;
1010145c:	28c00385 	stb	r3,14(r5)
    descriptor->write_burst_count = write_burst_count;
10101460:	280003c5 	stb	zero,15(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101464:	2800048d 	sth	zero,18(r5)
    descriptor->read_address_high = NULL;
10101468:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
1010146c:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101470:	0005883a 	mov	r2,zero
10101474:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101478:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
1010147c:	f800283a 	ret

10101480 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101480:	da000017 	ldw	r8,0(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
10101484:	22401217 	ldw	r9,72(r4)
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
10101488:	db400217 	ldw	r13,8(sp)
1010148c:	db000317 	ldw	r12,12(sp)
10101490:	dac00417 	ldw	r11,16(sp)
10101494:	d8c00517 	ldw	r3,20(sp)
10101498:	d8800617 	ldw	r2,24(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
1010149c:	4a001a36 	bltu	r9,r8,10101508 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
101014a0:	22801417 	ldw	r10,80(r4)
101014a4:	22401317 	ldw	r9,76(r4)
101014a8:	1bbfffcc 	andi	r14,r3,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
101014ac:	5000011e 	bne	r10,zero,101014b4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x34>
101014b0:	4b801536 	bltu	r9,r14,10101508 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
101014b4:	13bfffcc 	andi	r14,r2,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
101014b8:	5000011e 	bne	r10,zero,101014c0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x40>
101014bc:	4b801236 	bltu	r9,r14,10101508 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
101014c0:	22401703 	ldbu	r9,92(r4)
101014c4:	01000044 	movi	r4,1
101014c8:	49000f1e 	bne	r9,r4,10101508 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x88>
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101014cc:	2880048d 	sth	r2,18(r5)
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101014d0:	d8800117 	ldw	r2,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
101014d4:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
101014d8:	29c00115 	stw	r7,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101014dc:	10a00034 	orhi	r2,r2,32768
101014e0:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
101014e4:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
101014e8:	2b40030d 	sth	r13,12(r5)
    descriptor->read_burst_count = read_burst_count;
101014ec:	2b000385 	stb	r12,14(r5)
    descriptor->write_burst_count = write_burst_count;
101014f0:	2ac003c5 	stb	r11,15(r5)
    descriptor->read_stride = read_stride;
101014f4:	28c0040d 	sth	r3,16(r5)
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
101014f8:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
101014fc:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
10101500:	0005883a 	mov	r2,zero
10101504:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101508:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
1010150c:	f800283a 	ret

10101510 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
10101510:	d8800017 	ldw	r2,0(sp)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
10101514:	20c01217 	ldw	r3,72(r4)
10101518:	18800e36 	bltu	r3,r2,10101554 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
1010151c:	20c01703 	ldbu	r3,92(r4)
10101520:	18000c1e 	bne	r3,zero,10101554 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101524:	d8c00117 	ldw	r3,4(sp)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
10101528:	28800215 	stw	r2,8(r5)
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010152c:	00900034 	movhi	r2,16384
10101530:	10bfffc4 	addi	r2,r2,-1
10101534:	1884703a 	and	r2,r3,r2
10101538:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
1010153c:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101540:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
10101544:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101548:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
1010154c:	0005883a 	mov	r2,zero
10101550:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
10101554:	00bffa84 	movi	r2,-22
	alt_u32 length,
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, write_address, length, control);
}
10101558:	f800283a 	ret

1010155c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
1010155c:	20801217 	ldw	r2,72(r4)
10101560:	11c00e36 	bltu	r2,r7,1010159c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
10101564:	20801703 	ldbu	r2,92(r4)
10101568:	10000c1e 	bne	r2,zero,1010159c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
1010156c:	d8c00017 	ldw	r3,0(sp)
10101570:	00900034 	movhi	r2,16384
10101574:	10bfffc4 	addi	r2,r2,-1
10101578:	1884703a 	and	r2,r3,r2
1010157c:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
10101580:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
10101584:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
10101588:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
1010158c:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
10101590:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
10101594:	0005883a 	mov	r2,zero
10101598:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
1010159c:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		0, write_address, length, control);
}
101015a0:	f800283a 	ret

101015a4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
101015a4:	20801217 	ldw	r2,72(r4)
101015a8:	11c00e36 	bltu	r2,r7,101015e4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
101015ac:	20801703 	ldbu	r2,92(r4)
101015b0:	10000c1e 	bne	r2,zero,101015e4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101015b4:	d8c00017 	ldw	r3,0(sp)
101015b8:	00900034 	movhi	r2,16384
101015bc:	10bfffc4 	addi	r2,r2,-1
101015c0:	1884703a 	and	r2,r3,r2
101015c4:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
101015c8:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
101015cc:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
101015d0:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
101015d4:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
101015d8:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
101015dc:	0005883a 	mov	r2,zero
101015e0:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
101015e4:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, 0, length, control);
}
101015e8:	f800283a 	ret

101015ec <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101015ec:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
101015f0:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
101015f4:	da400217 	ldw	r9,8(sp)
101015f8:	da000317 	ldw	r8,12(sp)
101015fc:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101600:	50c01c36 	bltu	r10,r3,10101674 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
10101604:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < write_stride ||
10101608:	12bfffcc 	andi	r10,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
1010160c:	5800021e 	bne	r11,zero,10101618 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x2c>
10101610:	22c01317 	ldw	r11,76(r4)
10101614:	5a801736 	bltu	r11,r10,10101674 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < write_stride ||
10101618:	22801703 	ldbu	r10,92(r4)
1010161c:	01000044 	movi	r4,1
10101620:	5100141e 	bne	r10,r4,10101674 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
10101624:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101628:	d8c00117 	ldw	r3,4(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
1010162c:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101630:	00900034 	movhi	r2,16384
10101634:	10bfffc4 	addi	r2,r2,-1
10101638:	1884703a 	and	r2,r3,r2
1010163c:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101640:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
10101644:	28000915 	stw	zero,36(r5)
    descriptor->read_address_low = read_address_low;
10101648:	28000015 	stw	zero,0(r5)
    descriptor->write_address_high = write_address_high;
1010164c:	29800a15 	stw	r6,40(r5)
    descriptor->write_address_low = write_address_low;
10101650:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
10101654:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101658:	28000785 	stb	zero,30(r5)
    descriptor->write_burst_count = write_burst_count;
1010165c:	2a0007c5 	stb	r8,31(r5)
    descriptor->read_stride = read_stride;
10101660:	2800080d 	sth	zero,32(r5)
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
10101664:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
10101668:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
1010166c:	0005883a 	mov	r2,zero
10101670:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101674:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
10101678:	f800283a 	ret

1010167c <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
1010167c:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101680:	22801217 	ldw	r10,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
10101684:	da400217 	ldw	r9,8(sp)
10101688:	da000317 	ldw	r8,12(sp)
1010168c:	d8800417 	ldw	r2,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101690:	50c01c36 	bltu	r10,r3,10101704 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
10101694:	22c01417 	ldw	r11,80(r4)
       dev->max_stride < read_stride ||
10101698:	12bfffcc 	andi	r10,r2,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
1010169c:	5800021e 	bne	r11,zero,101016a8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x2c>
101016a0:	22c01317 	ldw	r11,76(r4)
101016a4:	5a801736 	bltu	r11,r10,10101704 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
101016a8:	22801703 	ldbu	r10,92(r4)
101016ac:	01000044 	movi	r4,1
101016b0:	5100141e 	bne	r10,r4,10101704 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
101016b4:	28c00215 	stw	r3,8(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101016b8:	d8c00117 	ldw	r3,4(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
101016bc:	2880080d 	sth	r2,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
101016c0:	00900034 	movhi	r2,16384
101016c4:	10bfffc4 	addi	r2,r2,-1
101016c8:	1884703a 	and	r2,r3,r2
101016cc:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
101016d0:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
101016d4:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
101016d8:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
101016dc:	28000a15 	stw	zero,40(r5)
    descriptor->write_address_low = write_address_low;
101016e0:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
101016e4:	2a40070d 	sth	r9,28(r5)
    descriptor->read_burst_count = read_burst_count;
101016e8:	2a000785 	stb	r8,30(r5)
    descriptor->write_burst_count = write_burst_count;
101016ec:	280007c5 	stb	zero,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
101016f0:	2800088d 	sth	zero,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
101016f4:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
101016f8:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101016fc:	0005883a 	mov	r2,zero
10101700:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
10101704:	00bffa84 	movi	r2,-22
	alt_u16 read_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
10101708:	f800283a 	ret

1010170c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
1010170c:	da000217 	ldw	r8,8(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101710:	22401217 	ldw	r9,72(r4)
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
10101714:	db400417 	ldw	r13,16(sp)
10101718:	db000517 	ldw	r12,20(sp)
1010171c:	dac00617 	ldw	r11,24(sp)
10101720:	d8c00717 	ldw	r3,28(sp)
10101724:	d8800817 	ldw	r2,32(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101728:	4a002136 	bltu	r9,r8,101017b0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
1010172c:	22801417 	ldw	r10,80(r4)
10101730:	22401317 	ldw	r9,76(r4)
10101734:	1bbfffcc 	andi	r14,r3,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
10101738:	5000011e 	bne	r10,zero,10101740 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x34>
1010173c:	4b801c36 	bltu	r9,r14,101017b0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
10101740:	13bfffcc 	andi	r14,r2,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
10101744:	5000011e 	bne	r10,zero,1010174c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x40>
10101748:	4b801936 	bltu	r9,r14,101017b0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
       dev->max_stride < write_stride ||
1010174c:	22401703 	ldbu	r9,92(r4)
10101750:	01000044 	movi	r4,1
10101754:	4900161e 	bne	r9,r4,101017b0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa4>
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
10101758:	d9000017 	ldw	r4,0(sp)
    descriptor->write_address_low = write_address_low;
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
1010175c:	28c0080d 	sth	r3,32(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101760:	d8c00317 	ldw	r3,12(sp)
    descriptor->transfer_length = length;
    descriptor->sequence_number = sequence_number;
    descriptor->read_burst_count = read_burst_count;
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
10101764:	2880088d 	sth	r2,34(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101768:	00900034 	movhi	r2,16384
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
1010176c:	29000a15 	stw	r4,40(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101770:	10bfffc4 	addi	r2,r2,-1
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
10101774:	d9000117 	ldw	r4,4(sp)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
10101778:	1884703a 	and	r2,r3,r2
1010177c:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
10101780:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
10101784:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
10101788:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
1010178c:	29000115 	stw	r4,4(r5)
    descriptor->transfer_length = length;
10101790:	2a000215 	stw	r8,8(r5)
    descriptor->sequence_number = sequence_number;
10101794:	2b40070d 	sth	r13,28(r5)
    descriptor->read_burst_count = read_burst_count;
10101798:	2b000785 	stb	r12,30(r5)
    descriptor->write_burst_count = write_burst_count;
1010179c:	2ac007c5 	stb	r11,31(r5)
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
101017a0:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
101017a4:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
101017a8:	0005883a 	mov	r2,zero
101017ac:	f800283a 	ret
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
101017b0:	00bffa84 	movi	r2,-22
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
101017b4:	f800283a 	ret

101017b8 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
101017b8:	28001126 	beq	r5,zero,10101800 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
101017bc:	29800317 	ldw	r6,12(r5)
101017c0:	29800f1e 	bne	r5,r6,10101800 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
101017c4:	20800017 	ldw	r2,0(r4)
101017c8:	1000021e 	bne	r2,zero,101017d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x1c>
	{
		*list = descriptor;  /* make this root-node if list is empty */
101017cc:	21400015 	stw	r5,0(r4)
		return 0;  /* successfully added */
101017d0:	f800283a 	ret
	}
	if (*list == descriptor)
101017d4:	11400a26 	beq	r2,r5,10101800 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
101017d8:	1007883a 	mov	r3,r2
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
101017dc:	19000317 	ldw	r4,12(r3)
101017e0:	20800326 	beq	r4,r2,101017f0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x38>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
101017e4:	21800626 	beq	r4,r6,10101800 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x48>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
101017e8:	2007883a 	mov	r3,r4
101017ec:	003ffb06 	br	101017dc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x24>
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
101017f0:	19800315 	stw	r6,12(r3)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
101017f4:	28800315 	stw	r2,12(r5)
	return 0; /* successfully added */
101017f8:	0005883a 	mov	r2,zero
101017fc:	f800283a 	ret
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
10101800:	00bffa84 	movi	r2,-22
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
	return 0; /* successfully added */
}
10101804:	f800283a 	ret

10101808 <alt_msgdma_prefetcher_add_extended_desc_to_list>:
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
10101808:	2800021e 	bne	r5,zero,10101814 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
1010180c:	00bffa84 	movi	r2,-22
10101810:	f800283a 	ret
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
10101814:	28800317 	ldw	r2,12(r5)
10101818:	11400226 	beq	r2,r5,10101824 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x1c>
1010181c:	28800b17 	ldw	r2,44(r5)
10101820:	103ffa1e 	bne	r2,zero,1010180c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
10101824:	20800017 	ldw	r2,0(r4)
10101828:	1000021e 	bne	r2,zero,10101834 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
1010182c:	21400015 	stw	r5,0(r4)
		return 0;
10101830:	f800283a 	ret
	}
	if (*list == descriptor)
10101834:	117ff526 	beq	r2,r5,1010180c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x4>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
10101838:	1007883a 	mov	r3,r2
1010183c:	11000317 	ldw	r4,12(r2)
10101840:	20c0061e 	bne	r4,r3,1010185c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x54>
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
10101844:	11400315 	stw	r5,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
10101848:	10000b15 	stw	zero,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
1010184c:	28c00315 	stw	r3,12(r5)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
10101850:	28000b15 	stw	zero,44(r5)
	return 0;
10101854:	0005883a 	mov	r2,zero
10101858:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
1010185c:	11800b17 	ldw	r6,44(r2)
10101860:	303ff826 	beq	r6,zero,10101844 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x3c>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
10101864:	2005883a 	mov	r2,r4
10101868:	003ff406 	br	1010183c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x34>

1010186c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
1010186c:	20000a26 	beq	r4,zero,10101898 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
10101870:	2005883a 	mov	r2,r4
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
10101874:	10c00717 	ldw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101878:	11400317 	ldw	r5,12(r2)
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
1010187c:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
10101880:	10c00715 	stw	r3,28(r2)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
10101884:	21400226 	beq	r4,r5,10101890 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x24>
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
10101888:	2805883a 	mov	r2,r5
1010188c:	003ff906 	br	10101874 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x8>
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
10101890:	0005883a 	mov	r2,zero
10101894:	f800283a 	ret
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
10101898:	00bffa84 	movi	r2,-22
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
}
1010189c:	f800283a 	ret

101018a0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
101018a0:	20000f26 	beq	r4,zero,101018e0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
101018a4:	200b883a 	mov	r5,r4
101018a8:	20c00317 	ldw	r3,12(r4)
101018ac:	1940051e 	bne	r3,r5,101018c4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x24>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101018b0:	20800f17 	ldw	r2,60(r4)
101018b4:	10900034 	orhi	r2,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
101018b8:	20800f15 	stw	r2,60(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
101018bc:	0005883a 	mov	r2,zero
101018c0:	f800283a 	ret
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
101018c4:	20800b17 	ldw	r2,44(r4)
101018c8:	103ff926 	beq	r2,zero,101018b0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x10>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
101018cc:	20800f17 	ldw	r2,60(r4)
101018d0:	10900034 	orhi	r2,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
101018d4:	20800f15 	stw	r2,60(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
101018d8:	1809883a 	mov	r4,r3
101018dc:	003ff206 	br	101018a8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8>
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
101018e0:	00bffa84 	movi	r2,-22
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
}
101018e4:	f800283a 	ret

101018e8 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
101018e8:	da800017 	ldw	r10,0(sp)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
101018ec:	20800617 	ldw	r2,24(r4)
101018f0:	10800037 	ldwio	r2,0(r2)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
101018f4:	10c0004c 	andi	r3,r2,1
101018f8:	18003b1e 	bne	r3,zero,101019e8 <alt_msgdma_start_prefetcher_with_list_addr+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
101018fc:	0011303a 	rdctl	r8,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101900:	00ffff84 	movi	r3,-2
10101904:	40d2703a 	and	r9,r8,r3
10101908:	4801703a 	wrctl	status,r9
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
1010190c:	22400317 	ldw	r9,12(r4)
10101910:	02c00804 	movi	r11,32
10101914:	4ac00135 	stwio	r11,4(r9)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
10101918:	22400317 	ldw	r9,12(r4)
1010191c:	4ac00037 	ldwio	r11,0(r9)
10101920:	4ac00035 	stwio	r11,0(r9)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101924:	4001703a 	wrctl	status,r8
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
10101928:	22400b17 	ldw	r9,44(r4)
1010192c:	22c00317 	ldw	r11,12(r4)
10101930:	22000d17 	ldw	r8,52(r4)
10101934:	48000526 	beq	r9,zero,1010194c <alt_msgdma_start_prefetcher_with_list_addr+0x64>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
10101938:	027ff7c4 	movi	r9,-33
1010193c:	4250703a 	and	r8,r8,r9
10101940:	42000514 	ori	r8,r8,20
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
10101944:	10800214 	ori	r2,r2,8
10101948:	00000506 	br	10101960 <alt_msgdma_start_prefetcher_with_list_addr+0x78>
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
1010194c:	027ff3c4 	movi	r9,-49
10101950:	4250703a 	and	r8,r8,r9
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
10101954:	027ffdc4 	movi	r9,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
10101958:	42000114 	ori	r8,r8,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
1010195c:	1244703a 	and	r2,r2,r9
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10101960:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10101964:	48c6703a 	and	r3,r9,r3
10101968:	1801703a 	wrctl	status,r3
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
1010196c:	5a000135 	stwio	r8,4(r11)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
10101970:	20c00617 	ldw	r3,24(r4)
10101974:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10101978:	4801703a 	wrctl	status,r9
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
1010197c:	20c00617 	ldw	r3,24(r4)
10101980:	19400135 	stwio	r5,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
10101984:	20c00617 	ldw	r3,24(r4)
10101988:	19800235 	stwio	r6,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
1010198c:	39c03fcc 	andi	r7,r7,255
10101990:	38000226 	beq	r7,zero,1010199c <alt_msgdma_start_prefetcher_with_list_addr+0xb4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
10101994:	10800414 	ori	r2,r2,16
10101998:	00000206 	br	101019a4 <alt_msgdma_start_prefetcher_with_list_addr+0xbc>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
1010199c:	00fffbc4 	movi	r3,-17
101019a0:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
101019a4:	50c03fcc 	andi	r3,r10,255
101019a8:	18000826 	beq	r3,zero,101019cc <alt_msgdma_start_prefetcher_with_list_addr+0xe4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101019ac:	20c00617 	ldw	r3,24(r4)
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
101019b0:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101019b4:	18c00304 	addi	r3,r3,12
101019b8:	19400037 	ldwio	r5,0(r3)
101019bc:	2800051e 	bne	r5,zero,101019d4 <alt_msgdma_start_prefetcher_with_list_addr+0xec>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
101019c0:	01403fc4 	movi	r5,255
101019c4:	19400035 	stwio	r5,0(r3)
101019c8:	00000206 	br	101019d4 <alt_msgdma_start_prefetcher_with_list_addr+0xec>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
101019cc:	00ffff44 	movi	r3,-3
101019d0:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101019d4:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
101019d8:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
101019dc:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
101019e0:	0005883a 	mov	r2,zero
101019e4:	f800283a 	ret
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
101019e8:	00bffc04 	movi	r2,-16
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
}
101019ec:	f800283a 	ret

101019f0 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
101019f0:	defffa04 	addi	sp,sp,-24
101019f4:	dc800415 	stw	r18,16(sp)
101019f8:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
101019fc:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
10101a00:	dc400315 	stw	r17,12(sp)
10101a04:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
10101a08:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
10101a0c:	dfc00515 	stw	ra,20(sp)
10101a10:	3023883a 	mov	r17,r6
10101a14:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
10101a18:	010186c0 	call	1010186c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
10101a1c:	d9400117 	ldw	r5,4(sp)
10101a20:	1000071e 	bne	r2,zero,10101a40 <alt_msgdma_start_prefetcher_with_std_desc_list+0x50>
		return -EINVAL;
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
10101a24:	84003fcc 	andi	r16,r16,255
10101a28:	dc000015 	stw	r16,0(sp)
10101a2c:	9009883a 	mov	r4,r18
10101a30:	000d883a 	mov	r6,zero
10101a34:	89c03fcc 	andi	r7,r17,255
10101a38:	01018e80 	call	101018e8 <alt_msgdma_start_prefetcher_with_list_addr>
10101a3c:	00000106 	br	10101a44 <alt_msgdma_start_prefetcher_with_std_desc_list+0x54>
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101a40:	00bffa84 	movi	r2,-22
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
			park_mode_en, poll_en);
}
10101a44:	dfc00517 	ldw	ra,20(sp)
10101a48:	dc800417 	ldw	r18,16(sp)
10101a4c:	dc400317 	ldw	r17,12(sp)
10101a50:	dc000217 	ldw	r16,8(sp)
10101a54:	dec00604 	addi	sp,sp,24
10101a58:	f800283a 	ret

10101a5c <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101a5c:	defffa04 	addi	sp,sp,-24
10101a60:	dc800415 	stw	r18,16(sp)
10101a64:	2025883a 	mov	r18,r4
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101a68:	2809883a 	mov	r4,r5
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101a6c:	dc400315 	stw	r17,12(sp)
10101a70:	dc000215 	stw	r16,8(sp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101a74:	d9400115 	stw	r5,4(sp)
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
10101a78:	dfc00515 	stw	ra,20(sp)
10101a7c:	3023883a 	mov	r17,r6
10101a80:	3821883a 	mov	r16,r7
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
10101a84:	01018a00 	call	101018a0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
10101a88:	d9400117 	ldw	r5,4(sp)
10101a8c:	1000071e 	bne	r2,zero,10101aac <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
10101a90:	84003fcc 	andi	r16,r16,255
10101a94:	dc000015 	stw	r16,0(sp)
10101a98:	9009883a 	mov	r4,r18
10101a9c:	000d883a 	mov	r6,zero
10101aa0:	89c03fcc 	andi	r7,r17,255
10101aa4:	01018e80 	call	101018e8 <alt_msgdma_start_prefetcher_with_list_addr>
10101aa8:	00000106 	br	10101ab0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x54>
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
10101aac:	00bffa84 	movi	r2,-22
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
			park_mode_en, poll_en);
}
10101ab0:	dfc00517 	ldw	ra,20(sp)
10101ab4:	dc800417 	ldw	r18,16(sp)
10101ab8:	dc400317 	ldw	r17,12(sp)
10101abc:	dc000217 	ldw	r16,8(sp)
10101ac0:	dec00604 	addi	sp,sp,24
10101ac4:	f800283a 	ret

10101ac8 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
10101ac8:	defffe04 	addi	sp,sp,-8
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
10101acc:	d1600204 	addi	r5,gp,-32760
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
10101ad0:	dc000015 	stw	r16,0(sp)
10101ad4:	dfc00115 	stw	ra,4(sp)
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
10101ad8:	0101d440 	call	10101d44 <alt_find_dev>
10101adc:	1021883a 	mov	r16,r2

    if (NULL == dev)
10101ae0:	10000a1e 	bne	r2,zero,10101b0c <alt_msgdma_open+0x44>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
10101ae4:	00840434 	movhi	r2,4112
10101ae8:	10890a04 	addi	r2,r2,9256
10101aec:	10800017 	ldw	r2,0(r2)
10101af0:	10000226 	beq	r2,zero,10101afc <alt_msgdma_open+0x34>
10101af4:	103ee83a 	callr	r2
10101af8:	00000206 	br	10101b04 <alt_msgdma_open+0x3c>
10101afc:	00840434 	movhi	r2,4112
10101b00:	10892f04 	addi	r2,r2,9404
    {
        ALT_ERRNO = ENODEV;
10101b04:	00c004c4 	movi	r3,19
10101b08:	10c00015 	stw	r3,0(r2)
    }

    return dev;
}
10101b0c:	8005883a 	mov	r2,r16
10101b10:	dfc00117 	ldw	ra,4(sp)
10101b14:	dc000017 	ldw	r16,0(sp)
10101b18:	dec00204 	addi	sp,sp,8
10101b1c:	f800283a 	ret

10101b20 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101b20:	defffb04 	addi	sp,sp,-20
10101b24:	dc800315 	stw	r18,12(sp)
10101b28:	dc400215 	stw	r17,8(sp)
10101b2c:	dc000115 	stw	r16,4(sp)
10101b30:	dfc00415 	stw	ra,16(sp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101b34:	20801783 	ldbu	r2,94(r4)
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10101b38:	2021883a 	mov	r16,r4
10101b3c:	2825883a 	mov	r18,r5
10101b40:	3023883a 	mov	r17,r6
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
10101b44:	1000041e 	bne	r2,zero,10101b58 <alt_msgdma_init+0x38>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
10101b48:	80800317 	ldw	r2,12(r16)
10101b4c:	00c00084 	movi	r3,2
10101b50:	10c00135 	stwio	r3,4(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101b54:	00000806 	br	10101b78 <alt_msgdma_init+0x58>
    int error;

    if (dev->prefetcher_enable)
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
10101b58:	20800617 	ldw	r2,24(r4)
10101b5c:	00c00104 	movi	r3,4
10101b60:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
10101b64:	80800617 	ldw	r2,24(r16)
10101b68:	10800037 	ldwio	r2,0(r2)
10101b6c:	1080010c 	andi	r2,r2,4
10101b70:	103ffc1e 	bne	r2,zero,10101b64 <alt_msgdma_init+0x44>
10101b74:	003ff406 	br	10101b48 <alt_msgdma_init+0x28>
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101b78:	80800317 	ldw	r2,12(r16)
10101b7c:	10c00037 	ldwio	r3,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
10101b80:	18c0100c 	andi	r3,r3,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
10101b84:	183ffc1e 	bne	r3,zero,10101b78 <alt_msgdma_init+0x58>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
10101b88:	10800104 	addi	r2,r2,4
10101b8c:	11000037 	ldwio	r4,0(r2)
10101b90:	00fffbc4 	movi	r3,-17
10101b94:	20c6703a 	and	r3,r4,r3
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
10101b98:	18c00814 	ori	r3,r3,32
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
10101b9c:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
10101ba0:	80800317 	ldw	r2,12(r16)
10101ba4:	10c00037 	ldwio	r3,0(r2)
10101ba8:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
10101bac:	80801783 	ldbu	r2,94(r16)
10101bb0:	10000426 	beq	r2,zero,10101bc4 <alt_msgdma_init+0xa4>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
10101bb4:	80800617 	ldw	r2,24(r16)
10101bb8:	10800404 	addi	r2,r2,16
10101bbc:	10c00037 	ldwio	r3,0(r2)
10101bc0:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
10101bc4:	8009883a 	mov	r4,r16
10101bc8:	d1600204 	addi	r5,gp,-32760
10101bcc:	0101ccc0 	call	10101ccc <alt_dev_llist_insert>
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
            
    if (!error)
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
10101bd0:	01840434 	movhi	r6,4112
10101bd4:	d8000015 	stw	zero,0(sp)
10101bd8:	9009883a 	mov	r4,r18
10101bdc:	880b883a 	mov	r5,r17
10101be0:	31837c04 	addi	r6,r6,3568
10101be4:	800f883a 	mov	r7,r16
10101be8:	01009740 	call	10100974 <alt_ic_isr_register>
        alt_printf("failed to create semaphores\n");
    }
    
    return;

}
10101bec:	dfc00417 	ldw	ra,16(sp)
10101bf0:	dc800317 	ldw	r18,12(sp)
10101bf4:	dc400217 	ldw	r17,8(sp)
10101bf8:	dc000117 	ldw	r16,4(sp)
10101bfc:	dec00504 	addi	sp,sp,20
10101c00:	f800283a 	ret

10101c04 <alt_msgdma_register_callback>:
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
    dev->callback         = callback;
10101c04:	21400b15 	stw	r5,44(r4)
    dev->callback_context = context;
10101c08:	21c00c15 	stw	r7,48(r4)
    dev->control          = control;
10101c0c:	21800d15 	stw	r6,52(r4)
10101c10:	f800283a 	ret

10101c14 <alt_msgdma_standard_descriptor_async_transfer>:
{
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
10101c14:	000d883a 	mov	r6,zero
10101c18:	01011541 	jmpi	10101154 <alt_msgdma_descriptor_async_transfer>

10101c1c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101c1c:	280d883a 	mov	r6,r5
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
10101c20:	000b883a 	mov	r5,zero
10101c24:	01011541 	jmpi	10101154 <alt_msgdma_descriptor_async_transfer>

10101c28 <alt_msgdma_standard_descriptor_sync_transfer>:
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
10101c28:	000d883a 	mov	r6,zero
10101c2c:	0100f241 	jmpi	10100f24 <alt_msgdma_descriptor_sync_transfer>

10101c30 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
10101c30:	280d883a 	mov	r6,r5
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
10101c34:	000b883a 	mov	r5,zero
10101c38:	0100f241 	jmpi	10100f24 <alt_msgdma_descriptor_sync_transfer>

10101c3c <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101c3c:	01420034 	movhi	r5,2048
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101c40:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101c44:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
10101c48:	dc000015 	stw	r16,0(sp)
10101c4c:	dfc00115 	stw	ra,4(sp)
10101c50:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
10101c54:	010093c0 	call	1010093c <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101c58:	10000e26 	beq	r2,zero,10101c94 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101c5c:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101c60:	013e0034 	movhi	r4,63488
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
10101c64:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101c68:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101c6c:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10101c70:	297fffc4 	addi	r5,r5,-1
10101c74:	283ffe1e 	bne	r5,zero,10101c70 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101c78:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10101c7c:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10101c80:	18bffb16 	blt	r3,r2,10101c70 <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101c84:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101c88:	843fffc4 	addi	r16,r16,-1
10101c8c:	803ffe1e 	bne	r16,zero,10101c88 <alt_busy_sleep+0x4c>
10101c90:	00000306 	br	10101ca0 <alt_busy_sleep+0x64>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
10101c94:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
10101c98:	843fffc4 	addi	r16,r16,-1
10101c9c:	043ffe16 	blt	zero,r16,10101c98 <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
10101ca0:	0005883a 	mov	r2,zero
10101ca4:	dfc00117 	ldw	ra,4(sp)
10101ca8:	dc000017 	ldw	r16,0(sp)
10101cac:	dec00204 	addi	sp,sp,8
10101cb0:	f800283a 	ret

10101cb4 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101cb4:	0005883a 	mov	r2,zero
10101cb8:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10101cbc:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10101cc0:	10800804 	addi	r2,r2,32
10101cc4:	10fffd1e 	bne	r2,r3,10101cbc <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10101cc8:	f800283a 	ret

10101ccc <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10101ccc:	20000226 	beq	r4,zero,10101cd8 <alt_dev_llist_insert+0xc>
10101cd0:	20800217 	ldw	r2,8(r4)
10101cd4:	1000131e 	bne	r2,zero,10101d24 <alt_dev_llist_insert+0x58>
10101cd8:	00840434 	movhi	r2,4112
10101cdc:	10890a04 	addi	r2,r2,9256
10101ce0:	10800017 	ldw	r2,0(r2)
10101ce4:	10000926 	beq	r2,zero,10101d0c <alt_dev_llist_insert+0x40>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10101ce8:	deffff04 	addi	sp,sp,-4
10101cec:	dfc00015 	stw	ra,0(sp)
10101cf0:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101cf4:	00c00584 	movi	r3,22
10101cf8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101cfc:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101d00:	dfc00017 	ldw	ra,0(sp)
10101d04:	dec00104 	addi	sp,sp,4
10101d08:	f800283a 	ret
10101d0c:	00840434 	movhi	r2,4112
10101d10:	10892f04 	addi	r2,r2,9404
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10101d14:	00c00584 	movi	r3,22
10101d18:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
10101d1c:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10101d20:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
10101d24:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10101d28:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
10101d2c:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
10101d30:	28800017 	ldw	r2,0(r5)
10101d34:	11000115 	stw	r4,4(r2)
  list->next           = entry;
10101d38:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
10101d3c:	0005883a 	mov	r2,zero
10101d40:	f800283a 	ret

10101d44 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10101d44:	defffb04 	addi	sp,sp,-20
10101d48:	dcc00315 	stw	r19,12(sp)
10101d4c:	dc800215 	stw	r18,8(sp)
10101d50:	dc400115 	stw	r17,4(sp)
10101d54:	dc000015 	stw	r16,0(sp)
10101d58:	dfc00415 	stw	ra,16(sp)
10101d5c:	2027883a 	mov	r19,r4
10101d60:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
10101d64:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
10101d68:	0101e340 	call	10101e34 <strlen>
10101d6c:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10101d70:	84400726 	beq	r16,r17,10101d90 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10101d74:	81000217 	ldw	r4,8(r16)
10101d78:	980b883a 	mov	r5,r19
10101d7c:	900d883a 	mov	r6,r18
10101d80:	0101e040 	call	10101e04 <memcmp>
10101d84:	10000426 	beq	r2,zero,10101d98 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
10101d88:	84000017 	ldw	r16,0(r16)
10101d8c:	003ff806 	br	10101d70 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
10101d90:	0005883a 	mov	r2,zero
10101d94:	00000106 	br	10101d9c <alt_find_dev+0x58>
10101d98:	8005883a 	mov	r2,r16
}
10101d9c:	dfc00417 	ldw	ra,16(sp)
10101da0:	dcc00317 	ldw	r19,12(sp)
10101da4:	dc800217 	ldw	r18,8(sp)
10101da8:	dc400117 	ldw	r17,4(sp)
10101dac:	dc000017 	ldw	r16,0(sp)
10101db0:	dec00504 	addi	sp,sp,20
10101db4:	f800283a 	ret

10101db8 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
10101db8:	0009883a 	mov	r4,zero
10101dbc:	01440004 	movi	r5,4096
10101dc0:	0101dcc1 	jmpi	10101dcc <alt_icache_flush>

10101dc4 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10101dc4:	000170fa 	wrctl	ienable,zero
10101dc8:	f800283a 	ret

10101dcc <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
10101dcc:	00840004 	movi	r2,4096
10101dd0:	1140012e 	bgeu	r2,r5,10101dd8 <alt_icache_flush+0xc>
10101dd4:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
10101dd8:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101ddc:	2005883a 	mov	r2,r4
10101de0:	1140032e 	bgeu	r2,r5,10101df0 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
10101de4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10101de8:	10800804 	addi	r2,r2,32
10101dec:	003ffc06 	br	10101de0 <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10101df0:	210007cc 	andi	r4,r4,31
10101df4:	20000126 	beq	r4,zero,10101dfc <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
10101df8:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
10101dfc:	0000203a 	flushp
10101e00:	f800283a 	ret

10101e04 <memcmp>:
10101e04:	218d883a 	add	r6,r4,r6
10101e08:	21800826 	beq	r4,r6,10101e2c <memcmp+0x28>
10101e0c:	20800003 	ldbu	r2,0(r4)
10101e10:	28c00003 	ldbu	r3,0(r5)
10101e14:	10c00226 	beq	r2,r3,10101e20 <memcmp+0x1c>
10101e18:	10c5c83a 	sub	r2,r2,r3
10101e1c:	f800283a 	ret
10101e20:	21000044 	addi	r4,r4,1
10101e24:	29400044 	addi	r5,r5,1
10101e28:	003ff706 	br	10101e08 <memcmp+0x4>
10101e2c:	0005883a 	mov	r2,zero
10101e30:	f800283a 	ret

10101e34 <strlen>:
10101e34:	2005883a 	mov	r2,r4
10101e38:	10c00007 	ldb	r3,0(r2)
10101e3c:	18000226 	beq	r3,zero,10101e48 <strlen+0x14>
10101e40:	10800044 	addi	r2,r2,1
10101e44:	003ffc06 	br	10101e38 <strlen+0x4>
10101e48:	1105c83a 	sub	r2,r2,r4
10101e4c:	f800283a 	ret
